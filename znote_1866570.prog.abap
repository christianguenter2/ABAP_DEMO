*&---------------------------------------------------------------------*
*& Report  ZNOTE_1866570
*&
*&---------------------------------------------------------------------*
*&
*&
*&---------------------------------------------------------------------*

REPORT  znote_1866570.

* Generated by SAP_LOCAL_DOWNPORT_ASSISTANT Version 3.45 on 19.07.2013

* The individual coding starts at 'FORM action.' ( line 1.622 )

DATA trnlayer TYPE vtcetral-translayer.
PARAMETERS testrun  RADIOBUTTON GROUP mode.
PARAMETERS update   RADIOBUTTON GROUP mode.
DATA genview.
PARAMETERS showlogs RADIOBUTTON GROUP mode.
DATA: gv_copy_translation.

TYPE-POOLS: seox, seoc, seok, seex, bcwbn, ststc, trmtd.

TYPES: t_switch_id TYPE char30, "sfw_switch_id does not exist in SAP_BASIS 640
       t_bfunction TYPE char30, "sfw_bfunction does not exist in SAP_BASIS 640
       BEGIN OF t_bf_sw, "sfw_bf_sw
         switch_id TYPE t_switch_id,
         version,
         bfunction TYPE t_bfunction,
         no_check,
       END   OF t_bf_sw,
         BEGIN OF t_permission, client_pak(30), intf_name(30), err_sever(4), END OF t_permission, "has to be in sync with structure permission
         BEGIN OF dd43v,typename(30),seckeyname(30),ddlanguage,seckeyunique,accessmode,kind,keydescription(80),END OF dd43v.

TYPES: tt_dd05m      TYPE TABLE OF dd05m,
       tt_dd17v      TYPE TABLE OF dd17v,
       tt_dd26v      TYPE TABLE OF dd26v,
       tt_dd27p      TYPE TABLE OF dd27p,
       tt_dd28v      TYPE TABLE OF dd28v,
       tt_dd30v      TYPE TABLE OF dd30v,
       tt_dd30tv     TYPE TABLE OF dd30tv,
       tt_dd31v      TYPE TABLE OF dd31v,
       tt_dd32v      TYPE TABLE OF dd32v,
       tt_dd32p      TYPE TABLE OF dd32p,
       tt_dd33v      TYPE TABLE OF dd33v,
       tt_dd36m      TYPE TABLE OF dd36m,
       tt_dd42v      TYPE TABLE OF dd42v,
       tt_dd43v      TYPE TABLE OF dd43v,
       tt_e071k      TYPE TABLE OF e071k,
       tt_permission TYPE TABLE OF t_permission,
       tt_tstca      TYPE TABLE OF tstca,
       tt_langu      TYPE TABLE OF sylangu,
       tt_sta        TYPE TABLE OF rsmpe_stat,
       tt_fun        TYPE TABLE OF rsmpe_funt,
       tt_men        TYPE TABLE OF rsmpe_men,
       tt_mtx        TYPE TABLE OF rsmpe_mnlt,
       tt_act        TYPE TABLE OF rsmpe_act,
       tt_but        TYPE TABLE OF rsmpe_but,
       tt_pfk        TYPE TABLE OF rsmpe_pfk,
       tt_set        TYPE TABLE OF rsmpe_staf,
       tt_doc        TYPE TABLE OF rsmpe_atrt,
       tt_tit        TYPE TABLE OF rsmpe_titt,
       tt_biv        TYPE TABLE OF rsmpe_buts.

DATA: gr_devclass           TYPE RANGE OF devclass,
      gr_domname            TYPE RANGE OF domname,
      gr_rollname           TYPE RANGE OF rollname,
      gr_tabname            TYPE RANGE OF tabname, "structures and database tables
      gr_dbtabname          TYPE RANGE OF tabname, "only database tables
      gt_tabname            TYPE TABLE OF tabname,
      gr_indexes            TYPE RANGE OF trobj_name,
      gr_indxtab            TYPE RANGE OF tabname,
      gr_indxname           TYPE RANGE OF indexid,
      gr_shlpname           TYPE RANGE OF shlpname,
      gr_enqname            TYPE RANGE OF enqname,
      gr_viewname           TYPE RANGE OF viewname,
      gr_ttypname           TYPE RANGE OF ttypename,
      gt_ttypname           TYPE TABLE OF ttypename,
      gr_guistatus          TYPE RANGE OF progname,
      gr_switchname         TYPE RANGE OF t_switch_id,
      gr_msg_class          TYPE RANGE OF msgid,
      gv_trkorr             TYPE trkorr,
      gv_unit_test,
      gv_translation,
      gv_repository_changed,
      gv_errors_occured,
      gv_uname              TYPE syuname,
      gv_log_handle         TYPE balloghndl.


CONSTANTS: c_bal_object     TYPE balobj_d VALUE 'SNOTE',
           c_bal_subobj     TYPE balsubobj VALUE space,
           c_bal_context    TYPE tabname VALUE 'ADIR_KEY',
           c_include6       TYPE fieldname VALUE '.INCLU', ".INCLUDE or .INCLU--AP or .INCLU-_BY
           c_memory_id(40)  VALUE 'SAP_LOCAL_DOWNPORT_ASSISTANT',
           c_logical_object VALUE 'L'.

CONSTANTS: gc_report    TYPE text15 VALUE 'Report', "#EC NOTEXT
           gc_local     LIKE gc_report VALUE 'Local', "#EC NOTEXT
           gc_snote     LIKE gc_report VALUE 'SNote', "#EC NOTEXT
           gc_manual    LIKE gc_report VALUE 'Manual Instr. ', "#EC NOTEXT
           gc_bcset     LIKE gc_report VALUE 'Manual/BC-Set', "#EC NOTEXT
           gc_ignore    LIKE gc_report VALUE '-', "#EC NOTEXT
           gc_generate  LIKE gc_report VALUE 'Generation', "#EC NOTEXT
           gc_suppack   LIKE gc_report VALUE 'Supp.Pack.', "#EC NOTEXT
           gc_dest_init TYPE rfcdest VALUE 'MISSING INITIALIZATION'. "#EC NOTEXT

DATA: akb_get_tadir TYPE funcname VALUE 'AKB_GET_TADIR'.

*&---------------------------------------------------------------------*
*&      Form  bal_callback_ucomm
*&---------------------------------------------------------------------*
*       called from ballog, e.g. during double click
*----------------------------------------------------------------------*
FORM bal_callback_ucomm CHANGING c_state TYPE bal_s_cbuc.   "#EC CALLED
  DATA: ls_msg    TYPE bal_s_msg,
        l_date(8),
        ls_tadir  TYPE adir_key.
  CASE c_state-ucomm.
    WHEN '%LONGTEXT' OR '&IC1'.
      CALL FUNCTION 'BAL_LOG_MSG_READ'
        EXPORTING
          i_s_msg_handle = c_state-list_msgh
        IMPORTING
          e_s_msg        = ls_msg
        EXCEPTIONS
          log_not_found  = 1
          msg_not_found  = 2
          OTHERS         = 3.
      IF ls_msg-msgid EQ 'DO' AND ls_msg-msgno EQ '626'.
        "MESSAGE i626(do) WITH 'Click this message to view' 'detailed activation logs with name' l_logname INTO sy-lisel. "#EC *
        SPLIT ls_msg-msgv3 AT ':' INTO sy-lisel l_date.
        SUBMIT radprotb WITH protname EQ ls_msg-msgv3
                        WITH date     EQ l_date
*                       with TIME
*                       with USER
                        AND RETURN.
        c_state-ucomm_exec = 'X'.
      ELSEIF c_state-ucomm EQ '&IC1'.
        ls_tadir = ls_msg-context-value.
        CHECK ls_tadir-object IS NOT INITIAL.
        CALL FUNCTION 'RS_TOOL_ACCESS'
          EXPORTING
            operation   = 'SHOW'
            object_name = ls_tadir-obj_name
            object_type = ls_tadir-object
          EXCEPTIONS
            OTHERS      = 1.
        CHECK sy-subrc EQ 0.
        c_state-ucomm_exec = 'X'.
      ENDIF.
  ENDCASE.
ENDFORM.                    "bal_callback_ucomm
*&---------------------------------------------------------------------*
*&      Form  bdc_field
*&---------------------------------------------------------------------*
DEFINE bdc_field.
  clear: ls_bdc.
  ls_bdc-fnam = &1.
  ls_bdc-fval = &2.
  append ls_bdc to lt_bdc.
END-OF-DEFINITION.
*&---------------------------------------------------------------------*
*&      Form  bdc_field
*&---------------------------------------------------------------------*
DEFINE bdc_screen.
  clear ls_bdc.
  ls_bdc-program  = &1.
  ls_bdc-dynpro   = &2.
  ls_bdc-dynbegin = 'X'.
  append ls_bdc to lt_bdc.
END-OF-DEFINITION.
*----------------------------------------------------------------------*
*       CLASS lcl_wb DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_wb DEFINITION.
  PUBLIC SECTION.

    CLASS-METHODS init
       IMPORTING
         value(i_note)  TYPE clike OPTIONAL      "note which indicates that report is not needed anymore
         value(i_cinst) TYPE cwbcialeid OPTIONAL "correction instruction which describes the validity of the report
       EXCEPTIONS
         stop_processing.

    CLASS-METHODS get_object_text
      IMPORTING
        i_object   TYPE e071-object    "e.g. TABD
        i_obj_name TYPE c OPTIONAL     "for DOCU
      RETURNING value(r_text) TYPE string.

    CLASS-METHODS create_table_type       "create or change table without sorting
      IMPORTING
        i_typename   TYPE dd40v-typename
        i_rowtype    TYPE dd40v-rowtype
        i_accessmode TYPE dd40v-accessmode DEFAULT 'T'
        i_keydef     TYPE dd40v-keydef DEFAULT 'D'
        i_keykind    TYPE dd40v-keykind DEFAULT 'N'
        i_generic    TYPE dd40v-generic OPTIONAL
        i_rowkind    TYPE dd40v-rowkind  DEFAULT 'S'  "Default: Strcuture as line type
        i_datatype   TYPE dd40v-datatype DEFAULT 'STRU'
        i_leng       TYPE dd40v-leng     OPTIONAL "only for direct type entry
        i_decimals   TYPE dd40v-decimals OPTIONAL "only for direct type entry
        i_furtherseckey TYPE char1 OPTIONAL " TYPE dd40v-furtherseckey
        it_dd43v     TYPE tt_dd43v OPTIONAL  "only needed for secondary index
        it_dd42v     TYPE tt_dd42v OPTIONAL  "only needed for sorted tables
        i_langu      TYPE sylangu       DEFAULT 'E'   "Default EN
        i_devclass   TYPE devclass      OPTIONAL  "only needed for new table type
        i_ddtext     TYPE ddtext        OPTIONAL  "only needed for new table type
        i_proxytype  TYPE ddproxyty     OPTIONAL.

    CLASS-METHODS create_table    "or structure or append or database table
      IMPORTING
        i_tabname    TYPE tabname
        i_devclass   TYPE devclass
        i_exclass    TYPE dd02v-exclass  OPTIONAL
        i_langu      TYPE sylangu   DEFAULT 'E'   "Default EN
        i_ddtext     TYPE ddtext    OPTIONAL      "can be taken from tabname
        i_authclass  TYPE dd02v-authclass DEFAULT '00'
        i_mainflag   TYPE dd02v-mainflag OPTIONAL
        i_tabclass   TYPE tabclass  DEFAULT 'INTTAB'
        i_sqltab     TYPE sqlappdtab OPTIONAL
        i_proxytype  TYPE ddproxyty         OPTIONAL
        i_contflag   TYPE contflag         DEFAULT 'C'     "only needed for db tables
        i_tabkat     TYPE dd09v-tabkat     DEFAULT '0'     "only needed for db tables
        i_tabart     TYPE dd09v-tabart     DEFAULT 'APPL2' "only needed for db tables
        i_bufallow   TYPE dd09v-bufallow   DEFAULT 'N'     "only needed for db tables
        i_pufferung  TYPE dd09v-pufferung  OPTIONAL        "only needed for db tables
        i_schfeldanz TYPE dd09v-schfeldanz OPTIONAL        "only needed for db tables
        i_speichpuff TYPE dd09v-speichpuff OPTIONAL        "only needed for db tables
        i_javaonly   TYPE xfeld OPTIONAL  "dd09v-javaonly  "only needed for db tables   ">=SAPBASIS700
        i_protokoll  TYPE dd09v-protokoll  OPTIONAL.       "only needed for db tables

    CLASS-METHODS add_to_transport
      IMPORTING
        i_object   TYPE e071-object    "TABD
        i_obj_name TYPE c     "flexible number of characters
        i_devclass TYPE devclass OPTIONAL
        i_langu    TYPE sylangu OPTIONAL
      EXCEPTIONS
        error
        simulation.

    CLASS-METHODS register_inactive_object
        IMPORTING
           i_objtype  TYPE e071-object
           i_treetype TYPE e071-object OPTIONAL  "space = do not update tree, optionally different type in tree, e.g. TABL vs. CDS
           i_objname TYPE c.

    CLASS-METHODS log_message.

    CLASS-METHODS display_log.

    CLASS-METHODS set_context
      IMPORTING i_object    TYPE e071-object
                i_obj_name  TYPE c
                i_obj_name2 TYPE c OPTIONAL
                i_text      TYPE c OPTIONAL
                i_langu     TYPE sylangu.

    CLASS-METHODS activate
      IMPORTING i_result_auth_check TYPE sysubrc OPTIONAL.

    CLASS-METHODS mass_activation
      IMPORTING
        i_step     TYPE i      DEFAULT 1
        i_inactive TYPE c      OPTIONAL
        i_ddmode   TYPE ddmode DEFAULT 'O'
        i_logname  TYPE c
       EXCEPTIONS
         error.
ENDCLASS.                    "lcl_wb DEFINITION
*----------------------------------------------------------------------*
*       CLASS lcl_dcm_to_po_bridge IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcl_wb IMPLEMENTATION.

  METHOD init.


    CLEAR gv_errors_occured.

    CALL FUNCTION 'AUTHORITY_CHECK_TCODE'
      EXPORTING
        tcode  = 'SNOTE'
      EXCEPTIONS
        ok     = 0
        OTHERS = 1.
    IF sy-subrc NE 0.
      MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      gv_errors_occured = 'X'.
      RAISE stop_processing.
    ENDIF.

    IF showlogs IS NOT INITIAL.
      CALL METHOD display_log.
      LEAVE PROGRAM.
    ENDIF.

    DATA: ls_log TYPE bal_s_log.
    "prepare application log
    ls_log-object    = c_bal_object.
    ls_log-subobject = c_bal_subobj.
    ls_log-extnumber = sy-cprog.
    ls_log-aldate    = sy-datum.
    ls_log-altime    = sy-uzeit.
    ls_log-aluser    = sy-uname.
    ls_log-alprog    = sy-repid.
    ls_log-altcode   = sy-tcode.
    "create standard application log handle
    CALL FUNCTION 'BAL_LOG_CREATE'
      EXPORTING
        i_s_log                 = ls_log
      IMPORTING
        e_log_handle            = gv_log_handle
      EXCEPTIONS
        log_header_inconsistent = 1
        OTHERS                  = 2.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    EXPORT gv_log_handle FROM gv_log_handle TO MEMORY ID c_memory_id.

    CALL METHOD set_context
      EXPORTING
        i_langu    = space
        i_object   = space
        i_obj_name = space.


    "Main check: Last changed by SAP -> Report came via SP / Upgrade
    "==> no execution anymore.
    IF sy-cprog NE 'SAP_LOCAL_DOWNPORT_ASSISTANT'.
      SELECT SINGLE prog FROM d010sinf INTO sy-lisel
                        WHERE prog   EQ sy-repid
                          AND ( unam EQ 'SAP' OR cnam EQ 'SAP' ).
      IF sy-subrc EQ 0.
        MESSAGE w666(01) WITH 'The neccessary changes already came' 'via support package.' 'Report execution not required anymore.' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        CALL METHOD display_log.
        RAISE stop_processing.
      ENDIF.
    ENDIF.

    IF i_note IS NOT INITIAL.
*     that that note is not already implemented
*     this must not be the note containing the generated report for DDIC but a follow-up note with the coding using that new DDIC
      DATA l_status TYPE c.
      CALL FUNCTION 'SCWB_NOTE_IMPL_STATUS_SIMPLE'
        EXPORTING
          iv_numm   = i_note
        IMPORTING
          ev_status = l_status
        EXCEPTIONS
          OTHERS    = 1.
      CASE l_status.
        WHEN 'E'.
          MESSAGE w666(01) WITH 'SAP Note' i_note 'completely implemented;' 'Report execution not required anymore.' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
          CALL METHOD display_log.
          RAISE stop_processing.
        WHEN 'O'.
          MESSAGE w666(01) WITH 'SAP Note' i_note 'is obsolete;' 'Report execution not required anymore.' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
          CALL METHOD display_log.
          RAISE stop_processing.
        WHEN OTHERS. "okay
          DATA: ls_note TYPE  bcwbn_note.
          ls_note-key-numm = i_note.
          CALL FUNCTION 'SCWB_NOTE_READ'
            EXPORTING
              iv_read_corr_instructions  = 'X'
            CHANGING
              cs_note                    = ls_note
            EXCEPTIONS
              note_not_found             = 1
              language_not_found         = 2
              unreadable_text_format     = 3
              corr_instruction_not_found = 4
              OTHERS                     = 5.
          IF sy-subrc <> 0.
            MESSAGE e666(01) WITH 'SAP Note' i_note 'cannot be read;' 'Ensure correct download of note first.' INTO sy-lisel. "#EC *
            CALL METHOD log_message.
            CALL METHOD display_log.
            RAISE stop_processing.
          ENDIF.
*------
          FIELD-SYMBOLS: <ls_corr> TYPE bcwbn_corr_instruction.
          DATA: l_valid TYPE bcwbn_bool.
          LOOP AT ls_note-corr_instructions ASSIGNING <ls_corr>.
            IF i_cinst IS NOT INITIAL.
              CHECK <ls_corr>-key-aleid = i_cinst.
            ENDIF.
            CALL FUNCTION 'SCWB_CINST_CHECK_VALID'
              IMPORTING
                ev_valid                   = l_valid
              CHANGING
                cs_corr_instruction        = <ls_corr>
              EXCEPTIONS
                corr_inst_not_found        = 1
                inconsistent_delivery_data = 2
                undefined                  = 3
                OTHERS                     = 4.
            IF sy-subrc <> 0.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ENDIF.
            IF l_valid IS NOT INITIAL.
              EXIT.
            ENDIF.
          ENDLOOP.
          IF l_valid IS INITIAL.
            MESSAGE e666(01) WITH 'Manual changes cannot be applied;' 'Correction instruction invalid' 'for current patch level' INTO sy-lisel. "#EC *
            CALL METHOD log_message.
            CALL METHOD display_log.
            RAISE stop_processing.
          ENDIF.
      ENDCASE.
    ENDIF.

    CALL FUNCTION 'SCWG_TOOLFLAG_SET'. "Reset will happen at leave of program

    IF testrun IS INITIAL.
      MESSAGE i666(01) WITH 'Running in Update Mode' INTO sy-lisel. "#EC *
    ELSE.
      MESSAGE w666(01) WITH 'Running in Test Mode' INTO sy-lisel. "#EC *
    ENDIF.
    CALL METHOD log_message.

  ENDMETHOD.                    "init


  METHOD get_object_text.

    STATICS: lt_object_text TYPE TABLE OF ko100,
             lt_doktypes    TYPE TABLE OF dd07v.

    DATA: ls_object_text TYPE ko100,
          ls_doktype     TYPE dd07v.

    IF lt_object_text IS INITIAL.
      CALL FUNCTION 'TR_OBJECT_TABLE'
        TABLES
          wt_object_text = lt_object_text.
      SORT lt_object_text BY object.

      CALL FUNCTION 'DDIF_DOMA_GET'
        EXPORTING
          name      = 'DOK_ID'
          langu     = sy-langu
        TABLES
          dd07v_tab = lt_doktypes
        EXCEPTIONS
          OTHERS    = 0.
      SORT lt_doktypes BY domvalue_l.
    ENDIF.

    IF i_object EQ 'DOCU'.
      READ TABLE lt_doktypes INTO ls_doktype BINARY SEARCH
        WITH KEY domvalue_l = i_obj_name(2).
      IF sy-subrc EQ 0.
        CONCATENATE 'Documentation' ls_doktype-ddtext INTO r_text SEPARATED BY space. "#EC NOTEXT
      ELSE.
        r_text = 'Documentation'.                           "#EC NOTEXT
      ENDIF.
    ELSEIF i_object IS NOT INITIAL.
      READ TABLE lt_object_text INTO ls_object_text BINARY SEARCH
        WITH KEY object = i_object.  "ignore PGMID!
      IF sy-subrc EQ 0.
        r_text = ls_object_text-text.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "get_object_text








  METHOD create_table_type.

    DATA: ls_dd40v    TYPE dd40v,
          lt_dd42v    TYPE tt_dd42v,
          lt_dd43v    TYPE tt_dd43v,
          ls_ttypname LIKE LINE OF gr_ttypname VALUE 'IEQ'.

    CALL METHOD set_context
      EXPORTING
        i_langu    = i_langu
        i_object   = 'TTYP'
        i_obj_name = i_typename.

    ls_ttypname-low = i_typename.
    COLLECT ls_ttypname INTO gr_ttypname.

    CALL FUNCTION 'DDIF_TTYP_GET'
      EXPORTING
        name          = i_typename
        state         = 'M'
        langu         = i_langu    "with text
      IMPORTING
        dd40v_wa      = ls_dd40v
      TABLES
        dd42v_tab     = lt_dd42v
        dd43v_tab     = lt_dd43v                                            ">=SAPBASIS702
*       dd43v_tab     = lt_dd43v
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc EQ 0     AND  "exists
    ( ls_dd40v-ddtext = i_ddtext OR i_ddtext IS INITIAL ) AND
      ls_dd40v-rowtype       = i_rowtype       AND
      ls_dd40v-datatype      = i_datatype      AND
      ( ls_dd40v-leng     = i_leng     OR i_leng     IS INITIAL ) AND
      ( ls_dd40v-decimals = i_decimals OR i_decimals IS INITIAL ) AND
      ls_dd40v-rowkind       = i_rowkind       AND
      ls_dd40v-accessmode    = i_accessmode    AND
      ls_dd40v-keydef        = i_keydef        AND
      ls_dd40v-keykind       = i_keykind       AND
      ls_dd40v-generic       = i_generic       AND
      ls_dd40v-proxytype     = i_proxytype     AND
*     ls_dd40v-furtherseckey = i_furtherseckey AND
      ls_dd40v-furtherseckey = i_furtherseckey AND                          ">=SAPBASIS702
      lt_dd43v               = it_dd43v        AND
      lt_dd42v               = it_dd42v.
      MESSAGE i666(01) WITH 'No update necessary' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    CHECK testrun IS INITIAL.

    ls_dd40v-typename   = i_typename.
    ls_dd40v-rowtype    = i_rowtype.
    ls_dd40v-rowkind    = i_rowkind.
    ls_dd40v-datatype   = i_datatype.
    ls_dd40v-leng       = i_leng.
    ls_dd40v-decimals   = i_decimals.
    ls_dd40v-accessmode = i_accessmode.
    ls_dd40v-keydef     = i_keydef.
    ls_dd40v-keykind    = i_keykind.
    ls_dd40v-proxytype  = i_proxytype.
    ls_dd40v-generic    = i_generic.
*   ls_dd40v-furtherseckey = i_furtherseckey.
    ls_dd40v-furtherseckey = i_furtherseckey.                              ">=SAPBASIS702
    IF i_ddtext IS NOT INITIAL.
      ls_dd40v-ddtext     = i_ddtext.
      ls_dd40v-ddlanguage = i_langu.
    ENDIF.

    CALL METHOD add_to_transport
      EXPORTING
        i_object   = 'TTYP'
        i_langu    = i_langu
        i_obj_name = i_typename
        i_devclass = i_devclass
      EXCEPTIONS
        OTHERS     = 1.
    CHECK sy-subrc EQ 0.

    CALL FUNCTION 'DDIF_TTYP_PUT'
      EXPORTING
        name              = i_typename
        dd40v_wa          = ls_dd40v
      TABLES
        dd42v_tab         = it_dd42v
*       dd43v_tab         = it_dd43v
        dd43v_tab         = it_dd43v                                      ">=SAPBASIS702
      EXCEPTIONS
        ttyp_not_found    = 1
        name_inconsistent = 2
        ttyp_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc NE 0.
      CALL METHOD log_message.
      RETURN.
    ELSE.
      MESSAGE i666(01) WITH 'Update successful' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
    ENDIF.

    CALL METHOD register_inactive_object
      EXPORTING
        i_objtype = 'TTYP'
        i_objname = i_typename.


  ENDMETHOD.                    "create_table_type



  METHOD create_table.
    DATA: ls_dd02v   TYPE dd02v,
          ls_dd09l   TYPE dd09l,
          lt_dd03p   TYPE TABLE OF dd03p,
          lt_dd05m   TYPE TABLE OF dd05m,
          lt_dd08v   TYPE TABLE OF dd08v,
          lt_dd12v   TYPE TABLE OF dd12v,
          lt_dd17v   TYPE TABLE OF dd17v,
          lt_dd35v   TYPE TABLE OF dd35v,
          lt_dd36m   TYPE TABLE OF dd36m,
          l_treetype TYPE trobjtype,
          ls_tabname LIKE LINE OF gr_tabname VALUE 'IEQ'.

    FIELD-SYMBOLS: <ls_dd09l_javaonly> TYPE char1.

    CALL METHOD set_context
      EXPORTING
        i_langu    = i_langu
        i_object   = 'TABD'
        i_obj_name = i_tabname.

    ls_tabname-low = i_tabname.
    COLLECT ls_tabname INTO gr_tabname.

    ASSIGN ('LS_DD09L-JAVAONLY') TO <ls_dd09l_javaonly>.                ">=SAPBASIS700

    CALL FUNCTION 'DDIF_TABL_GET'
      EXPORTING
        name          = i_tabname
        state         = 'M'  "newest version (e.g. inactive)
        langu         = i_langu
      IMPORTING
*       GOTSTATE      = GOTSTATE
        dd02v_wa      = ls_dd02v
        dd09l_wa      = ls_dd09l
      TABLES
        dd03p_tab     = lt_dd03p
        dd05m_tab     = lt_dd05m
        dd08v_tab     = lt_dd08v
        dd12v_tab     = lt_dd12v
        dd17v_tab     = lt_dd17v
        dd35v_tab     = lt_dd35v
        dd36m_tab     = lt_dd36m
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    IF sy-subrc           EQ 0           AND
       ls_dd02v-tabname   IS NOT INITIAL AND "existing.
       ls_dd02v-ddtext    EQ i_ddtext    AND
       ls_dd02v-exclass   EQ i_exclass   AND
       ls_dd02v-tabclass  EQ i_tabclass  AND
       ls_dd02v-authclass EQ i_authclass AND
       ls_dd02v-mainflag  EQ i_mainflag  AND
       ls_dd02v-proxytype EQ i_proxytype AND
       ls_dd02v-sqltab    EQ i_sqltab.

      IF ( ls_dd02v-tabclass   EQ 'INTTAB' ) OR
         ( ls_dd02v-contflag   EQ i_contflag   AND
           ls_dd09l-tabkat     EQ i_tabkat     AND
           ls_dd09l-tabart     EQ i_tabart     AND
           ls_dd09l-pufferung  EQ i_pufferung  AND
           ls_dd09l-bufallow   EQ i_bufallow   AND
           ls_dd09l-schfeldanz EQ i_schfeldanz AND
           ls_dd09l-protokoll  EQ i_protokoll  AND
           "ls_dd09l-javaonly   EQ i_javaonly   AND     ">=SAPBASIS700
           ls_dd09l-speichpuff EQ i_speichpuff ).   "do not check javaonly field
        MESSAGE i666(01) WITH 'No update necessary' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        RETURN.
      ENDIF.

    ENDIF.

    CHECK testrun IS INITIAL.

    "new table
    ls_dd02v-tabname    = i_tabname.
    ls_dd02v-ddlanguage = i_langu.
    ls_dd02v-exclass    = i_exclass.
    ls_dd02v-tabclass   = i_tabclass.
    ls_dd02v-authclass  = i_authclass.
    ls_dd02v-mainflag   = i_mainflag.
    ls_dd02v-proxytype  = i_proxytype.
    ls_dd02v-sqltab     = i_sqltab.

    IF i_ddtext IS INITIAL.
      ls_dd02v-ddtext   = i_tabname.
    ELSE.
      ls_dd02v-ddtext   = i_ddtext.
    ENDIF.

    IF ls_dd02v-tabclass EQ 'CLUSTER' OR  "only for real database tables
       ls_dd02v-tabclass EQ 'POOL'    OR
       ls_dd02v-tabclass EQ 'TRANSP'.
      ls_dd02v-contflag   = i_contflag.
      ls_dd09l-tabname    = i_tabname.
      ls_dd09l-tabkat     = i_tabkat.
      ls_dd09l-tabart     = i_tabart.
      ls_dd09l-pufferung  = i_pufferung.
      ls_dd09l-bufallow   = i_bufallow.
      ls_dd09l-schfeldanz = i_schfeldanz.
      ls_dd09l-protokoll  = i_protokoll.
      ls_dd09l-speichpuff = i_speichpuff.
      IF <ls_dd09l_javaonly> IS ASSIGNED.         ">=SAPBASIS700
        <ls_dd09l_javaonly> = i_javaonly.         ">=SAPBASIS700
      ENDIF.                                      ">=SAPBASIS700
      l_treetype = 'TABL'.
    ELSE.
      l_treetype = 'CDS'.
    ENDIF.

    CALL METHOD add_to_transport
      EXPORTING
        i_object   = 'TABL'
        i_langu    = i_langu
        i_obj_name = i_tabname
        i_devclass = i_devclass
      EXCEPTIONS
        OTHERS     = 1.
    CHECK sy-subrc EQ 0.

    CALL FUNCTION 'DDIF_TABL_PUT'
      EXPORTING
        name              = i_tabname
        dd02v_wa          = ls_dd02v
        dd09l_wa          = ls_dd09l
      TABLES
        dd03p_tab         = lt_dd03p
        dd05m_tab         = lt_dd05m
        dd08v_tab         = lt_dd08v
        dd35v_tab         = lt_dd35v
        dd36m_tab         = lt_dd36m
      EXCEPTIONS
        tabl_not_found    = 1
        name_inconsistent = 2
        tabl_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc <> 0.
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    MESSAGE i666(01) WITH 'Update successful' INTO sy-lisel. "#EC *
    CALL METHOD log_message.

    CALL METHOD register_inactive_object
      EXPORTING
        i_objtype  = 'TABL'
        i_treetype = l_treetype
        i_objname  = i_tabname.


  ENDMETHOD.                    "create_table







  METHOD activate.

    DATA: lt_dwinactiv      TYPE TABLE OF dwinactiv,
          lt_dwinactiv_ddic TYPE TABLE OF dwinactiv,
          lv_answer,
          l_logname         TYPE ddprh-protname,
          ls_job            TYPE tbtcjob,
          lv_rc             TYPE sysubrc,
          l_dref            TYPE REF TO data,
          l_message         TYPE sy-lisel,
          ls_tabname        LIKE LINE OF gr_tabname.

    FIELD-SYMBOLS: <ls_dwinactiv> LIKE LINE OF lt_dwinactiv.

    CALL METHOD set_context
      EXPORTING
        i_langu    = space
        i_object   = space
        i_obj_name = 'Activation'.                          "#EC *

    IF testrun IS INITIAL.

      "activate switches "online"
      IF gr_switchname IS NOT INITIAL.
        SELECT * FROM dwinactiv INTO TABLE lt_dwinactiv
                                     WHERE obj_name IN gr_switchname.
        IF lt_dwinactiv[] IS  NOT INITIAL.
          LOOP AT lt_dwinactiv ASSIGNING <ls_dwinactiv>
                                WHERE uname NE sy-uname
                                  AND obj_name IN gr_switchname.
            <ls_dwinactiv>-uname = sy-uname.
          ENDLOOP.
          INSERT dwinactiv FROM TABLE lt_dwinactiv ACCEPTING DUPLICATE KEYS.
        ENDIF.

        MESSAGE s357(scwn).
        CALL FUNCTION 'RS_WORKING_OBJECT_ACTIVATE'
          EXPORTING
            dictionary_only = 'X'
          TABLES
            objects         = lt_dwinactiv
          EXCEPTIONS
            OTHERS          = 5.
      ENDIF.

      "make sure that ranges are not empty
      APPEND 'IEQ' TO: "gr_switchname,
                       gr_domname,
                       gr_rollname,
                       gr_tabname,
                       gr_shlpname,
                       gr_viewname,
                       gr_enqname,
                       gr_ttypname,
                       gr_guistatus,
                       gr_indexes,
                       gr_indxtab,
                       gr_indxname.

      SELECT * FROM dwinactiv INTO TABLE lt_dwinactiv
              WHERE ( object NE space )   "dummy
                AND ( "obj_name IN gr_switchname OR
                      obj_name IN gr_domname
                   OR obj_name IN gr_rollname
                   OR obj_name IN gr_tabname
                   OR obj_name IN gr_shlpname
                   OR obj_name IN gr_viewname
                   OR obj_name IN gr_enqname
                   OR obj_name IN gr_ttypname
                   OR obj_name IN gr_guistatus
                   OR obj_name IN gr_indexes ).
    ENDIF.

    "add all relevant inactive objects also to current user's worklist
    "gets relevant if a different user is doing the activation.
    "entries for all users will be deleted if any user activates the object
    LOOP AT lt_dwinactiv ASSIGNING <ls_dwinactiv> WHERE uname NE sy-uname.
      <ls_dwinactiv>-uname = sy-uname.
    ENDLOOP.
    INSERT dwinactiv FROM TABLE lt_dwinactiv ACCEPTING DUPLICATE KEYS.

    LOOP AT lt_dwinactiv ASSIGNING <ls_dwinactiv>
                             WHERE object EQ 'DOMA' OR
                                   object EQ 'DTEL' OR
                                   object EQ 'TABL' OR
                                   object EQ 'INDX' OR
                                   object EQ 'VIEW' OR
                                   object EQ 'ENQU' OR
                                   object EQ 'TTYP' OR
                                   object EQ 'SHLP'.
      CALL FUNCTION 'RS_DD_CHECK_ACTIVATE'
        EXPORTING
          objtype = <ls_dwinactiv>-object
          objname = <ls_dwinactiv>-obj_name
*         i_no_ui = 'X' "not in all sap_basis releases
        EXCEPTIONS
          OTHERS  = 1.
      IF sy-subrc EQ 0.
        "DDIC always via RADMASG0
        "move DDIC objects to separate worklist
        APPEND <ls_dwinactiv> TO lt_dwinactiv_ddic.
        DELETE lt_dwinactiv.
      ELSE.
        MESSAGE e666(01) WITH 'No authorization to activate' <ls_dwinactiv>-object <ls_dwinactiv>-obj_name '. Call transaction SU53 for details' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        CASE <ls_dwinactiv>-object.
          WHEN 'DOMA'. DELETE gr_domname  WHERE low EQ <ls_dwinactiv>-obj_name.
          WHEN 'DTEL'. DELETE gr_rollname WHERE low EQ <ls_dwinactiv>-obj_name.
          WHEN 'TABL'.
            DELETE gr_tabname  WHERE low EQ <ls_dwinactiv>-obj_name.
            DELETE gr_indxtab  WHERE low EQ <ls_dwinactiv>-obj_name.
          WHEN 'INDX'. DELETE gr_indxname WHERE low EQ <ls_dwinactiv>-obj_name.
          WHEN 'VIEW'. DELETE gr_viewname WHERE low EQ <ls_dwinactiv>-obj_name.
          WHEN 'ENQU'. DELETE gr_enqname  WHERE low EQ <ls_dwinactiv>-obj_name.
          WHEN 'TTYP'. DELETE gr_ttypname WHERE low EQ <ls_dwinactiv>-obj_name.
          WHEN 'SHLP'. DELETE gr_shlpname WHERE low EQ <ls_dwinactiv>-obj_name.
        ENDCASE.
        DELETE lt_dwinactiv.
      ENDIF.
    ENDLOOP.

    IF lt_dwinactiv[] IS INITIAL AND lt_dwinactiv_ddic[] IS INITIAL AND gv_repository_changed IS INITIAL.
      MESSAGE i666(01) WITH 'No repository changes made' '' '' '' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      IF gv_translation EQ 'X' OR gv_copy_translation EQ 'X'.
        MESSAGE i666(01) WITH 'Translation has been updated' '' '' '' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
      ENDIF.
    ELSEIF gv_errors_occured IS NOT INITIAL.
      MESSAGE w666(01) WITH 'Activation was skipped because of errors' 'in previous steps. Please try again.' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
    ELSEIF i_result_auth_check IS NOT INITIAL.
      MESSAGE e666(01) WITH 'No authorization to activate the DDIC changes.' 'Call transaction SU53 for details' '' '' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
    ELSE.  "do the activation

      IF lt_dwinactiv[] IS NOT INITIAL.
        "1) activate non DDIC objects (e.g. CUAD) online
        MESSAGE s357(scwn).
        CALL FUNCTION 'RS_WORKING_OBJECT_ACTIVATE'
          EXPORTING
            dictionary_only = ' '
*           cwb_mode        = 'X'
          TABLES
            objects         = lt_dwinactiv
          EXCEPTIONS
            OTHERS          = 5.
        IF sy-subrc NE 0.
          lv_answer = 'A'.
          CALL METHOD log_message.
          MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      ENDIF.

      IF lt_dwinactiv_ddic[] IS NOT INITIAL AND lv_answer NE 'A'.
        IF gv_unit_test IS NOT INITIAL OR genview IS NOT INITIAL.
          lv_answer = '1'.  "force online activation
        ELSE.
          CALL FUNCTION 'POPUP_TO_CONFIRM'
            EXPORTING
              titlebar              = 'Activation'          "#EC NOTEXT
              text_question         = 'How do you want to activate DDIC?' "#EC NOTEXT
              text_button_1         = 'Online'              "#EC NOTEXT
              text_button_2         = 'Batch'               "#EC NOTEXT
              display_cancel_button = 'X'
            IMPORTING
              answer                = lv_answer
            EXCEPTIONS
              OTHERS                = 1.
          IF sy-subrc <> 0.
            MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            CALL METHOD log_message.
          ENDIF.
        ENDIF.
      ENDIF.

      IF sy-repid(2) EQ '%_'. "Temp. Subroutine Pool
        l_logname = 'UDO'.
      ELSEIF sy-repid(1) EQ '/'.
        SPLIT sy-repid AT '/' INTO l_logname l_logname l_logname. "remove namespace
      ELSE.
        l_logname = sy-repid.
      ENDIF.
      CONCATENATE l_logname sy-datum sy-uzeit INTO l_logname SEPARATED BY '_'.

      IF lv_answer EQ '1'.  "online
        "2a) activate DDIC online
        IF sy-repid(2) EQ '%_'. "Temp. Subroutine Pool
          l_logname = 'UDO'.
        ELSEIF sy-repid(1) EQ '/'.
          SPLIT sy-repid AT '/' INTO l_logname l_logname l_logname. "remove namespace
        ELSE.
          l_logname = sy-repid.
        ENDIF.

        CONCATENATE l_logname ':' sy-datum ':' sy-uzeit INTO l_logname.

        CALL METHOD mass_activation   "Step 1
          EXPORTING
            i_step     = 1
            i_logname  = space "no log, any error messages will appear in step 2 also
            i_ddmode   = 'T'
            i_inactive = 'X'
          EXCEPTIONS
            error      = 1.
        IF sy-subrc EQ 0.
          CALL METHOD mass_activation  "Step 2
            EXPORTING
              i_step     = 2
              i_logname  = l_logname
              i_ddmode   = 'O'
              i_inactive = ' '
            EXCEPTIONS
              error      = 1.
        ENDIF.

        CLEAR l_message.
        IF sy-subrc EQ 0.
          LOOP AT gr_dbtabname INTO ls_tabname WHERE low IS NOT INITIAL.
            "make a test SELECT * FROM table UP TP 1 ROWS to see whether it is really consistent
            "go via RFC to have the chance to catch short dumps
            "or GET_TABLE_KEYLIST_RFC
            CALL FUNCTION 'RFC_READ_TABLE' DESTINATION 'NONE' "#EC FB_PAR_MIS
              EXPORTING
                query_table         = ls_tabname-low
                rowcount            = 1
              EXCEPTIONS
                system_failure      = 1  MESSAGE l_message
                table_not_available = 0
                OTHERS              = 0.
            IF sy-subrc <> 0.
              IF l_message CS 'ASSIGN ... CASTING'.   "RFC_READ_TABLE does not like SSTRING fields
                MESSAGE i666(01) WITH 'Skipping additional check' 'for database table' ls_tabname-low INTO sy-lisel. "#EC *
                CLEAR l_message.  "we do not treat the as an error
              ELSE.
                MESSAGE e666(01) WITH l_message INTO sy-lisel. "#EC *
              ENDIF.
              CALL METHOD log_message.
            ENDIF.
          ENDLOOP.

          APPEND LINES OF gr_ttypname TO gr_tabname.
          APPEND LINES OF gr_rollname TO gr_tabname.

          LOOP AT gr_tabname INTO ls_tabname WHERE low IS NOT INITIAL.
            TRY.
                CREATE DATA l_dref TYPE (ls_tabname-low).
              CATCH cx_sy_create_data_error.
                MESSAGE e666(01) WITH 'Data Type' ls_tabname-low 'is inconsistent' INTO l_message. "#EC *
                CALL METHOD log_message.
            ENDTRY.
          ENDLOOP.
          IF l_message IS INITIAL.
            CLEAR sy-subrc.
          ELSE.
            MESSAGE e666(01) WITH 'DDIC activation step 3 ended with errors.' INTO sy-lisel. "#EC *
            CALL METHOD log_message.
            sy-subrc = 4.
          ENDIF.
        ENDIF.

        IF sy-subrc EQ 0.
          MESSAGE s666(01) WITH 'DDIC activation successful' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
          MESSAGE i626(do) WITH 'Click this message to view' 'detailed activation logs with name' l_logname INTO sy-lisel. "#EC *
          CALL METHOD log_message.
        ELSE.
          "e.g. no authorization for activation or conversion of dependent database tables
          "make sure that the objects appear as inactive; corresponding are removed by DDIC activation phase 1 although phase 2 or 3 may fail.
          MODIFY dwinactiv FROM TABLE lt_dwinactiv_ddic.
          MESSAGE e626(do) WITH 'Click this message to view' 'detailed activation logs with name' l_logname INTO sy-lisel. "#EC *
          CALL METHOD log_message.
        ENDIF.

      ELSEIF lv_answer EQ '2' .
        "2b) activate DDIC objects via batch job
        ls_job-jobname = sy-repid.

        CALL FUNCTION 'JOB_OPEN'
          EXPORTING
            jobname          = ls_job-jobname
          IMPORTING
            jobcount         = ls_job-jobcount
          CHANGING
            ret              = lv_rc
          EXCEPTIONS
            cant_create_job  = 1
            invalid_job_data = 2
            jobname_missing  = 3
            OTHERS           = 4.
        IF sy-subrc <> 0 OR lv_rc NE 0.
          MESSAGE e026(bt) WITH ls_job-jobname INTO sy-lisel. "#EC *
          CALL METHOD log_message.
        ELSE.
          SUBMIT radmasg0 WITH domname  IN gr_domname
                          WITH rollname IN gr_rollname
                          WITH tabname  IN gr_tabname
                          WITH indxtab  IN gr_indxtab
                          WITH indxname IN gr_indxname
                          WITH viewname IN gr_viewname
                          WITH ttypname IN gr_ttypname
                          WITH shlpname IN gr_shlpname
                          WITH logname  EQ l_logname
                          WITH logshow  EQ 'X'      "show log in SPOOL

                          WITH ddmode   EQ 'T'
                          WITH inactive EQ 'X'

                          VIA JOB ls_job-jobname
                          NUMBER ls_job-jobcount
                          AND RETURN.

          SUBMIT radmasg0 WITH domname  IN gr_domname
                          WITH rollname IN gr_rollname
                          WITH tabname  IN gr_tabname
                          WITH indxtab  IN gr_indxtab
                          WITH indxname IN gr_indxname
                          WITH viewname IN gr_viewname
                          WITH ttypname IN gr_ttypname
                          WITH shlpname IN gr_shlpname
                          WITH logname  EQ l_logname
                          WITH logshow  EQ 'X'      "show log in SPOOL

                          WITH ddmode   EQ 'O'
                          WITH inactive EQ ' '

                          VIA JOB ls_job-jobname
                          NUMBER ls_job-jobcount
                          AND RETURN.

          CALL FUNCTION 'JOB_CLOSE'
            EXPORTING
              jobcount  = ls_job-jobcount
              jobname   = ls_job-jobname
              strtimmed = 'X'
            EXCEPTIONS
              OTHERS    = 1.
          IF sy-subrc EQ 0.
            MESSAGE s305(ut) WITH ls_job-jobname INTO sy-lisel. "#EC *
            CALL METHOD log_message.
            MESSAGE i666(01) WITH 'Use Report RADPROTB to view' 'activation log' l_logname 'after job has finished in transaction SMX.'. "#EC *
            CALL METHOD log_message.
          ELSE.
            MESSAGE e026(bt) WITH ls_job-jobname INTO sy-lisel. "#EC *
            CALL METHOD log_message.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.

    SET PARAMETER ID 'EUK' FIELD space.
    EXPORT current_devclass FROM space TO MEMORY ID 'EUK'.

  ENDMETHOD.                    "activate

  METHOD mass_activation.

    DATA: lt_log TYPE TABLE OF trlog,
          ls_log TYPE trlog.

    SUBMIT radmasg0 WITH domname  IN gr_domname
                    WITH rollname IN gr_rollname
                    WITH tabname  IN gr_tabname
                    WITH indxtab  IN gr_indxtab
                    WITH indxname IN gr_indxname
                    WITH viewname IN gr_viewname
                    WITH enquname IN gr_enqname
                    WITH ttypname IN gr_ttypname
                    WITH shlpname IN gr_shlpname
                    WITH logname  EQ i_logname
                    WITH logshow  EQ space

                    WITH inactive EQ i_inactive
                    WITH ddmode   EQ i_ddmode

                    AND RETURN.

    IMPORT act_rc TO sy-subrc FROM MEMORY ID 'ACRC'.

    CHECK i_logname IS NOT INITIAL.

    IF sy-subrc > 4.  "4 is only warning
      CHECK i_step <> 1.  "messages of step 1 have to be ignored
      MESSAGE e666(01) WITH 'DDIC activation step' i_step 'ended with errors:' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      CALL FUNCTION 'TR_READ_LOG'
        EXPORTING
          iv_log_type   = 'DB'
          iv_logname_db = i_logname
        TABLES
          et_lines      = lt_log
        EXCEPTIONS
          invalid_input = 1
          access_error  = 2
          OTHERS        = 3.
      "append errors from activation log
      LOOP AT lt_log INTO ls_log WHERE severity EQ 'E'.
        MESSAGE e666(01) WITH ls_log-line INTO sy-lisel.    "#EC *
        CALL METHOD log_message.
      ENDLOOP.
      RAISE error.
    ENDIF.

  ENDMETHOD.                    "mass_activation






  METHOD add_to_transport.

    STATICS: s_object   LIKE i_object,
             s_obj_name TYPE string,
             s_subrc    TYPE sysubrc.

    DATA: l_tadir_name   TYPE tadir-obj_name,
          l_object_name  TYPE string,
          l_object_class TYPE string,
          l_extend,
          l_global_lock,
          ls_trkey       TYPE trkey.

    CLEAR sy-subrc.
    CHECK gv_copy_translation IS INITIAL.
    CHECK testrun IS INITIAL.

    IF i_object   NE s_object OR
       i_obj_name NE s_obj_name.

      s_object   = i_object.
      s_obj_name = i_obj_name.

      CASE i_object.
        WHEN 'REPT' OR 'FUNC' OR 'CUAD' OR 'DOCU'.
          l_object_class = i_object.
          l_object_name  = i_obj_name.
        WHEN 'DOCV' OR 'DOCT' OR 'DSYS' OR 'STCS' OR 'MSAG'
          OR 'SFRN' OR 'OSOD' OR 'SCP2'. "logical transport object
          l_object_class = i_object.
          l_object_name  = i_obj_name.
          l_global_lock  = 'X'.
          l_extend       = 'X'.
          l_tadir_name   = i_obj_name.
        WHEN 'MESS'.
          l_object_class = 'T100'.
          l_object_name  = i_obj_name.
        WHEN 'CLAS' OR 'FUGR' OR 'PARA' OR 'VCLS' OR 'AUTH'.
          l_object_class = i_object.
          l_object_name  = i_obj_name.
          l_tadir_name   = i_obj_name.
          l_global_lock  = 'X'.
        WHEN 'DOMA' OR 'DTEL' OR 'TABL' OR 'VIEW' OR 'INDX' OR 'TTYP' OR 'SHLP' OR 'ENQU'.
          l_object_class = 'DICT'.
          CONCATENATE i_object i_obj_name INTO l_object_name.
          l_tadir_name   = i_obj_name.
          IF i_object EQ 'VIEW'.
            l_global_lock  = 'X'.   "always write R3TR VIEW
          ENDIF.
        WHEN OTHERS.
          l_object_class = i_object.
          l_object_name  = i_obj_name.
      ENDCASE.

      "create TADIR entry in advance avoid popup
      IF l_tadir_name IS NOT INITIAL.
        DATA: ls_tadir_old TYPE tadir.
        SELECT SINGLE * FROM tadir INTO ls_tadir_old
                       WHERE pgmid      EQ 'R3TR'
                         AND object     EQ i_object
                         AND obj_name   EQ l_tadir_name.
        IF i_langu CA 'ED'.
          "set correct language and package on first call per object
          "skip this for other languages than EN/DE.
          CALL FUNCTION 'TR_TADIR_INTERFACE'
            EXPORTING
*             WI_DELETE_TADIR_ENTRY = ' '
              wi_test_modus         = space
              wi_tadir_pgmid        = 'R3TR'
              wi_tadir_object       = i_object
              wi_tadir_obj_name     = l_tadir_name
              wi_tadir_devclass     = i_devclass
              wi_tadir_masterlang   = i_langu
            EXCEPTIONS
              OTHERS                = 25.
          IF sy-subrc <> 0.
          ENDIF.
        ENDIF.
        IF i_devclass IS NOT INITIAL.
          "set correct package in memory
          EXPORT current_devclass FROM i_devclass TO MEMORY ID 'EUK'.
          SET PARAMETER ID 'EUK' FIELD i_devclass.
        ENDIF.
      ENDIF.

      CALL FUNCTION 'RS_CORR_INSERT'    "and create TADIR-entry
        EXPORTING
          object              = l_object_name
          object_class        = l_object_class
          devclass            = i_devclass
          korrnum             = gv_trkorr
          global_lock         = l_global_lock
*         AUTHOR              = ' '
          master_language     = i_langu
*         GENFLAG             = ' '
*         PROGRAM             = ' '
*         OBJECT_CLASS_SUPPORTS_MA = ' '
          extend              = l_extend
*         SUPPRESS_DIALOG     = ' '
*         MOD_LANGU           = ' '
*         ACTIVATION_CALL     = ' '
        IMPORTING
          korrnum             = gv_trkorr
*         ORDERNUM            =
*         NEW_CORR_ENTRY      =
*         AUTHOR              =
          transport_key       = ls_trkey
*         NEW_EXTEND          =
        EXCEPTIONS
          cancelled           = 1
          permission_failure  = 2
          unknown_objectclass = 3
          OTHERS              = 4.
      s_subrc = sy-subrc.

      "correct master language if neccessary
      IF l_tadir_name IS NOT INITIAL AND ls_tadir_old IS INITIAL.
        IF i_langu CA 'ED'.
          UPDATE tadir SET masterlang = i_langu
                     WHERE pgmid      EQ 'R3TR'
                       AND object     EQ i_object
                       AND obj_name   EQ l_tadir_name
                       AND masterlang NE i_langu.
        ENDIF.
      ENDIF.

    ENDIF.

    IF s_subrc NE 0.
      MESSAGE e666(01) WITH 'Could not add to transport request' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      RAISE error.
    ENDIF.

  ENDMETHOD.                    "add_to_transport

  METHOD register_inactive_object.

    DATA: l_obj_name TYPE e071-obj_name.

    l_obj_name = i_objname.
    CALL FUNCTION 'RS_INSERT_INTO_WORKING_AREA'
      EXPORTING
        object            = i_objtype
        obj_name          = l_obj_name
      EXCEPTIONS
        wrong_object_name = 1
        OTHERS            = 2.

    IF i_treetype IS SUPPLIED.
      CHECK i_treetype NE space.
      CALL FUNCTION 'RS_TREE_OBJECT_PLACEMENT'
        EXPORTING
          type   = i_treetype
          object = l_obj_name.
    ELSE.
      CALL FUNCTION 'RS_TREE_OBJECT_PLACEMENT'
        EXPORTING
          type   = i_objtype
          object = l_obj_name.
    ENDIF.

  ENDMETHOD.                    "register_inactive_object













  METHOD log_message.

    DATA: ls_msg     TYPE bal_s_msg.

    IF sy-msgno IS INITIAL OR sy-msgid IS INITIAL.
      MESSAGE i666(01) WITH 'unknown error' INTO sy-lisel.  "#EC *
    ENDIF.
    MOVE-CORRESPONDING syst TO ls_msg.

    CALL FUNCTION 'BAL_LOG_MSG_ADD'
      EXPORTING
        i_log_handle = gv_log_handle
        i_s_msg      = ls_msg
      EXCEPTIONS
        OTHERS       = 0.

    IF ls_msg-msgty CA 'EA'.
      gv_errors_occured = 'X'.
    ENDIF.

  ENDMETHOD.                    "log_message

  METHOD display_log.

    DATA: lt_log_handle TYPE bal_t_logh,
          ls_profile    TYPE bal_s_prof,
          l_s_fcat      TYPE bal_s_fcat,
          lt_dfies      TYPE TABLE OF dfies,
          ls_dfies      TYPE dfies.
    DATA: ls_filter     TYPE bal_s_lfil,
          lr_filter     TYPE bal_s_extn, "range table
          lr_extnumber  TYPE bal_s_extn,
          lt_log_header TYPE balhdr_t.

    IF gv_log_handle IS INITIAL.

      CLEAR: ls_filter, lr_extnumber.

*- Search only log file of this application
      lr_filter-sign   = 'I'.
      lr_filter-option = 'EQ'.
      lr_filter-low    = c_bal_object.
      APPEND lr_filter TO ls_filter-object.

      lr_filter-sign   = 'I'.
      lr_filter-option = 'EQ'.
      lr_filter-low    = c_bal_subobj.
      APPEND lr_filter TO ls_filter-subobject.

*- Search only log file of this change number
      lr_extnumber-low    = sy-repid.
      lr_extnumber-sign   = 'I'.
      lr_extnumber-option = 'EQ'.
      APPEND lr_extnumber TO ls_filter-extnumber.

*-- Search for log files on the database
      CALL FUNCTION 'BAL_DB_SEARCH'
        EXPORTING
          i_s_log_filter     = ls_filter
        IMPORTING
          e_t_log_header     = lt_log_header
        EXCEPTIONS
          log_not_found      = 1
          no_filter_criteria = 2
          OTHERS             = 3.
      IF sy-subrc EQ 0.
*-- Load log files from database into memory
        CALL FUNCTION 'BAL_DB_LOAD'
          EXPORTING
            i_t_log_header     = lt_log_header
          IMPORTING
            e_t_log_handle     = lt_log_handle
          EXCEPTIONS
            no_logs_specified  = 1
            log_not_found      = 2
            log_already_loaded = 3
            OTHERS             = 4.
      ENDIF.
    ELSE.
      APPEND gv_log_handle TO lt_log_handle.
    ENDIF.

    IF 1 = 1.
      "grid
      CALL FUNCTION 'BAL_DSP_PROFILE_SINGLE_LOG_GET'
        IMPORTING
          e_s_display_profile = ls_profile
        EXCEPTIONS
          OTHERS              = 0.
      "Set profile
      ls_profile-show_all   = abap_on.
      ls_profile-use_grid   = abap_on.
      ls_profile-tree_ontop = abap_on.
      ls_profile-exp_level  = 1.
      ls_profile-mess_mark  = abap_on.
    ELSE.
      "tree
      CALL FUNCTION 'BAL_DSP_PROFILE_DETLEVEL_GET'
        IMPORTING
          e_s_display_profile = ls_profile
        EXCEPTIONS
          OTHERS              = 0.
    ENDIF.

    "add own fields to field cat
    CALL FUNCTION 'DDIF_FIELDINFO_GET'
      EXPORTING
        tabname        = c_bal_context
      TABLES
        dfies_tab      = lt_dfies
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.
    ASSERT sy-subrc EQ 0.

    LOOP AT lt_dfies INTO ls_dfies WHERE fieldname EQ 'OBJECT'
                                      OR fieldname EQ 'OBJ_NAME'.
      l_s_fcat-ref_table = c_bal_context.
      l_s_fcat-ref_field = ls_dfies-fieldname.
      l_s_fcat-outputlen = ls_dfies-outputlen + 1.
*      l_s_fcat-col_pos   = 100 + sy-tabix.   "most rigth columns
      APPEND l_s_fcat TO ls_profile-mess_fcat.
    ENDLOOP.


    "set parameters for saving layout.
    ls_profile-disvariant-report = sy-repid.
    ls_profile-disvariant-handle = c_bal_subobj.

    ls_profile-clbk_ucbf-userexitp = sy-repid.
    ls_profile-clbk_ucbf-userexitf = 'BAL_CALLBACK_UCOMM'.
*    ls_profile-clbk_ucom-userexitp = sy-repid.
*    ls_profile-clbk_ucom-userexitf = 'BAL_CALLBACK_UCOMM'.
*    ls_profile-ext_push1-active        = 'X'.
*    ls_profile-ext_push1-def-text      = 'DDIC'.
*    ls_profile-ext_push1-def-icon_id   = icon_history.
*    ls_profile-ext_push1-def-icon_text = 'DDIC'.
*    ls_profile-ext_push1-def-quickinfo = 'DDIC Activation log'.

    IF testrun IS NOT INITIAL.
      ls_profile-title = 'UDO - Simulation log'.            "#EC *
    ELSEIF update IS NOT INITIAL.
      ls_profile-title = 'UDO - Change Log'.                "#EC *
    ELSEIF genview IS NOT INITIAL.
      ls_profile-title = 'UDO - View Generation Log'.       "#EC *
    ENDIF.

    CALL FUNCTION 'BAL_DSP_LOG_DISPLAY'
      EXPORTING
        i_t_log_handle      = lt_log_handle
        i_s_display_profile = ls_profile
        i_amodal            = space
      EXCEPTIONS
        OTHERS              = 0.

    CALL FUNCTION 'BAL_DB_SAVE'
      EXPORTING
        i_t_log_handle = lt_log_handle
      EXCEPTIONS
        OTHERS         = 0.

  ENDMETHOD.                    "display_log

  METHOD set_context.

    STATICS: BEGIN OF lss_key, "save last key
               i_object    TYPE e071-object,
               i_obj_name  TYPE adir_key-obj_name,
               i_obj_name2 TYPE adir_key-obj_name,
               i_text      TYPE string,
               i_langu     TYPE sylangu,
             END OF lss_key.

    DATA: ls_msg_defaults TYPE bal_s_mdef,
          ls_context      TYPE adir_key,
          l_text(70),
          l_mode          TYPE string,
          ls_key          LIKE lss_key.

    DATA: ls_e071      TYPE e071,
          ls_tadir     TYPE tadir,
          ls_tadir_key TYPE tadir.

    ls_key-i_object    = i_object.
    ls_key-i_obj_name  = i_obj_name.
    ls_key-i_obj_name2 = i_obj_name2.
    ls_key-i_text      = i_text.
    ls_key-i_langu     = i_langu.
    IF ls_key EQ lss_key. "check last key
      "avoid double message like "add field to table"
      RETURN.
    ELSE.
      lss_key = ls_key.
    ENDIF.

    ls_context-object   = i_object.
    CONCATENATE i_obj_name i_obj_name2 INTO ls_context-obj_name.
    ls_msg_defaults-log_handle      = gv_log_handle.
    ls_msg_defaults-context-value   = ls_context.
    ls_msg_defaults-context-tabname = c_bal_context.

    CALL FUNCTION 'BAL_GLB_MSG_DEFAULTS_SET'
      EXPORTING
        i_s_msg_defaults = ls_msg_defaults
      EXCEPTIONS
        OTHERS           = 0.

    "try to check if object exists
    IF i_object IS NOT INITIAL AND i_obj_name IS NOT INITIAL.
      ls_e071-pgmid    = 'R3TR'.
      ls_e071-object   = i_object.
      ls_e071-obj_name = i_obj_name.

      CALL FUNCTION 'SCWB_GET_TADIR_REM'
        EXPORTING
          is_e071      = ls_e071
        IMPORTING
          es_tadir_key = ls_tadir_key
          es_tadir     = ls_tadir.
      IF ls_tadir_key IS INITIAL.
        ls_e071-pgmid   = 'LIMU'.
        CALL FUNCTION 'SCWB_GET_TADIR_REM'
          EXPORTING
            is_e071      = ls_e071
          IMPORTING
            es_tadir_key = ls_tadir_key
            es_tadir     = ls_tadir.
      ENDIF.

      IF ls_tadir IS INITIAL.
        l_mode = 'Create'.                                  "#EC NOTEXT
      ELSE.
        l_mode = 'Change'.                                  "#EC NOTEXT
        "check if object has been manually modified by customer.
        SELECT COUNT( * ) FROM adiraccess WHERE pgmid    EQ ls_tadir-pgmid
                                            AND object   EQ ls_tadir-object
                                            AND obj_name EQ ls_tadir-obj_name.
        IF sy-dbcnt NE 0.
          MESSAGE w666(01) WITH ls_tadir-object ls_tadir-obj_name 'was manually changed before.' 'Please adjust manually afterwards' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
        ENDIF.
      ENDIF.
    ENDIF.

    IF i_text IS INITIAL.
      CALL METHOD get_object_text
        EXPORTING
          i_object   = i_object
          i_obj_name = i_obj_name
        RECEIVING
          r_text     = l_text.

      CONCATENATE l_mode l_text INTO l_text SEPARATED BY space.
    ELSE.
      l_text = i_text.
    ENDIF.

    IF l_text IS NOT INITIAL.
      IF i_langu IS NOT INITIAL.
        MESSAGE s666(01) WITH l_text '( language' i_langu ')' INTO l_text. "#EC NOTEXT
      ENDIF.
      CALL FUNCTION 'BAL_LOG_MSG_ADD_FREE_TEXT'
        EXPORTING
          i_msgty = 'I'
          i_text  = l_text
        EXCEPTIONS
          OTHERS  = 0.
    ENDIF.

  ENDMETHOD.                    "set_context




ENDCLASS.                    "lcl_wb IMPLEMENTATION


START-OF-SELECTION.
  PERFORM action.

*&---------------------------------------------------------------------*
FORM action.

  CALL METHOD lcl_wb=>init                                  "#EC *
*     EXPORTING
*       i_note          = '1866570'
     EXCEPTIONS
        stop_processing = 1
        OTHERS          = 2.
  IF sy-subrc EQ 0 AND ( update IS NOT INITIAL OR testrun IS NOT INITIAL ).

    APPEND 'SEPA_HASHTAB_DATA_MANDATE_DATA'         TO gt_ttypname. "#EC NOTEXT
    APPEND 'SEPA_SORTTAB_DATA_MANDATE_DATA'         TO gt_ttypname. "#EC NOTEXT

    "- TTYP TTYD ------------------------------------------------------------------------ Table Types
    "-- LIMU TTYD SEPA_HASHTAB_DATA_MANDATE_DATA (language: DE , source: SI3 )
    DATA: ls_dd42v TYPE dd42v, lt_dd42v TYPE TABLE OF dd42v.
    DATA: ls_dd43v TYPE dd43v, lt_dd43v TYPE TABLE OF dd43v.

    CLEAR lt_dd42v.
    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd42v-keyfdpos   = '0001'.
    ls_dd42v-rowtypepos = '0001'.
    ls_dd42v-keyfield   = 'MGUID'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'MNDID'.
    ls_dd42v-keyfdpos   = '0001'.
    ls_dd42v-rowtypepos = '0002'.
    ls_dd42v-keyfield   = 'MNDID'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'ORIGIN'.
    ls_dd42v-keyfdpos   = '0001'.
    ls_dd42v-rowtypepos = '0018'.
    ls_dd42v-keyfield   = 'ORIGIN_MNDID'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'SNDID'.
    ls_dd42v-keyfdpos   = '0001'.
    ls_dd42v-rowtypepos = '0029'.
    ls_dd42v-keyfield   = 'SND_TYPE'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'MNDID'.
    ls_dd42v-keyfdpos   = '0002'.
    ls_dd42v-rowtypepos = '0068'.
    ls_dd42v-keyfield   = 'REC_ID_CRDID'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'ORIGIN'.
    ls_dd42v-keyfdpos   = '0002'.
    ls_dd42v-rowtypepos = '0017'.
    ls_dd42v-keyfield   = 'ORIGIN_REC_CRDID'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'SNDID'.
    ls_dd42v-keyfdpos   = '0002'.
    ls_dd42v-rowtypepos = '0030'.
    ls_dd42v-keyfield   = 'SND_ID'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'MNDID'.
    ls_dd42v-keyfdpos   = '0003'.
    ls_dd42v-rowtypepos = '0022'.
    ls_dd42v-keyfield   = 'ANWND'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'ORIGIN'.
    ls_dd42v-keyfdpos   = '0003'.
    ls_dd42v-rowtypepos = '0022'.
    ls_dd42v-keyfield   = 'ANWND'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'SNDID'.
    ls_dd42v-keyfdpos   = '0003'.
    ls_dd42v-rowtypepos = '0022'.
    ls_dd42v-keyfield   = 'ANWND'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'MNDID'.
    ls_dd42v-keyfdpos   = '0004'.
    ls_dd42v-rowtypepos = '0003'.
    ls_dd42v-keyfield   = 'MVERS'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'ORIGIN'.
    ls_dd42v-keyfdpos   = '0004'.
    ls_dd42v-rowtypepos = '0003'.
    ls_dd42v-keyfield   = 'MVERS'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'SNDID'.
    ls_dd42v-keyfdpos   = '0004'.
    ls_dd42v-rowtypepos = '0003'.
    ls_dd42v-keyfield   = 'MVERS'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR lt_dd43v.
    CLEAR ls_dd43v.
    ls_dd43v-typename     = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd43v-seckeyname   = 'MNDID'.
    ls_dd43v-seckeyunique = 'X'.
    ls_dd43v-accessmode   = 'H'.
    ls_dd43v-kind         = 'K'.
    APPEND ls_dd43v TO lt_dd43v.

    CLEAR ls_dd43v.
    ls_dd43v-typename     = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd43v-seckeyname   = 'ORIGIN'.
    ls_dd43v-seckeyunique = 'X'.
    ls_dd43v-accessmode   = 'H'.
    ls_dd43v-kind         = 'K'.
    APPEND ls_dd43v TO lt_dd43v.

    CLEAR ls_dd43v.
    ls_dd43v-typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'.
    ls_dd43v-seckeyname = 'SNDID'.
    ls_dd43v-accessmode = 'S'.
    ls_dd43v-kind       = 'K'.
    APPEND ls_dd43v TO lt_dd43v.

    CALL METHOD lcl_wb=>create_table_type                   "#EC *
      EXPORTING
        i_typename   = 'SEPA_HASHTAB_DATA_MANDATE_DATA'
        i_devclass   = 'BF_SEPA'
        i_langu      = 'D'
        i_ddtext     = 'Tabelle für Mandatsdaten im Applikationlayer'
        i_rowtype    = 'SEPA_STR_DATA_MANDATE_DATA'
        i_accessmode = 'H'
        i_keydef     = 'K'
        i_keykind    = 'U'
        i_generic    = 'X'
        i_furtherseckey = 'W'
        it_dd43v     = lt_dd43v
        it_dd42v     = lt_dd42v.


    "-- LIMU TTYD SEPA_SORTTAB_DATA_MANDATE_DATA (language: DE , source: SI3 )
    CLEAR lt_dd42v.
    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_SORTTAB_DATA_MANDATE_DATA'.
    ls_dd42v-keyfdpos   = '0001'.
    ls_dd42v-rowtypepos = '0001'.
    ls_dd42v-keyfield   = 'MGUID'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_SORTTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'MNDID'.
    ls_dd42v-keyfdpos   = '0001'.
    ls_dd42v-rowtypepos = '0002'.
    ls_dd42v-keyfield   = 'MNDID'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_SORTTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'ORIGIN'.
    ls_dd42v-keyfdpos   = '0001'.
    ls_dd42v-rowtypepos = '0018'.
    ls_dd42v-keyfield   = 'ORIGIN_MNDID'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_SORTTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'MNDID'.
    ls_dd42v-keyfdpos   = '0002'.
    ls_dd42v-rowtypepos = '0048'.
    ls_dd42v-keyfield   = 'REC_CRDID'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_SORTTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'ORIGIN'.
    ls_dd42v-keyfdpos   = '0002'.
    ls_dd42v-rowtypepos = '0017'.
    ls_dd42v-keyfield   = 'ORIGIN_REC_CRDID'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_SORTTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'MNDID'.
    ls_dd42v-keyfdpos   = '0003'.
    ls_dd42v-rowtypepos = '0022'.
    ls_dd42v-keyfield   = 'ANWND'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_SORTTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'ORIGIN'.
    ls_dd42v-keyfdpos   = '0003'.
    ls_dd42v-rowtypepos = '0022'.
    ls_dd42v-keyfield   = 'ANWND'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_SORTTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'MNDID'.
    ls_dd42v-keyfdpos   = '0004'.
    ls_dd42v-rowtypepos = '0003'.
    ls_dd42v-keyfield   = 'MVERS'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_SORTTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'ORIGIN'.
    ls_dd42v-keyfdpos   = '0004'.
    ls_dd42v-rowtypepos = '0003'.
    ls_dd42v-keyfield   = 'MVERS'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_SORTTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'MNDID'.
    ls_dd42v-keyfdpos   = '0005'.
    ls_dd42v-rowtypepos = '0063'.
    ls_dd42v-keyfield   = 'VERSION_CHG'.
    APPEND ls_dd42v TO lt_dd42v.

    CLEAR ls_dd42v.
    ls_dd42v-typename   = 'SEPA_SORTTAB_DATA_MANDATE_DATA'.
    ls_dd42v-seckeyname = 'ORIGIN'.
    ls_dd42v-keyfdpos   = '0005'.
    ls_dd42v-rowtypepos = '0063'.
    ls_dd42v-keyfield   = 'VERSION_CHG'.
    APPEND ls_dd42v TO lt_dd42v.


    CLEAR lt_dd43v.
    CLEAR ls_dd43v.
    ls_dd43v-typename   = 'SEPA_SORTTAB_DATA_MANDATE_DATA'.
    ls_dd43v-seckeyname = 'MNDID'.
    ls_dd43v-accessmode = 'S'.
    ls_dd43v-kind       = 'K'.
    APPEND ls_dd43v TO lt_dd43v.

    CLEAR ls_dd43v.
    ls_dd43v-typename   = 'SEPA_SORTTAB_DATA_MANDATE_DATA'.
    ls_dd43v-seckeyname = 'ORIGIN'.
    ls_dd43v-accessmode = 'S'.
    ls_dd43v-kind       = 'K'.
    APPEND ls_dd43v TO lt_dd43v.

    CALL METHOD lcl_wb=>create_table_type                   "#EC *
      EXPORTING
        i_typename   = 'SEPA_SORTTAB_DATA_MANDATE_DATA'
        i_devclass   = 'BF_SEPA'
        i_langu      = 'D'
        i_ddtext     = 'Tabelle für Mandatsdaten im Applikationlayer'
        i_rowtype    = 'SEPA_STR_DATA_MANDATE_DATA'
        i_accessmode = 'H'
        i_keydef     = 'K'
        i_keykind    = 'U'
        i_generic    = 'X'
        i_furtherseckey = 'W'
        it_dd43v     = lt_dd43v
        it_dd42v     = lt_dd42v.


  ENDIF.

  CALL METHOD lcl_wb=>activate.

  CALL METHOD lcl_wb=>display_log.
ENDFORM.                    "action
