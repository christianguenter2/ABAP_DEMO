REPORT note_xxxxxxx.

* Generated by SAP_LOCAL_DOWNPORT_ASSISTANT Version 3.34 on 22.05.2013

* The individual coding starts at 'FORM action.' ( line 1.851 )

PARAMETERS testrun  RADIOBUTTON GROUP mode.
PARAMETERS update   RADIOBUTTON GROUP mode.
DATA genview.
PARAMETERS showlogs RADIOBUTTON GROUP mode.
DATA: gv_copy_translation.

TYPE-POOLS: seox, seoc, seok, seex, bcwbn, ststc.

TYPES: t_switch_id TYPE char30, "sfw_switch_id does not exist in SAP_BASIS 640
       t_bfunction TYPE char30, "sfw_bfunction does not exist in SAP_BASIS 640
       BEGIN OF t_bf_sw, "sfw_bf_sw
         switch_id TYPE t_switch_id,
         version,
         bfunction TYPE t_bfunction,
         no_check,
       END   OF t_bf_sw,
         BEGIN OF dd43v,typename(30),seckeyname(30),ddlanguage,seckeyunique,accessmode,kind,keydescription(80),END OF dd43v.

TYPES: tt_dd05m   TYPE TABLE OF dd05m,
       tt_dd08v   TYPE TABLE OF dd08v,
       tt_dd17v   TYPE TABLE OF dd17v,
       tt_dd26v   TYPE TABLE OF dd26v,
       tt_dd27p   TYPE TABLE OF dd27p,
       tt_dd28j   TYPE TABLE OF dd28j,
       tt_dd28v   TYPE TABLE OF dd28v,
       tt_dd30v   TYPE TABLE OF dd30v,
       tt_dd30tv  TYPE TABLE OF dd30tv,
       tt_dd31v   TYPE TABLE OF dd31v,
       tt_dd32v   TYPE TABLE OF dd32v,
       tt_dd32p   TYPE TABLE OF dd32p,
       tt_dd33v   TYPE TABLE OF dd33v,
       tt_dd36m   TYPE TABLE OF dd36m,
       tt_dd42v   TYPE TABLE OF dd42v,
       tt_dd43v   TYPE TABLE OF dd43v,
       tt_e071k   TYPE TABLE OF e071k,
       tt_langu   TYPE TABLE OF sylangu,
       tt_bdcdata TYPE TABLE OF bdcdata,
       tt_sta     TYPE TABLE OF rsmpe_stat,
       tt_fun     TYPE TABLE OF rsmpe_funt,
       tt_men     TYPE TABLE OF rsmpe_men,
       tt_mtx     TYPE TABLE OF rsmpe_mnlt,
       tt_act     TYPE TABLE OF rsmpe_act,
       tt_but     TYPE TABLE OF rsmpe_but,
       tt_pfk     TYPE TABLE OF rsmpe_pfk,
       tt_set     TYPE TABLE OF rsmpe_staf,
       tt_doc     TYPE TABLE OF rsmpe_atrt,
       tt_tit     TYPE TABLE OF rsmpe_titt,
       tt_biv     TYPE TABLE OF rsmpe_buts.

DATA: gr_domname            TYPE RANGE OF domname,
      gr_rollname           TYPE RANGE OF rollname,
      gr_tabname            TYPE RANGE OF tabname, "structures and database tables
      gr_dbtabname          TYPE RANGE OF tabname, "only database tables
      gt_tabname            TYPE TABLE OF tabname,
      gr_indexes            TYPE RANGE OF trobj_name,
      gr_indxtab            TYPE RANGE OF tabname,
      gr_indxname           TYPE RANGE OF indexid,
      gr_shlpname           TYPE RANGE OF shlpname,
      gr_viewname           TYPE RANGE OF viewname,
      gr_ttypname           TYPE RANGE OF ttypename,
      gt_ttypname           TYPE TABLE OF ttypename,
      gr_guistatus          TYPE RANGE OF progname,
      gr_switchname         TYPE RANGE OF t_switch_id,
      gr_msg_class          TYPE RANGE OF msgid,
      gv_trkorr             TYPE trkorr,
      gv_unit_test,
      gv_translation,
      gv_repository_changed,
      gv_errors_occured,
      gv_log_handle         TYPE balloghndl.


CONSTANTS: c_bal_object     TYPE balobj_d VALUE 'SNOTE',
           c_bal_subobj     TYPE balsubobj VALUE space,
           c_bal_context    TYPE tabname VALUE 'ADIR_KEY',
           c_include6       TYPE fieldname VALUE '.INCLU', ".INCLUDE or .INCLU--AP or .INCLU-_BY
           c_memory_id(40)  VALUE 'SAP_LOCAL_DOWNPORT_ASSISTANT',
           c_logical_object VALUE 'L'.

DATA: akb_get_tadir TYPE funcname VALUE 'AKB_GET_TADIR'.

*----------------------------------------------------------------------*
*       CLASS lcl_wb DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_wb DEFINITION.
  PUBLIC SECTION.

    CLASS-METHODS init
       IMPORTING
         i_trkorr_list  TYPE string OPTIONAL   "list of support packages which indicates that report is not needed anymore
         i_component    TYPE dlvunit OPTIONAL  "software component without which report makes no sense
         value(i_note)  TYPE clike OPTIONAL    "note which indicates that report is not needed anymore
         value(i_cinst) TYPE cwbcialeid OPTIONAL "correction instruction which describes the validity of the report
       EXCEPTIONS
         stop_processing.

    CLASS-METHODS get_object_text
      IMPORTING
        i_object   TYPE e071-object    "e.g. TABD
        i_obj_name TYPE c OPTIONAL     "for DOCU
      RETURNING value(r_text) TYPE string.

    CLASS-METHODS create_table    "or structure or append or database table
      IMPORTING
        i_tabname    TYPE tabname
        i_devclass   TYPE devclass
        i_exclass    TYPE dd02v-exclass  OPTIONAL
        i_langu      TYPE sylangu   DEFAULT 'E'   "Default EN
        i_ddtext     TYPE ddtext    OPTIONAL      "can be taken from tabname
        i_authclass  TYPE dd02v-authclass DEFAULT '00'
        i_mainflag   TYPE dd02v-mainflag OPTIONAL
        i_tabclass   TYPE tabclass  DEFAULT 'INTTAB'
        i_sqltab     TYPE sqlappdtab OPTIONAL
        i_proxytype  TYPE ddproxyty         OPTIONAL
        i_contflag   TYPE contflag         DEFAULT 'C'     "only needed for db tables
        i_tabkat     TYPE dd09v-tabkat     DEFAULT '0'     "only needed for db tables
        i_tabart     TYPE dd09v-tabart     DEFAULT 'APPL2' "only needed for db tables
        i_bufallow   TYPE dd09v-bufallow   DEFAULT 'N'     "only needed for db tables
        i_pufferung  TYPE dd09v-pufferung  OPTIONAL        "only needed for db tables
        i_schfeldanz TYPE dd09v-schfeldanz OPTIONAL        "only needed for db tables
        i_speichpuff TYPE dd09v-speichpuff OPTIONAL        "only needed for db tables
        i_javaonly   TYPE xfeld OPTIONAL  "dd09v-javaonly  "only needed for db tables   ">=SAPBASIS700
        i_protokoll  TYPE dd09v-protokoll  OPTIONAL.       "only needed for db tables

    CLASS-METHODS add_field_to_table
      IMPORTING
        i_tabname   TYPE tabname
        i_keyflag   TYPE keyflag DEFAULT space
        i_anonymous TYPE xfeld OPTIONAL "dd03p-anonymous
        i_fieldname TYPE fieldname
        i_rollname  TYPE rollname       OPTIONAL  "data element, structure, table_type, include/append name
        i_datatype  TYPE dd03p-datatype OPTIONAL  "only needed if rollname is initial
        i_decimals  TYPE dd03p-decimals OPTIONAL  "only needed if rollname is initial
        i_leng      TYPE dd03p-leng     OPTIONAL  "only needed if rollname is initial
        i_langu     TYPE dd03p-ddlanguage OPTIONAL  "only needed if rollname is initial
        i_ddtext    TYPE dd03p-ddtext   OPTIONAL  "only needed if rollname is initial
        i_reftable  TYPE dd03p-reftable OPTIONAL
        i_reffield  TYPE dd03p-reffield OPTIONAL
        i_notnull   TYPE dd03p-notnull  OPTIONAL
        i_languflag TYPE dd03p-languflag OPTIONAL
        i_groupname TYPE ddgroup        OPTIONAL
        is_dd08v    TYPE dd08v          OPTIONAL   "foreign key relationship
        it_dd05m    TYPE tt_dd05m       OPTIONAL   "foreign key relationship fields
        i_context   TYPE fieldname      OPTIONAL.  "name of previous field or include, blank->append

    CLASS-METHODS create_message
      IMPORTING
         i_msgid TYPE msgid
         i_msgno TYPE msgno
         i_langu TYPE sylangu DEFAULT 'E'   "Default EN
         i_text  TYPE natxt
         i_selfdef TYPE doku_selfd DEFAULT 'X'.

    CLASS-METHODS add_to_transport
      IMPORTING
        i_object   TYPE e071-object    "TABD
        i_obj_name TYPE c     "flexible number of characters
        i_devclass TYPE devclass OPTIONAL
        i_langu    TYPE sylangu OPTIONAL
      EXCEPTIONS
        error
        simulation.

    CLASS-METHODS register_inactive_object
        IMPORTING
           i_objtype  TYPE e071-object
           i_treetype TYPE e071-object OPTIONAL  "space = do not update tree, optionally different type in tree, e.g. TABL vs. CDS
           i_objname TYPE c.

    CLASS-METHODS log_message.

    CLASS-METHODS display_log.

    CLASS-METHODS set_context
      IMPORTING i_object    TYPE e071-object
                i_obj_name  TYPE c
                i_obj_name2 TYPE c OPTIONAL
                i_text      TYPE c OPTIONAL
                i_langu     TYPE sylangu.

    CLASS-METHODS support_pack_applied
      IMPORTING i_trkorr_list TYPE string
      RETURNING value(r_applied) TYPE xfeld.

    CLASS-METHODS software_comp_applied
      IMPORTING i_component TYPE dlvunit
      EXPORTING e_cvers TYPE cvers
      EXCEPTIONS not_applied.

    CLASS-METHODS activate
      IMPORTING i_result_auth_check TYPE sysubrc OPTIONAL
                i_actmode TYPE i DEFAULT 1.  "1/2 step activation

ENDCLASS.                    "lcl_wb DEFINITION
*----------------------------------------------------------------------*
*       CLASS lcl_dcm_to_po_bridge IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcl_wb IMPLEMENTATION.

  METHOD init.

    CLEAR gv_errors_occured.

    CALL FUNCTION 'AUTHORITY_CHECK_TCODE'
      EXPORTING
        tcode  = 'SNOTE'
      EXCEPTIONS
        ok     = 0
        OTHERS = 1.
    IF sy-subrc NE 0.
      MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      gv_errors_occured = 'X'.
      RAISE stop_processing.
    ENDIF.

    IF showlogs IS NOT INITIAL.
      CALL METHOD display_log.
      LEAVE PROGRAM.
    ENDIF.

    DATA: ls_log TYPE bal_s_log.
    "prepare application log
    ls_log-object    = c_bal_object.
    ls_log-subobject = c_bal_subobj.
    ls_log-extnumber = sy-repid.
    ls_log-aldate    = sy-datum.
    ls_log-altime    = sy-uzeit.
    ls_log-aluser    = sy-uname.
    ls_log-alprog    = sy-repid.
    ls_log-altcode   = sy-tcode.
    "create standard application log handle
    CALL FUNCTION 'BAL_LOG_CREATE'
      EXPORTING
        i_s_log                 = ls_log
      IMPORTING
        e_log_handle            = gv_log_handle
      EXCEPTIONS
        log_header_inconsistent = 1
        OTHERS                  = 2.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    EXPORT gv_log_handle FROM gv_log_handle TO MEMORY ID c_memory_id.

    CALL METHOD set_context
      EXPORTING
        i_langu    = space
        i_object   = space
        i_obj_name = space.

    "check software component and SP level
    DATA: ls_cvers    TYPE cvers,
          l_applied   TYPE xfeld,
          l_line(255).
    IF i_component IS SUPPLIED.
      CALL METHOD software_comp_applied                     "#EC *
        EXPORTING
          i_component = i_component
        IMPORTING
          e_cvers     = ls_cvers
        EXCEPTIONS
          not_applied = 1
          OTHERS      = 2.
      IF sy-subrc IS NOT INITIAL.
        MESSAGE e666(01) WITH 'Software Component' i_component 'not installed! Execution stopped!' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        CALL METHOD display_log.
        RAISE stop_processing.
      ELSE.
        "further check if possible
        IF i_trkorr_list IS SUPPLIED.
          CALL METHOD support_pack_applied
            EXPORTING
              i_trkorr_list = i_trkorr_list
            RECEIVING
              r_applied     = l_applied.
          IF l_applied EQ 'X'.
            CONCATENATE i_component '/' ls_cvers-extrelease INTO l_line.
            MESSAGE e666(01) WITH 'The system contains software component/support pack level' l_line
                                  '. Report execution not required anymore.' INTO sy-lisel. "#EC *
            CALL METHOD log_message.
            CALL METHOD display_log.
            RAISE stop_processing.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF. " i_component IS SUPPLIED.

    IF i_note IS NOT INITIAL.
*     that that note is not already implemented
*     this must not be the note containing the generated report for DDIC but a follow-up note with the coding using that new DDIC
      DATA l_status TYPE c.
      CALL FUNCTION 'SCWB_NOTE_IMPL_STATUS_SIMPLE'
        EXPORTING
          iv_numm   = i_note
        IMPORTING
          ev_status = l_status
        EXCEPTIONS
          OTHERS    = 1.
      CASE l_status.
        WHEN 'E'.
          MESSAGE e666(01) WITH 'SAP Note' i_note 'completely implemented;' 'Report execution not required anymore.' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
          CALL METHOD display_log.
          RAISE stop_processing.
        WHEN 'O'.
          MESSAGE e666(01) WITH 'SAP Note' i_note 'is obsolete;' 'Report execution not required anymore.' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
          CALL METHOD display_log.
          RAISE stop_processing.
        WHEN OTHERS. "okay
          DATA: ls_note TYPE  bcwbn_note.
          ls_note-key-numm = i_note.
          CALL FUNCTION 'SCWB_NOTE_READ'
            EXPORTING
              iv_read_corr_instructions  = 'X'
            CHANGING
              cs_note                    = ls_note
            EXCEPTIONS
              note_not_found             = 1
              language_not_found         = 2
              unreadable_text_format     = 3
              corr_instruction_not_found = 4
              OTHERS                     = 5.
          IF sy-subrc <> 0.
            MESSAGE e666(01) WITH 'SAP Note' i_note 'cannot be read;' 'Ensure correct download of note first.' INTO sy-lisel. "#EC *
            CALL METHOD log_message.
            CALL METHOD display_log.
            RAISE stop_processing.
          ENDIF.
*------
          FIELD-SYMBOLS: <ls_corr> TYPE bcwbn_corr_instruction.
          DATA: l_valid TYPE bcwbn_bool.
          LOOP AT ls_note-corr_instructions ASSIGNING <ls_corr>.
            IF i_cinst IS NOT INITIAL.
              CHECK <ls_corr>-key-aleid = i_cinst.
            ENDIF.
            CALL FUNCTION 'SCWB_CINST_CHECK_VALID'
              IMPORTING
                ev_valid                   = l_valid
              CHANGING
                cs_corr_instruction        = <ls_corr>
              EXCEPTIONS
                corr_inst_not_found        = 1
                inconsistent_delivery_data = 2
                undefined                  = 3
                OTHERS                     = 4.
            IF sy-subrc <> 0.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ENDIF.
            IF l_valid IS NOT INITIAL.
              EXIT.
            ENDIF.
          ENDLOOP.
          IF l_valid IS INITIAL.
            MESSAGE e666(01) WITH 'Manual changes cannot be applied;' 'Correction instruction invalid' 'for current patch level' INTO sy-lisel. "#EC *                 "#EC *
            CALL METHOD log_message.
            CALL METHOD display_log.
            RAISE stop_processing.
          ENDIF.
      ENDCASE.
    ENDIF.

    CALL FUNCTION 'SCWG_TOOLFLAG_SET'. "Reset will happen at leave of program

    IF testrun IS INITIAL.
      MESSAGE i666(01) WITH 'Running in Update Mode' INTO sy-lisel. "#EC *
    ELSE.
      MESSAGE i666(01) WITH 'Running in Test Mode' INTO sy-lisel. "#EC *
    ENDIF.
    CALL METHOD log_message.

  ENDMETHOD.                    "init


  METHOD get_object_text.

    STATICS: lt_object_text TYPE TABLE OF ko100,
             lt_doktypes    TYPE TABLE OF dd07v.

    DATA: ls_object_text TYPE ko100,
          ls_doktype     TYPE dd07v.

    IF lt_object_text IS INITIAL.
      CALL FUNCTION 'TR_OBJECT_TABLE'
        TABLES
          wt_object_text = lt_object_text.
      SORT lt_object_text BY object.

      CALL FUNCTION 'DDIF_DOMA_GET'
        EXPORTING
          name      = 'DOK_ID'
          langu     = sy-langu
        TABLES
          dd07v_tab = lt_doktypes
        EXCEPTIONS
          OTHERS    = 0.
      SORT lt_doktypes BY domvalue_l.
    ENDIF.

    IF i_object EQ 'DOCU'.
      READ TABLE lt_doktypes INTO ls_doktype BINARY SEARCH
        WITH KEY domvalue_l = i_obj_name(2).
      IF sy-subrc EQ 0.
        CONCATENATE 'Documentation' ls_doktype-ddtext INTO r_text SEPARATED BY space. "#EC NOTEXT
      ELSE.
        r_text = 'Documentation'.                           "#EC NOTEXT
      ENDIF.
    ELSEIF i_object IS NOT INITIAL.
      READ TABLE lt_object_text INTO ls_object_text BINARY SEARCH
        WITH KEY object = i_object.  "ignore PGMID!
      IF sy-subrc EQ 0.
        r_text = ls_object_text-text.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "get_object_text










  METHOD create_table.
    DATA: ls_dd02v     TYPE dd02v,
          ls_dd09l     TYPE dd09l,
          lt_dd03p     TYPE TABLE OF dd03p,
          lt_dd05m     TYPE TABLE OF dd05m,
          lt_dd08v     TYPE TABLE OF dd08v,
          lt_dd12v     TYPE TABLE OF dd12v,
          lt_dd17v     TYPE TABLE OF dd17v,
          lt_dd35v     TYPE TABLE OF dd35v,
          lt_dd36m     TYPE TABLE OF dd36m,
          l_tabix      TYPE sytabix,
          l_treetype   TYPE trobjtype,
          ls_dwinactiv TYPE dwinactiv,
          ls_tabname   LIKE LINE OF gr_tabname VALUE 'IEQ'.

    FIELD-SYMBOLS: <ls_dd03p>          TYPE dd03p,
                   <ls_dd09l_javaonly> TYPE char1.

    CALL METHOD set_context
      EXPORTING
        i_langu    = i_langu
        i_object   = 'TABD'
        i_obj_name = i_tabname.

    ls_tabname-low = i_tabname.
    COLLECT ls_tabname INTO gr_tabname.

    ASSIGN ('LS_DD09L-JAVAONLY') TO <ls_dd09l_javaonly>.                ">=SAPBASIS700

    CALL FUNCTION 'DDIF_TABL_GET'
      EXPORTING
        name          = i_tabname
        state         = 'M'  "newest version (e.g. inactive)
        langu         = i_langu
      IMPORTING
*       GOTSTATE      = GOTSTATE
        dd02v_wa      = ls_dd02v
        dd09l_wa      = ls_dd09l
      TABLES
        dd03p_tab     = lt_dd03p
        dd05m_tab     = lt_dd05m
        dd08v_tab     = lt_dd08v
        dd12v_tab     = lt_dd12v
        dd17v_tab     = lt_dd17v
        dd35v_tab     = lt_dd35v
        dd36m_tab     = lt_dd36m
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    IF sy-subrc           EQ 0           AND
       ls_dd02v-tabname   IS NOT INITIAL AND "existing.
       ls_dd02v-ddtext    EQ i_ddtext    AND
       ls_dd02v-exclass   EQ i_exclass   AND
       ls_dd02v-tabclass  EQ i_tabclass  AND
       ls_dd02v-authclass EQ i_authclass AND
       ls_dd02v-mainflag  EQ i_mainflag  AND
       ls_dd02v-proxytype EQ i_proxytype AND
       ls_dd02v-sqltab    EQ i_sqltab.

      IF ( ls_dd02v-tabclass   EQ 'INTTAB' ) OR
         ( ls_dd02v-contflag   EQ i_contflag   AND
           ls_dd09l-tabkat     EQ i_tabkat     AND
           ls_dd09l-tabart     EQ i_tabart     AND
           ls_dd09l-pufferung  EQ i_pufferung  AND
           ls_dd09l-bufallow   EQ i_bufallow   AND
           ls_dd09l-schfeldanz EQ i_schfeldanz AND
           ls_dd09l-protokoll  EQ i_protokoll  AND
           "ls_dd09l-javaonly   EQ i_javaonly   AND     ">=SAPBASIS700
           ls_dd09l-speichpuff EQ i_speichpuff ).   "do not check javaonly field
        MESSAGE i666(01) WITH 'No update necessary' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        RETURN.
      ENDIF.

    ENDIF.

    CHECK testrun IS INITIAL.

    "new table
    ls_dd02v-tabname    = i_tabname.
    ls_dd02v-ddlanguage = i_langu.
    ls_dd02v-exclass    = i_exclass.
    ls_dd02v-tabclass   = i_tabclass.
    ls_dd02v-authclass  = i_authclass.
    ls_dd02v-mainflag   = i_mainflag.
    ls_dd02v-proxytype  = i_proxytype.
    ls_dd02v-sqltab     = i_sqltab.

    IF i_ddtext IS INITIAL.
      ls_dd02v-ddtext   = i_tabname.
    ELSE.
      ls_dd02v-ddtext   = i_ddtext.
    ENDIF.

    IF ls_dd02v-tabclass EQ 'CLUSTER' OR  "only for real database tables
       ls_dd02v-tabclass EQ 'POOL'    OR
       ls_dd02v-tabclass EQ 'TRANSP'.
      ls_dd02v-contflag   = i_contflag.
      ls_dd09l-tabname    = i_tabname.
      ls_dd09l-tabkat     = i_tabkat.
      ls_dd09l-tabart     = i_tabart.
      ls_dd09l-pufferung  = i_pufferung.
      ls_dd09l-bufallow   = i_bufallow.
      ls_dd09l-schfeldanz = i_schfeldanz.
      ls_dd09l-protokoll  = i_protokoll.
      ls_dd09l-speichpuff = i_speichpuff.
      IF <ls_dd09l_javaonly> IS ASSIGNED.         ">=SAPBASIS700
        <ls_dd09l_javaonly> = i_javaonly.         ">=SAPBASIS700
      ENDIF.                                      ">=SAPBASIS700
      l_treetype = 'TABL'.
    ELSE.
      l_treetype = 'CDS'.
    ENDIF.

    CALL METHOD add_to_transport
      EXPORTING
        i_object   = 'TABL'
        i_langu    = i_langu
        i_obj_name = i_tabname
        i_devclass = i_devclass
      EXCEPTIONS
        OTHERS     = 1.
    CHECK sy-subrc EQ 0.

    CALL FUNCTION 'DDIF_TABL_PUT'
      EXPORTING
        name              = i_tabname
        dd02v_wa          = ls_dd02v
        dd09l_wa          = ls_dd09l
      TABLES
        dd03p_tab         = lt_dd03p
        dd05m_tab         = lt_dd05m
        dd08v_tab         = lt_dd08v
        dd35v_tab         = lt_dd35v
        dd36m_tab         = lt_dd36m
      EXCEPTIONS
        tabl_not_found    = 1
        name_inconsistent = 2
        tabl_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc <> 0.
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    MESSAGE i666(01) WITH 'Update successful' INTO sy-lisel. "#EC *
    CALL METHOD log_message.

    CALL METHOD register_inactive_object
      EXPORTING
        i_objtype  = 'TABL'
        i_treetype = l_treetype
        i_objname  = i_tabname.


  ENDMETHOD.                    "create_table

  METHOD add_field_to_table.

    DATA: ls_dd02v             TYPE dd02v,
          ls_dd09l             TYPE dd09l,
          lt_dd03p             TYPE TABLE OF dd03p,
          ls_dd05m             TYPE dd05m,
          lt_dd05m             TYPE TABLE OF dd05m,
          ls_dd08v             TYPE dd08v,
          lt_dd08v             TYPE TABLE OF dd08v,
          lt_dd12v             TYPE TABLE OF dd12v,
          lt_dd17v             TYPE TABLE OF dd17v,
          lt_dd35v             TYPE TABLE OF dd35v,
          lt_dd36m             TYPE TABLE OF dd36m,
          lt_dd32p             TYPE tt_dd32p,
          ls_dd32p             TYPE dd32p,
          l_tabix              TYPE sytabix,
          lt_checktable_fields TYPE TABLE OF dd03p,
          ls_checktable_field  TYPE dd03p,
          ls_tabname           LIKE LINE OF gr_tabname VALUE 'IEQ'.

    FIELD-SYMBOLS: <ls_dd03p> TYPE dd03p.

    CALL METHOD set_context
      EXPORTING
        i_langu    = space
        i_text     = 'Add field(s) to table'                "#EC NOTEXT
        i_object   = 'TABD'
        i_obj_name = i_tabname.

    ls_tabname-low = i_tabname.
    COLLECT ls_tabname INTO gr_tabname.

    CALL FUNCTION 'DDIF_TABL_GET'
      EXPORTING
        name          = i_tabname
        state         = 'M'  "newest version (e.g. inactive)
      IMPORTING
*       GOTSTATE      = GOTSTATE
        dd02v_wa      = ls_dd02v
        dd09l_wa      = ls_dd09l
      TABLES
        dd03p_tab     = lt_dd03p
        dd05m_tab     = lt_dd05m
        dd08v_tab     = lt_dd08v
        dd12v_tab     = lt_dd12v
        dd17v_tab     = lt_dd17v
        dd35v_tab     = lt_dd35v
        dd36m_tab     = lt_dd36m
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    IF sy-subrc NE 0 OR ls_dd02v-tabname IS INITIAL.  "not existing.
      IF testrun IS INITIAL OR i_tabname NOT IN gr_tabname.
        MESSAGE e666(01) WITH 'Error while reading table' i_tabname INTO sy-lisel. "#EC *
        CALL METHOD log_message.
      ENDIF.
      RETURN.
    ENDIF.

    CASE ls_dd02v-tabclass.
      WHEN 'CLUSTER' OR 'POOL' OR 'TRANSP'.
        COLLECT ls_tabname INTO gr_dbtabname.
    ENDCASE.

    "check whether data element respectivly included/appended/referenced structure exists
    IF i_rollname IS NOT INITIAL.
      READ TABLE gr_rollname TRANSPORTING NO FIELDS WITH KEY low = i_rollname.  "new data element
      IF sy-subrc NE 0.
        READ TABLE gt_tabname TRANSPORTING NO FIELDS WITH KEY table_line = i_rollname.  "new structure
      ENDIF.
      IF sy-subrc NE 0.
        READ TABLE gt_ttypname TRANSPORTING NO FIELDS WITH KEY table_line = i_rollname.  "new table type
      ENDIF.
      IF sy-subrc NE 0.
        SELECT SINGLE rollname FROM dd04l INTO sy-lisel WHERE rollname EQ i_rollname.  "existing data element
      ENDIF.
      IF sy-subrc NE 0.
        SELECT SINGLE tabname FROM dd03l INTO sy-lisel WHERE tabname EQ i_rollname.  "existing structure
      ENDIF.
      IF sy-subrc NE 0.
        SELECT SINGLE typename FROM dd40l INTO sy-lisel WHERE typename EQ i_rollname.  "existing table_type
      ENDIF.
      IF sy-subrc NE 0.
        SELECT SINGLE clsname FROM seoclass INTO sy-lisel WHERE clsname EQ i_rollname.  "existing class
      ENDIF.
      IF sy-subrc NE 0.
        IF i_rollname(3) EQ 'CL_'. "probably a class
          MESSAGE w666(01) WITH 'Class' i_rollname 'does not exist (yet)' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
        ELSE.
          MESSAGE e666(01) WITH 'Data Element or Structure' i_rollname 'does not exist' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
          RETURN.
        ENDIF.
      ENDIF.
    ENDIF.

    "Find field to insert/change
    IF i_fieldname(6) EQ c_include6.
      READ TABLE lt_dd03p ASSIGNING <ls_dd03p>
           WITH KEY fieldname = i_fieldname
                    precfield = i_rollname
                    groupname = i_groupname.
      IF sy-subrc EQ 0.
        "INCLUDE already exists
        MESSAGE i666(01) WITH 'Include ' i_rollname 'already part of table' i_tabname INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        RETURN.
      ENDIF.
    ELSE.
      READ TABLE lt_dd03p ASSIGNING <ls_dd03p>
           WITH KEY fieldname = i_fieldname.
      IF sy-subrc EQ 0.
        "Check if fields already has data element
        IF i_rollname NE <ls_dd03p>-rollname.
          "change data element
          <ls_dd03p>-rollname  = i_rollname.
          MESSAGE i666(01) WITH 'Data element of field' i_fieldname 'will be changed to' i_rollname INTO sy-lisel. "#EC *
          CALL METHOD log_message.
        ELSEIF it_dd05m IS SUPPLIED OR is_dd08v IS NOT INITIAL.
          "update foreign key relation ship
          DATA: lt_dd05m_h TYPE tt_dd05m,
                it_dd05m_h TYPE tt_dd05m.

          lt_dd05m_h[] = lt_dd05m[].
          it_dd05m_h[] = it_dd05m[].
          DELETE lt_dd05m_h WHERE fieldname NE i_fieldname.
          CLEAR ls_dd05m.
          MODIFY lt_dd05m_h FROM ls_dd05m TRANSPORTING domname datatype leng WHERE fieldname IS NOT INITIAL.
          MODIFY it_dd05m_h FROM ls_dd05m TRANSPORTING domname datatype leng WHERE fieldname IS NOT INITIAL.
          CLEAR ls_dd08v.
          READ TABLE lt_dd08v INTO ls_dd08v WITH KEY fieldname = i_fieldname.
          IF lt_dd05m_h[] EQ it_dd05m[] AND ls_dd08v EQ is_dd08v.
            "field already exists with correct data element
            MESSAGE i666(01) WITH 'Field' i_fieldname 'already exists with SHLP' INTO sy-lisel. "#EC *
            CALL METHOD log_message.
            RETURN.
          ENDIF.
        ELSEIF i_languflag NE <ls_dd03p>-languflag.
          "field already exists with correct data element
          MESSAGE i666(01) WITH 'Properties of field' i_fieldname 'will be changed' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
        ELSE.
          "field already exists with correct data element
          MESSAGE i666(01) WITH 'Field' i_fieldname 'already exists' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
          RETURN.
        ENDIF.
      ENDIF.
    ENDIF.
    IF sy-subrc NE 0. "new field
      "Find context (one field is enough since fieldname is unique)
      IF i_context IS NOT INITIAL.
        READ TABLE lt_dd03p TRANSPORTING NO FIELDS
             WITH KEY fieldname = i_context.
        IF sy-subrc NE 0.
          READ TABLE lt_dd03p TRANSPORTING NO FIELDS  "include name as context
                WITH KEY precfield = i_context.
        ENDIF.
        IF sy-subrc NE 0 AND sy-tfill NE 0.
          IF testrun IS INITIAL OR i_tabname NOT IN gr_tabname.
            MESSAGE w666(01) WITH 'Context' i_context 'not found in TABD' i_tabname INTO sy-lisel. "#EC *
            CALL METHOD log_message.
          ELSE.
            MESSAGE i666(01) WITH 'Field' i_fieldname 'will be added' INTO sy-lisel. "#EC *
            CALL METHOD log_message.
          ENDIF.
          RETURN.
        ENDIF.

        "insert new field after context
        l_tabix = sy-tabix + 1.
      ELSE.
        "no context -> insert field at end
        l_tabix = lines( lt_dd03p ) + 1.
      ENDIF.

      INSERT INITIAL LINE INTO lt_dd03p INDEX l_tabix ASSIGNING <ls_dd03p>.
    ENDIF.

    <ls_dd03p>-tabname   = i_tabname.
    <ls_dd03p>-fieldname = i_fieldname.
    <ls_dd03p>-groupname = i_groupname.
    <ls_dd03p>-languflag = i_languflag.
    <ls_dd03p>-notnull   = i_notnull.
    <ls_dd03p>-keyflag   = i_keyflag.
    FIELD-SYMBOLS: <ls_dd01v_anonymous> TYPE c.
    ASSIGN ('LS_DD01V-ANONYMOUS') TO <ls_dd01v_anonymous>.
    IF sy-subrc EQ 0.
      <ls_dd01v_anonymous> = i_anonymous.
    ENDIF.
    IF i_fieldname(6) EQ c_include6.
      <ls_dd03p>-precfield = i_rollname.
      <ls_dd03p>-comptype  = 'S'.
    ELSEIF i_rollname IS INITIAL.
      <ls_dd03p>-datatype = i_datatype.
      <ls_dd03p>-decimals = i_decimals.
      <ls_dd03p>-leng     = i_leng.
      IF i_ddtext IS NOT INITIAL.
        <ls_dd03p>-ddtext     = i_ddtext.
        <ls_dd03p>-ddlanguage = i_langu.
      ENDIF.
    ELSE.
      <ls_dd03p>-rollname  = i_rollname.
    ENDIF.
    <ls_dd03p>-reftable = i_reftable.
    <ls_dd03p>-reffield = i_reffield.

    LOOP AT lt_dd03p ASSIGNING <ls_dd03p> FROM l_tabix.
      <ls_dd03p>-position = sy-tabix.
    ENDLOOP.
    "field will be added
    MESSAGE i666(01) WITH 'Field' i_fieldname 'will be added' INTO sy-lisel. "#EC *
    CALL METHOD log_message.

    IF is_dd08v IS NOT INITIAL OR it_dd05m IS SUPPLIED.
      DELETE lt_dd08v WHERE fieldname EQ i_fieldname.
      DELETE lt_dd05m WHERE fieldname EQ i_fieldname.

      LOOP AT it_dd05m INTO ls_dd05m WHERE checktable IS NOT INITIAL
                                       AND checkfield IS NOT INITIAL.
        APPEND ls_dd05m TO lt_dd05m.
      ENDLOOP.
      IF is_dd08v IS NOT INITIAL.
        APPEND is_dd08v TO lt_dd08v.
      ENDIF.
    ENDIF.

    CHECK testrun IS INITIAL.

    CALL METHOD add_to_transport
      EXPORTING
        i_object   = 'TABL'
        i_obj_name = i_tabname
      EXCEPTIONS
        OTHERS     = 1.
    CHECK sy-subrc EQ 0.

    CALL FUNCTION 'DDIF_TABL_PUT'
      EXPORTING
        name              = i_tabname
        dd02v_wa          = ls_dd02v
        dd09l_wa          = ls_dd09l
      TABLES
        dd03p_tab         = lt_dd03p
        dd05m_tab         = lt_dd05m
        dd08v_tab         = lt_dd08v
        dd35v_tab         = lt_dd35v
        dd36m_tab         = lt_dd36m
      EXCEPTIONS
        tabl_not_found    = 1
        name_inconsistent = 2
        tabl_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc <> 0.
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    CALL METHOD register_inactive_object
      EXPORTING
        i_objtype = 'TABL'
        i_objname = i_tabname.

  ENDMETHOD.                    "add_field_to_table





  METHOD activate.

    DATA: lt_dwinactiv TYPE TABLE OF dwinactiv,
          lv_answer,
          l_request    TYPE trkorr,
          l_logname    TYPE ddprh-protname,
          ls_job       TYPE tbtcjob,
          lv_rc        TYPE sysubrc,
          l_act_rc     TYPE sysubrc.

    FIELD-SYMBOLS: <ls_dwinactiv> LIKE LINE OF lt_dwinactiv,
                   <ls_viewname>  TYPE viewname.

    CALL METHOD set_context
      EXPORTING
        i_langu    = space
        i_object   = space
        i_obj_name = 'Activation'.                          "#EC *

    IF testrun IS INITIAL.
      "activate switches "online"
      IF gr_switchname IS NOT INITIAL.
        SELECT * FROM dwinactiv INTO TABLE lt_dwinactiv
                                     WHERE obj_name IN gr_switchname.
        IF lt_dwinactiv[] IS  NOT INITIAL.
          LOOP AT lt_dwinactiv ASSIGNING <ls_dwinactiv>
                                WHERE uname NE sy-uname
                                  AND obj_name IN gr_switchname.
            <ls_dwinactiv>-uname = sy-uname.
          ENDLOOP.
          INSERT dwinactiv FROM TABLE lt_dwinactiv ACCEPTING DUPLICATE KEYS.
        ENDIF.

        MESSAGE s357(scwn).
        CALL FUNCTION 'RS_WORKING_OBJECT_ACTIVATE'
          EXPORTING
            dictionary_only = 'X'
          TABLES
            objects         = lt_dwinactiv
          EXCEPTIONS
            OTHERS          = 5.
      ENDIF.

      "make sure that ranges are not empty
      APPEND 'IEQ' TO: gr_domname,
                       gr_rollname,
                       gr_tabname,
                       gr_shlpname,
                       gr_viewname,
                       gr_ttypname,
                       gr_guistatus,
                       gr_indexes,
                       gr_indxtab,
                       gr_indxname.

      SELECT * FROM dwinactiv INTO TABLE lt_dwinactiv
              WHERE ( object NE space )   "dummy
                AND ( obj_name IN gr_domname
                   OR obj_name IN gr_rollname
                   OR obj_name IN gr_tabname
                   OR obj_name IN gr_shlpname
                   OR obj_name IN gr_viewname
                   OR obj_name IN gr_ttypname
                   OR obj_name IN gr_guistatus
                   OR obj_name IN gr_indexes ).
    ENDIF.

    IF lt_dwinactiv[] IS INITIAL AND gv_repository_changed IS INITIAL.
      MESSAGE i666(01) WITH 'No repository changes made' '' '' '' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      IF gv_translation EQ 'X' OR gv_copy_translation EQ 'X'.
        MESSAGE i666(01) WITH 'Translation has been updated' '' '' '' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
      ENDIF.
    ELSEIF gv_errors_occured IS NOT INITIAL.
      MESSAGE w666(01) WITH 'Activation was skipped because of errors' 'in previous steps. Please try again.' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
    ELSE.
      "add all relevant inactive objects also to current user's worklist
      "gets relevant if a different user is doing the activation.
      "entries for all users will be deleted if any user activates the object
      LOOP AT lt_dwinactiv ASSIGNING <ls_dwinactiv>
                           WHERE uname NE sy-uname.
        <ls_dwinactiv>-uname = sy-uname.
      ENDLOOP.
      INSERT dwinactiv FROM TABLE lt_dwinactiv ACCEPTING DUPLICATE KEYS.

      IF i_result_auth_check IS INITIAL.

        LOOP AT lt_dwinactiv TRANSPORTING NO FIELDS
                             WHERE object = 'DOMA' OR
                                   object = 'DTEL' OR
                                   object = 'TABL' OR
                                   object = 'INDX' OR
                                   object = 'VIEW' OR
                                   object = 'TTYP' OR
                                   object = 'SHLP'.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          IF gv_unit_test IS NOT INITIAL.
            lv_answer = '1'.  "force online activation
          ELSE.
            CALL FUNCTION 'POPUP_TO_CONFIRM'
              EXPORTING
                titlebar              = 'Activation'        "#EC NOTEXT
                text_question         = 'How do you want to activate DDIC?' "#EC NOTEXT
                text_button_1         = 'Online'            "#EC NOTEXT
                text_button_2         = 'Batch'             "#EC NOTEXT
                display_cancel_button = 'X'
              IMPORTING
                answer                = lv_answer
              EXCEPTIONS
                OTHERS                = 1.
            IF sy-subrc <> 0.
              MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
              CALL METHOD log_message.
            ENDIF.
          ENDIF.

          "DDIC via RADMASG0
          "remove DDIC objects from worklist
          DELETE lt_dwinactiv WHERE object = 'DOMA' OR
                                    object = 'DTEL' OR
                                    object = 'TABL' OR
                                    object = 'INDX' OR
                                    object = 'VIEW' OR
                                    object = 'TTYP' OR
                                    object = 'SHLP'.
        ENDIF.

        IF lv_answer NE 'A' AND lt_dwinactiv[] IS NOT INITIAL.
          "1) activate non DDIC objects (e.g. CUAD) online
          MESSAGE s357(scwn).
          CALL FUNCTION 'RS_WORKING_OBJECT_ACTIVATE'
            EXPORTING
              dictionary_only = 'X'
*             cwb_mode        = 'X'
            TABLES
              objects         = lt_dwinactiv
            EXCEPTIONS
              OTHERS          = 5.
          IF sy-subrc <> 0.
            MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            CALL METHOD log_message.
          ENDIF.

          MESSAGE s357(scwn).
          CALL FUNCTION 'RS_WORKING_OBJECT_ACTIVATE'
            EXPORTING
              dictionary_only = ' '
*             cwb_mode        = 'X'
            TABLES
              objects         = lt_dwinactiv
            EXCEPTIONS
              OTHERS          = 5.
          IF sy-subrc <> 0.
            lv_answer = 'A'.
            CALL METHOD log_message.
            MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
        ENDIF.

        IF sy-repid(2) EQ '%_'. "Temp. Subroutine Pool
          l_logname = 'UDO'.
        ELSEIF sy-repid(1) EQ '/'.
          SPLIT sy-repid AT '/' INTO l_logname l_logname l_logname. "remove namespace
        ELSE.
          l_logname = sy-repid.
        ENDIF.
        CONCATENATE l_logname sy-datum sy-uzeit INTO l_logname SEPARATED BY '_'.

        break backesr.
        IF lv_answer = '1' OR i_actmode = 2.
          "2a) activate DDIC online
          IF i_actmode = 1.  "1 step activation
            SUBMIT radmasg0 WITH domname  IN gr_domname
                            WITH rollname IN gr_rollname
                            WITH tabname  IN gr_tabname
                            WITH indxtab  IN gr_indxtab
                            WITH indxname IN gr_indxname
                            WITH viewname IN gr_viewname
                            WITH ttypname IN gr_ttypname
                            WITH shlpname IN gr_shlpname
                            WITH logname  EQ l_logname

                            WITH ddmode   = 'O'        "normal Modus
                            WITH logshow  = 'X'

                            AND RETURN.

          ELSEIF i_actmode = 2. "2 step activation
            SUBMIT radmasg0 WITH domname  IN gr_domname
                            WITH rollname IN gr_rollname
                            WITH tabname  IN gr_tabname
                            WITH indxtab  IN gr_indxtab
                            WITH indxname IN gr_indxname
                            WITH viewname IN gr_viewname
                            WITH ttypname IN gr_ttypname
                            WITH shlpname IN gr_shlpname
                            WITH logname  EQ l_logname

                            WITH ddmode   = 'T'        "normal Modus
                            WITH logshow  = ' '

                            AND RETURN.
          ENDIF.
          IMPORT act_rc TO l_act_rc FROM MEMORY ID 'ACRC'.
          IF l_act_rc > 4.  "4 is only warning
            DATA: lt_log TYPE TABLE OF trlog,
                  ls_log TYPE trlog.
            CALL FUNCTION 'TR_READ_LOG'
              EXPORTING
                iv_log_type   = 'DB'
                iv_logname_db = l_logname
*               IV_TIMESTAMP  = '00000000000000'
              TABLES
                et_lines      = lt_log
              EXCEPTIONS
                invalid_input = 1
                access_error  = 2
                OTHERS        = 3.
            MESSAGE e666(01) WITH 'Errors during DDIC activation:' INTO sy-lisel.
            CALL METHOD log_message.
            "append errors from activation log
            LOOP AT lt_log INTO ls_log WHERE severity EQ 'E'.
              MESSAGE e666(01) WITH ls_log-line INTO sy-lisel.
              CALL METHOD log_message.
            ENDLOOP.
          ELSEIF i_actmode = 2.
            "Nach-Aktivieren der DB-Tabellen (teilweise "Tabelle existiert nicht auf der DB")
            SUBMIT radmasg0 WITH tabname  IN gr_dbtabname
                            WITH indxtab  IN gr_indxtab
                            WITH indxname IN gr_indxname
                            WITH logname  EQ l_logname
                            WITH logshow  = space
                            WITH ddmode   = 'O'
                            WITH frcact   = 'X'
                            AND RETURN.

            IMPORT act_rc TO l_act_rc FROM MEMORY ID 'ACRC'.
            IF l_act_rc > 4.  "4 is only warning
              MESSAGE e666(01) WITH 'Errors during DDIC activation Step 2' INTO sy-lisel. "#EC *
              CALL METHOD log_message.
            ENDIF.
          ENDIF.

          IF l_act_rc <= 4.  "4 is only warning
            "make a test SELECT * FROM table UP TP 1 ROWS to see whether it is really consistent
            DATA: ls_dbtabname LIKE LINE OF gr_dbtabname,
                  l_message    TYPE sy-lisel.
            CLEAR l_message.
            LOOP AT gr_dbtabname INTO ls_dbtabname.
              "go via RFC to have the chance to catch short dumps
              CALL FUNCTION 'RFC_READ_TABLE' DESTINATION 'NONE'
                EXPORTING
                  query_table    = ls_dbtabname-low
                  rowcount       = 1
                EXCEPTIONS
                  system_failure = 1  MESSAGE l_message
                  OTHERS         = 0.
              IF sy-subrc <> 0.
                MESSAGE e666(01) WITH l_message INTO sy-lisel. "#EC *
                CALL METHOD log_message.
              ENDIF.
            ENDLOOP.
            IF l_message IS INITIAL.
              MESSAGE s666(01) WITH 'DDIC activation successful' INTO sy-lisel. "#EC *
              CALL METHOD log_message.
            ELSE.
              MESSAGE e666(01) WITH 'Errors during DDIC activation Step 3' INTO sy-lisel. "#EC *
              CALL METHOD log_message.
            ENDIF.
          ENDIF.
          MESSAGE i666(01) WITH 'Use Report RADPROTB to view detailed' 'activation logs with name' l_logname INTO sy-lisel. "#EC *
          CALL METHOD log_message.

        ELSEIF lv_answer = '2' .
          "2b) activate DDIC objects via batch job
          ls_job-jobname = sy-repid.

          CALL FUNCTION 'JOB_OPEN'
            EXPORTING
              jobname          = ls_job-jobname
            IMPORTING
              jobcount         = ls_job-jobcount
            CHANGING
              ret              = lv_rc
            EXCEPTIONS
              cant_create_job  = 1
              invalid_job_data = 2
              jobname_missing  = 3
              OTHERS           = 4.
          IF sy-subrc <> 0 OR lv_rc NE 0.
            MESSAGE e026(bt) WITH ls_job-jobname INTO sy-lisel. "#EC *
            CALL METHOD log_message.
          ELSE.
            "only 1 step allowed!
            SUBMIT radmasg0 WITH domname  IN gr_domname
                            WITH rollname IN gr_rollname
                            WITH tabname  IN gr_tabname
                            WITH indxtab  IN gr_indxtab
                            WITH indxname IN gr_indxname
                            WITH viewname IN gr_viewname
                            WITH ttypname IN gr_ttypname
                            WITH shlpname IN gr_shlpname
                            WITH logname  EQ l_logname

                            WITH ddmode   = 'O'
                            WITH frcact   = 'X'
                            WITH logshow  = 'X'

                            VIA JOB ls_job-jobname
                            NUMBER ls_job-jobcount
                            AND RETURN.

            CALL FUNCTION 'JOB_CLOSE'
              EXPORTING
                jobcount  = ls_job-jobcount
                jobname   = ls_job-jobname
                strtimmed = 'X'
              EXCEPTIONS
                OTHERS    = 1.
            IF sy-subrc EQ 0.
              MESSAGE s305(ut) WITH ls_job-jobname INTO sy-lisel. "#EC *
              CALL METHOD log_message.
              MESSAGE i666(01) WITH 'Use Report RADPROTB to view activation log' l_logname
                                    'after job has finished'
                                    'in transaction SMX.'.  "#EC NOTEXT
              CALL METHOD log_message.
            ELSE.
              MESSAGE e026(bt) WITH ls_job-jobname INTO sy-lisel. "#EC *
              CALL METHOD log_message.
            ENDIF.
          ENDIF.
        ENDIF.
      ELSE.
        MESSAGE i666(01) WITH 'No authorization to activate the DDIC changes.'
                              'Call transaction SU53 for details' '' ''. "#EC NOTEXT
        sy-msgty = 'E'.
        CALL METHOD log_message.
      ENDIF.
    ENDIF.

    SET PARAMETER ID 'EUK' FIELD space.
    EXPORT current_devclass FROM space TO MEMORY ID 'EUK'.

  ENDMETHOD.                    "activate




  METHOD add_to_transport.

    STATICS: s_object   LIKE i_object,
             s_obj_name TYPE string,
             s_subrc    TYPE sysubrc.

    DATA: l_tadir_name   TYPE tadir-obj_name,
          l_object_name  TYPE string,
          l_object_class TYPE string,
          l_extend,
          l_global_lock,
          ls_trkey       TYPE trkey,
          lv_msgty       TYPE symsgty.

    CLEAR sy-subrc.
    CHECK gv_copy_translation IS INITIAL.
    CHECK testrun IS INITIAL.

    IF i_object   NE s_object OR
       i_obj_name NE s_obj_name.

      s_object   = i_object.
      s_obj_name = i_obj_name.

      CASE i_object.
        WHEN 'REPT' OR 'FUNC' OR 'CUAD' OR 'DOCU'.
          l_object_class = i_object.
          l_object_name  = i_obj_name.
        WHEN 'DOCV' OR 'DOCT' OR 'DSYS' OR 'STCS' OR 'MSAG'.
          l_object_class = i_object.
          l_object_name  = i_obj_name.
          l_global_lock  = 'X'.
          l_extend       = 'X'.
          l_tadir_name   = i_obj_name.
        WHEN 'MESS'.
          l_object_class = 'T100'.
          l_object_name  = i_obj_name.
        WHEN 'CLAS' OR 'FUGR' OR 'PARA' OR 'VCLS' OR 'AUTH'.
          l_object_class = i_object.
          l_object_name  = i_obj_name.
          l_tadir_name   = i_obj_name.
          l_global_lock  = 'X'.
        WHEN 'DOMA' OR 'DTEL' OR 'TABL' OR 'VIEW' OR 'INDX' OR 'TTYP' OR 'SHLP'.
          l_object_class = 'DICT'.
          CONCATENATE i_object i_obj_name
                 INTO l_object_name.
          l_tadir_name   = i_obj_name.
        WHEN OTHERS.
          l_object_class = i_object.
          l_object_name  = i_obj_name.
      ENDCASE.

      "create TADIR entry in advance avoid popup
      IF l_tadir_name IS NOT INITIAL.
        DATA: ls_tadir_old TYPE tadir.
        SELECT SINGLE * FROM tadir INTO ls_tadir_old
                       WHERE pgmid      EQ 'R3TR'
                         AND object     EQ i_object
                         AND obj_name   EQ l_tadir_name.
        IF i_langu CA 'ED'.
          "set correct language and package on first call per object
          "skip this for other languages than EN/DE.
          CALL FUNCTION 'TR_TADIR_INTERFACE'
            EXPORTING
*             WI_DELETE_TADIR_ENTRY = ' '
              wi_test_modus         = space
              wi_tadir_pgmid        = 'R3TR'
              wi_tadir_object       = i_object
              wi_tadir_obj_name     = l_tadir_name
              wi_tadir_devclass     = i_devclass
              wi_tadir_masterlang   = i_langu
            EXCEPTIONS
              OTHERS                = 25.
          IF sy-subrc <> 0.
          ENDIF.
        ENDIF.
        IF i_devclass IS NOT INITIAL.
          "set correct package in memory
          EXPORT current_devclass FROM i_devclass TO MEMORY ID 'EUK'.
          SET PARAMETER ID 'EUK' FIELD i_devclass.
        ENDIF.
      ENDIF.

      CALL FUNCTION 'RS_CORR_INSERT'    "and create TADIR-entry
        EXPORTING
          object              = l_object_name
          object_class        = l_object_class
          devclass            = i_devclass
          korrnum             = gv_trkorr
          global_lock         = l_global_lock
*         AUTHOR              = ' '
          master_language     = i_langu
*         GENFLAG             = ' '
*         PROGRAM             = ' '
*         OBJECT_CLASS_SUPPORTS_MA = ' '
          extend              = l_extend
*         SUPPRESS_DIALOG     = ' '
*         MOD_LANGU           = ' '
*         ACTIVATION_CALL     = ' '
        IMPORTING
          korrnum             = gv_trkorr
*         ORDERNUM            =
*         NEW_CORR_ENTRY      =
*         AUTHOR              =
          transport_key       = ls_trkey
*         NEW_EXTEND          =
        EXCEPTIONS
          cancelled           = 1
          permission_failure  = 2
          unknown_objectclass = 3
          OTHERS              = 4.
      s_subrc = sy-subrc.

      "correct master language if neccessary
      IF l_tadir_name IS NOT INITIAL AND ls_tadir_old IS INITIAL.
        IF i_langu CA 'ED'.
          UPDATE tadir SET masterlang = i_langu
                     WHERE pgmid      EQ 'R3TR'
                       AND object     EQ i_object
                       AND obj_name   EQ l_tadir_name
                       AND masterlang NE i_langu.
        ENDIF.
      ENDIF.

    ENDIF.

    IF s_subrc NE 0.
      MESSAGE e666(01) WITH 'Could not add to transport request' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      RAISE error.
    ENDIF.

  ENDMETHOD.                    "add_to_transport

  METHOD register_inactive_object.

    DATA: l_obj_name TYPE e071-obj_name.

    l_obj_name = i_objname.
    CALL FUNCTION 'RS_INSERT_INTO_WORKING_AREA'
      EXPORTING
        object            = i_objtype
        obj_name          = l_obj_name
      EXCEPTIONS
        wrong_object_name = 1
        OTHERS            = 2.

    IF i_treetype IS SUPPLIED.
      CHECK i_treetype NE space.
      CALL FUNCTION 'RS_TREE_OBJECT_PLACEMENT'
        EXPORTING
          type   = i_treetype
          object = l_obj_name.
    ELSE.
      CALL FUNCTION 'RS_TREE_OBJECT_PLACEMENT'
        EXPORTING
          type   = i_objtype
          object = l_obj_name.
    ENDIF.

  ENDMETHOD.                    "register_inactive_object


  METHOD create_message.

    DATA: lt_bdc       TYPE TABLE OF bdcdata,
          ls_bdc       TYPE bdcdata,
          ls_bdcp      TYPE bdcdata,
          ls_radio     LIKE ls_bdc-fnam,
          ls_opt       TYPE ctu_params.
    DATA: ls_t100      TYPE t100,
          ls_t100a     TYPE t100a,
          ls_t100u     TYPE t100u,
          l_obj_name   TYPE dokil-object,
          ls_msg_class LIKE LINE OF gr_msg_class VALUE 'IEQ'.

    ls_msg_class-low = i_msgid.
    COLLECT ls_msg_class INTO gr_msg_class.

    CALL METHOD set_context
      EXPORTING
        i_langu     = i_langu
        i_object    = 'MESS'
        i_obj_name  = i_msgid
        i_obj_name2 = i_msgno.

    SELECT SINGLE * FROM t100a INTO ls_t100a
                   WHERE arbgb EQ i_msgid.
    IF sy-subrc NE 0.
      IF testrun IS INITIAL OR i_msgid NOT IN gr_msg_class.
        MESSAGE e509(eu) WITH i_msgid INTO sy-lisel.        "#EC *
        CALL METHOD log_message.
      ENDIF.
      RETURN.
    ENDIF.

    SELECT SINGLE * FROM t100 INTO ls_t100
                   WHERE sprsl EQ i_langu
                     AND arbgb EQ i_msgid
                     AND msgnr EQ i_msgno.

    SELECT SINGLE * FROM t100u INTO ls_t100u
                   WHERE arbgb EQ i_msgid
                     AND msgnr EQ i_msgno.
    IF i_text EQ ls_t100-text.
      IF i_selfdef IS INITIAL     AND ls_t100u-selfdef IS INITIAL OR
         i_selfdef IS NOT INITIAL AND ls_t100u-selfdef IS NOT INITIAL.
        MESSAGE i666(01) WITH 'No update necessary' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        RETURN.
      ENDIF.
    ENDIF.

    CHECK testrun IS INITIAL.

    CALL FUNCTION 'DOCU_OBJECT_NAME_CONCATENATE'
      EXPORTING
        docu_id  = 'NA'
        element  = i_msgid
        addition = i_msgno
      IMPORTING
        object   = l_obj_name
      EXCEPTIONS
        OTHERS   = 0.

    CALL METHOD add_to_transport
      EXPORTING
        i_object   = 'MESS'
        i_obj_name = l_obj_name
      EXCEPTIONS
        OTHERS     = 1.
    CHECK sy-subrc EQ 0.

    IF i_langu EQ ls_t100a-masterlang AND gv_copy_translation IS INITIAL.
      "create or change message and write into transport request
      "if sy-langu is different from master language SE91 will switch to master lang

      "-------------------------------------------
      ls_bdcp-program  = 'SAPLWBMESSAGES'.
      ls_bdcp-dynpro   = '0100'.
      ls_bdcp-dynbegin = 'X'.
      APPEND ls_bdcp TO lt_bdc.

*    ls_bdc-fnam = 'BDC_CURSOR'.
*    ls_bdc-fval = 'MSG_NUMMER'.
*    APPEND ls_bdc TO lt_bdc.

      ls_bdc-fnam = 'RSDAG-ARBGB'.
      ls_bdc-fval = i_msgid.
      APPEND ls_bdc TO lt_bdc.

      ls_bdc-fnam = 'MSG_NUMMER'.
      ls_bdc-fval = i_msgno.
      APPEND ls_bdc TO lt_bdc.

      ls_bdc-fnam = 'RSDAG-MSGFLAG'.
      ls_bdc-fval = 'X'.
      APPEND ls_bdc TO lt_bdc.

      ls_bdc-fnam = 'BDC_OKCODE'.
      ls_bdc-fval = '=WB_EDIT'.
      APPEND ls_bdc TO lt_bdc.

      "-------------------------------------------
      ls_bdcp-dynpro   = '1000'.
      ls_bdcp-dynbegin = 'X'.
      APPEND ls_bdcp TO lt_bdc.

      ls_bdc-fnam = 'BDC_SUBSCR'.
      ls_bdc-fval = 'SAPLWBMESSAGES 0101SUB'.
      APPEND ls_bdc TO lt_bdc.

      ls_bdc-fnam = 'T100-TEXT(01)'.
      ls_bdc-fval = i_text.
      APPEND ls_bdc TO lt_bdc.

      ls_bdc-fnam = 'LISTTAB-DOKU_FLAG(01)'.
      IF i_selfdef IS INITIAL.
        ls_bdc-fval = ' '.
      ELSE.
        ls_bdc-fval = 'X'.
      ENDIF.
      APPEND ls_bdc TO lt_bdc.

      ls_bdc-fnam = 'BDC_OKCODE'.
      ls_bdc-fval = '=WB_SAVE'.
      APPEND ls_bdc TO lt_bdc.

      "-------------------------------------------
      ls_bdcp-dynpro   = '1000'.
      ls_bdcp-dynbegin = 'X'.
      APPEND ls_bdcp TO lt_bdc.

      ls_bdc-fnam = 'BDC_OKCODE'.
      ls_bdc-fval = '=WB_BACK'.
      APPEND ls_bdc TO lt_bdc.

      "-------------------------------------------
      ls_bdcp-dynpro   = '0100'.
      ls_bdcp-dynbegin = 'X'.
      APPEND ls_bdcp TO lt_bdc.

      ls_bdc-fnam = 'BDC_OKCODE'.
      ls_bdc-fval = '=WB_BACK'.
      APPEND ls_bdc TO lt_bdc.

      ls_opt-dismode  = 'E'.
      ls_opt-racommit = 'X'.
      ls_opt-nobinpt  = 'X'.
      ls_opt-nobiend  = 'X'.

      "-------------------------------------------
      CALL TRANSACTION 'SE91' USING lt_bdc OPTIONS FROM ls_opt.
    ELSE.
      "update translation only
      ls_t100-arbgb = i_msgid.
      ls_t100-msgnr = i_msgno.
      ls_t100-sprsl = i_langu.
      ls_t100-text  = i_text.
      MODIFY t100 FROM ls_t100.  "no activation needed
    ENDIF.
    MESSAGE i666(01) WITH 'Update successful' INTO sy-lisel. "#EC *
    CALL METHOD log_message.
    gv_translation        = 'X'.
    gv_repository_changed = 'X'.

  ENDMETHOD.                    "create_message











  METHOD log_message.

    DATA: ls_msg     TYPE bal_s_msg.

    IF sy-msgno IS INITIAL OR sy-msgid IS INITIAL.
      MESSAGE i666(01) WITH 'unknown error' INTO sy-lisel.  "#EC *
    ENDIF.
    MOVE-CORRESPONDING syst TO ls_msg.

    CALL FUNCTION 'BAL_LOG_MSG_ADD'
      EXPORTING
        i_log_handle = gv_log_handle
        i_s_msg      = ls_msg
      EXCEPTIONS
        OTHERS       = 0.

    IF ls_msg-msgty CA 'EA'.
      gv_errors_occured = 'X'.
    ENDIF.

  ENDMETHOD.                    "log_message

  METHOD display_log.

    DATA: lt_log_handle TYPE bal_t_logh,
          ls_profile    TYPE bal_s_prof,
          l_s_fcat      TYPE bal_s_fcat,
          lt_dfies      TYPE TABLE OF dfies,
          ls_dfies      TYPE dfies.
    DATA: ls_filter     TYPE bal_s_lfil,
          lr_filter     TYPE bal_s_extn, "range table
          lr_extnumber  TYPE bal_s_extn, "range table
          ls_s_log      TYPE bal_s_log,
          lt_log_header TYPE balhdr_t,
          lr_handle     TYPE bal_s_logh. "range table

    IF gv_log_handle IS INITIAL.

      CLEAR: ls_filter, lr_extnumber.

*- Search only log file of this application
      lr_filter-sign   = 'I'.
      lr_filter-option = 'EQ'.
      lr_filter-low    = c_bal_object.
      APPEND lr_filter TO ls_filter-object.

      lr_filter-sign   = 'I'.
      lr_filter-option = 'EQ'.
      lr_filter-low    = c_bal_subobj.
      APPEND lr_filter TO ls_filter-subobject.

*- Search only log file of this change number
      lr_extnumber-low    = sy-repid.
      lr_extnumber-sign   = 'I'.
      lr_extnumber-option = 'EQ'.
      APPEND lr_extnumber TO ls_filter-extnumber.

*-- Search for log files on the database
      CALL FUNCTION 'BAL_DB_SEARCH'
        EXPORTING
          i_s_log_filter     = ls_filter
        IMPORTING
          e_t_log_header     = lt_log_header
        EXCEPTIONS
          log_not_found      = 1
          no_filter_criteria = 2
          OTHERS             = 3.
      IF sy-subrc EQ 0.
*-- Load log files from database into memory
        CALL FUNCTION 'BAL_DB_LOAD'
          EXPORTING
            i_t_log_header     = lt_log_header
          IMPORTING
            e_t_log_handle     = lt_log_handle
          EXCEPTIONS
            no_logs_specified  = 1
            log_not_found      = 2
            log_already_loaded = 3
            OTHERS             = 4.
      ENDIF.
    ELSE.
      APPEND gv_log_handle TO lt_log_handle.
    ENDIF.

    IF 1 = 1.
      "grid
      CALL FUNCTION 'BAL_DSP_PROFILE_SINGLE_LOG_GET'
        IMPORTING
          e_s_display_profile = ls_profile
        EXCEPTIONS
          OTHERS              = 0.
      "Set profile
      ls_profile-show_all   = abap_on.
      ls_profile-use_grid   = abap_on.
      ls_profile-tree_ontop = abap_on.
      ls_profile-exp_level  = 1.
      ls_profile-mess_mark  = abap_on.
    ELSE.
      "tree
      CALL FUNCTION 'BAL_DSP_PROFILE_DETLEVEL_GET'
        IMPORTING
          e_s_display_profile = ls_profile
        EXCEPTIONS
          OTHERS              = 0.
    ENDIF.

    "add own fields to field cat
    CALL FUNCTION 'DDIF_FIELDINFO_GET'
      EXPORTING
        tabname        = c_bal_context
      TABLES
        dfies_tab      = lt_dfies
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.
    ASSERT sy-subrc EQ 0.

    LOOP AT lt_dfies INTO ls_dfies WHERE fieldname EQ 'OBJECT'
                                      OR fieldname EQ 'OBJ_NAME'.
      l_s_fcat-ref_table = c_bal_context.
      l_s_fcat-ref_field = ls_dfies-fieldname.
      l_s_fcat-outputlen = ls_dfies-outputlen + 1.
*      l_s_fcat-col_pos   = 100 + sy-tabix.   "most rigth columns
      APPEND l_s_fcat TO ls_profile-mess_fcat.
    ENDLOOP.


    "set parameters for saving layout.
    ls_profile-disvariant-report = sy-repid.
    ls_profile-disvariant-handle = c_bal_subobj.

    CALL FUNCTION 'BAL_DSP_LOG_DISPLAY'
      EXPORTING
        i_t_log_handle      = lt_log_handle
        i_s_display_profile = ls_profile
        i_amodal            = space
      EXCEPTIONS
        OTHERS              = 0.

    CALL FUNCTION 'BAL_DB_SAVE'
      EXPORTING
        i_t_log_handle = lt_log_handle
      EXCEPTIONS
        OTHERS         = 0.

  ENDMETHOD.                    "display_log

  METHOD set_context.

    STATICS: BEGIN OF lss_key, "save last key
               i_object    TYPE e071-object,
               i_obj_name  TYPE adir_key-obj_name,
               i_obj_name2 TYPE adir_key-obj_name,
               i_text      TYPE string,
               i_langu     TYPE sylangu,
             END OF lss_key.

    DATA: ls_msg_defaults TYPE bal_s_mdef,
          ls_context      TYPE adir_key,
          ls_object_text  TYPE ko100,
          ls_doktype      TYPE dd07v,
          l_text(70),
          l_mode          TYPE string,
          ls_key          LIKE lss_key.

    DATA: ls_e071      TYPE e071,
          ls_tadir     TYPE tadir,
          ls_tadir_key TYPE tadir.

    ls_key-i_object    = i_object.
    ls_key-i_obj_name  = i_obj_name.
    ls_key-i_obj_name2 = i_obj_name2.
    ls_key-i_text      = i_text.
    ls_key-i_langu     = i_langu.
    IF ls_key EQ lss_key. "check last key
      "avoid double message like "add field to table"
      RETURN.
    ELSE.
      lss_key = ls_key.
    ENDIF.

    ls_context-object   = i_object.
    CONCATENATE i_obj_name i_obj_name2 INTO ls_context-obj_name.
    ls_msg_defaults-log_handle      = gv_log_handle.
    ls_msg_defaults-context-value   = ls_context.
    ls_msg_defaults-context-tabname = c_bal_context.

    CALL FUNCTION 'BAL_GLB_MSG_DEFAULTS_SET'
      EXPORTING
        i_s_msg_defaults = ls_msg_defaults
      EXCEPTIONS
        OTHERS           = 0.

    "try to check if object exists
    IF i_object IS NOT INITIAL AND i_obj_name IS NOT INITIAL.
      ls_e071-pgmid    = 'R3TR'.
      ls_e071-object   = i_object.
      ls_e071-obj_name = i_obj_name.

      CALL FUNCTION 'SCWB_GET_TADIR_REM'
        EXPORTING
          is_e071      = ls_e071
        IMPORTING
          es_tadir_key = ls_tadir_key
          es_tadir     = ls_tadir.
      IF ls_tadir_key IS INITIAL.
        ls_e071-pgmid   = 'LIMU'.
        CALL FUNCTION 'SCWB_GET_TADIR_REM'
          EXPORTING
            is_e071      = ls_e071
          IMPORTING
            es_tadir_key = ls_tadir_key
            es_tadir     = ls_tadir.
      ENDIF.

      IF ls_tadir IS INITIAL.
        l_mode = 'Create'.                                  "#EC NOTEXT
      ELSE.
        l_mode = 'Change'.                                  "#EC NOTEXT
        "check if object has been manually modified by customer.
        SELECT COUNT( * ) FROM adiraccess WHERE pgmid    EQ ls_tadir-pgmid
                                            AND object   EQ ls_tadir-object
                                            AND obj_name EQ ls_tadir-obj_name.
        IF sy-dbcnt NE 0.
          MESSAGE w666(01) WITH ls_tadir-object ls_tadir-obj_name 'was manually changed before.' 'Please adjust manually afterwards' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
        ENDIF.
      ENDIF.
    ENDIF.

    IF i_text IS INITIAL.
      CALL METHOD get_object_text
        EXPORTING
          i_object   = i_object
          i_obj_name = i_obj_name
        RECEIVING
          r_text     = l_text.

      CONCATENATE l_mode l_text INTO l_text SEPARATED BY space.
    ELSE.
      l_text = i_text.
    ENDIF.

    IF l_text IS NOT INITIAL.
      IF i_langu IS NOT INITIAL.
        MESSAGE s666(01) WITH l_text '( language' i_langu ')' INTO l_text.
      ENDIF.
      CALL FUNCTION 'BAL_LOG_MSG_ADD_FREE_TEXT'
        EXPORTING
          i_msgty = 'I'
          i_text  = l_text
        EXCEPTIONS
          OTHERS  = 0.
    ENDIF.

  ENDMETHOD.                    "set_context

  METHOD support_pack_applied.

    DATA: lt_trkorr TYPE TABLE OF trkorr.

    SPLIT i_trkorr_list AT space INTO TABLE lt_trkorr.
    SELECT COUNT( * ) FROM e070 UP TO 1 ROWS
                      FOR ALL ENTRIES IN lt_trkorr
                      WHERE trkorr EQ lt_trkorr-table_line.
    IF sy-subrc EQ 0.
      r_applied = 'X'.
    ENDIF.

  ENDMETHOD.                    "support_pack_applied

  METHOD software_comp_applied.
    CLEAR e_cvers.
    SELECT SINGLE * FROM cvers
                    INTO e_cvers
                    WHERE component = i_component.
    IF sy-subrc IS NOT INITIAL.
      RAISE not_applied.
    ENDIF.
  ENDMETHOD.                    "software_comp_applied


ENDCLASS.                    "lcl_wb IMPLEMENTATION


START-OF-SELECTION.
  PERFORM action.

*&---------------------------------------------------------------------*
FORM action.

  CALL METHOD lcl_wb=>init                                  "#EC *
*    EXPORTING
*       i_trkorr_list = '<list of supportpacks which delivers the objects anyway. Take from CSS note tab support packages>'
*       i_component   = '<software comp. of objects to be created by this report>'
     EXCEPTIONS
        stop_processing = 1
        OTHERS          = 2.
  IF sy-subrc EQ 0 AND ( genview IS INITIAL OR testrun IS NOT INITIAL ).

    APPEND 'SEPA_MDTENQ_MULT'                       TO gt_tabname.

    "- TABL TABD ----------------------------------------------------------------------------- Tables
    "-- LIMU TABD SEPA_MDTENQ_MULT (language: DE , source: SI3 )
    DATA: lt_dd36  TYPE TABLE OF dd36m, ls_dd36 TYPE dd36m,
          lt_dd05m TYPE TABLE OF dd05m, ls_dd05m TYPE dd05m,
          ls_dd08v TYPE dd08v.

    CALL METHOD lcl_wb=>create_table                        "#EC *
      EXPORTING
        i_tabname    = 'SEPA_MDTENQ_MULT'
        i_devclass   = 'BF_SEPA'
        i_exclass    = '1'
        i_authclass  = '00'
        i_tabclass   = 'TRANSP'
        i_contflag   = 'L'
        i_tabkat     = '0'
        i_tabart     = 'APPL0'
        i_langu      = 'D'
        i_ddtext     = 'SEPA-Mandat: Hilfstabelle fr Mehrfach Enqueue'.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_MDTENQ_MULT'
        i_fieldname = 'MANDT'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'MANDT'
        i_context   = ''.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_MDTENQ_MULT'
        i_fieldname = 'LOCK_TYPE'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'CHAR1'
        i_context   = 'MANDT'.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_MDTENQ_MULT'
        i_fieldname = 'ANWND'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'SEPA_ANWND'
        i_context   = 'LOCK_TYPE'.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_MDTENQ_MULT'
        i_fieldname = 'REC_CRDID'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'SEPA_CRDID'
        i_context   = 'ANWND'.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_MDTENQ_MULT'
        i_fieldname = 'SND_ID_LOW'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'CHAR35'
        i_context   = 'REC_CRDID'.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_MDTENQ_MULT'
        i_fieldname = 'SND_ID_HIGH'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'CHAR35'
        i_context   = 'SND_ID_LOW'.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_MDTENQ_MULT'
        i_fieldname = 'MNDID'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'SEPA_MNDID'
        i_context   = 'SND_ID_HIGH'.

    "- MSAG ------------------------------------------------------------------------- Message Classes
    "-- LIMU MESS SEPA300 (language: DE , source: SI3 )
    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA'
        i_msgno     = '300':
        i_langu     = 'D'
        i_selfdef   = '3'
        i_text      = 'Das Mandat &1/&2 ist von Benutzer &3 gesperrt'.

    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA'
        i_msgno     = '300':
        i_langu     = 'E'
        i_selfdef   = '3'
        i_text      = 'The mandate &1/&2 is locked by user &3'.

    "-- LIMU MESS SEPA301 (language: DE , source: SI3 )
    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA'
        i_msgno     = '301':
        i_langu     = 'D'
        i_selfdef   = '3'
        i_text      = 'Das angeforderte Mandatenintervall ist von Benutzer &1 gesperrt'.

    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA'
        i_msgno     = '301':
        i_langu     = 'E'
        i_selfdef   = '3'
        i_text      = 'The requested interval of mandates is locked by user &1'.

  ENDIF.

  CALL METHOD lcl_wb=>activate.

  CALL METHOD lcl_wb=>display_log.
ENDFORM.                    "action
