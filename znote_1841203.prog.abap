REPORT  znote_1841203.
*PARAMETERS trnlayer TYPE vtcetral-translayer OBLIGATORY.    "ask user for transport layer
* Generated by SAP_LOCAL_DOWNPORT_ASSISTANT Version 3.32 on 13.05.2013

* The individual coding starts at 'FORM action.' ( line 3.206 )

PARAMETERS: testrun  RADIOBUTTON GROUP mode DEFAULT 'X',
            update   RADIOBUTTON GROUP mode,
            showlogs RADIOBUTTON GROUP mode.
DATA: gv_copy_translation.

TYPE-POOLS: seox, seoc, seok, seex, bcwbn, ststc.

TYPES: t_switch_id TYPE char30, "sfw_switch_id does not exist in SAP_BASIS 640
       t_bfunction TYPE char30, "sfw_bfunction does not exist in SAP_BASIS 640
       BEGIN OF t_bf_sw, "sfw_bf_sw
         switch_id TYPE t_switch_id,
         version,
         bfunction TYPE t_bfunction,
         no_check,
       END   OF t_bf_sw,
         BEGIN OF dd43v,typename(30),seckeyname(30),ddlanguage,seckeyunique,accessmode,kind,keydescription(80),END OF dd43v.

TYPES: tt_dd05m  TYPE TABLE OF dd05m,
       tt_dd08v  TYPE TABLE OF dd08v,
       tt_dd17v  TYPE TABLE OF dd17v,
       tt_dd26v  TYPE TABLE OF dd26v,
       tt_dd27p  TYPE TABLE OF dd27p,
       tt_dd28j  TYPE TABLE OF dd28j,
       tt_dd28v  TYPE TABLE OF dd28v,
       tt_dd30v  TYPE TABLE OF dd30v,
       tt_dd30tv TYPE TABLE OF dd30tv,
       tt_dd31v  TYPE TABLE OF dd31v,
       tt_dd32v  TYPE TABLE OF dd32v,
       tt_dd32p  TYPE TABLE OF dd32p,
       tt_dd33v  TYPE TABLE OF dd33v,
       tt_dd36m  TYPE TABLE OF dd36m,
       tt_dd42v  TYPE TABLE OF dd42v,
       tt_dd43v  TYPE TABLE OF dd43v,
       tt_e071k  TYPE TABLE OF e071k,
       tt_langu  TYPE TABLE OF sylangu,
       tt_sta    TYPE TABLE OF rsmpe_stat,
       tt_fun    TYPE TABLE OF rsmpe_funt,
       tt_men    TYPE TABLE OF rsmpe_men,
       tt_mtx    TYPE TABLE OF rsmpe_mnlt,
       tt_act    TYPE TABLE OF rsmpe_act,
       tt_but    TYPE TABLE OF rsmpe_but,
       tt_pfk    TYPE TABLE OF rsmpe_pfk,
       tt_set    TYPE TABLE OF rsmpe_staf,
       tt_doc    TYPE TABLE OF rsmpe_atrt,
       tt_tit    TYPE TABLE OF rsmpe_titt,
       tt_biv    TYPE TABLE OF rsmpe_buts.

DATA: gr_domname                    TYPE RANGE OF domname,
      gr_rollname                   TYPE RANGE OF rollname,
      gr_tabname                    TYPE RANGE OF tabname,
      gt_tabname                    TYPE TABLE OF tabname,
      gr_indexes                    TYPE RANGE OF trobj_name,
      gr_indxtab                    TYPE RANGE OF tabname,
      gr_indxname                   TYPE RANGE OF indexid,
      gr_shlpname                   TYPE RANGE OF shlpname,
      gr_viewname                   TYPE RANGE OF viewname,
      gr_ttypname                   TYPE RANGE OF ttypename,
      gt_ttypname                   TYPE TABLE OF ttypename,
      gr_guistatus                  TYPE RANGE OF progname,
      gr_switchname                 TYPE RANGE OF t_switch_id,
      gr_msg_class                  TYPE RANGE OF msgid,
      gv_trkorr                     TYPE trkorr,
      gv_unit_test,
      gv_translation,
      gv_objects_without_activation,
      gv_log_handle                 TYPE balloghndl.


CONSTANTS: c_bal_object    TYPE balobj_d VALUE 'SNOTE',
           c_bal_subobj    TYPE balsubobj VALUE space,
           c_bal_context   TYPE tabname VALUE 'ADIR_KEY',
           c_include6      TYPE fieldname VALUE '.INCLU', ".INCLUDE or .INCLU--AP or .INCLU-_BY
           c_memory_id(40) VALUE 'SAP_LOCAL_DOWNPORT_ASSISTANT'.

DATA: akb_get_tadir TYPE funcname VALUE 'AKB_GET_TADIR'.

*----------------------------------------------------------------------*
*       CLASS lcl_wb DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_wb DEFINITION.
  PUBLIC SECTION.

    CLASS-METHODS init
       IMPORTING
         i_trkorr_list  TYPE string OPTIONAL   "list of support packages which indicates that report is not needed anymore
         i_component    TYPE dlvunit OPTIONAL  "software component without which report makes no sense
         value(i_note)  TYPE clike OPTIONAL    "note which indicates that report is not needed anymore
         value(i_cinst) TYPE cwbcialeid OPTIONAL "correction instruction which describes the validity of the report
       EXCEPTIONS
         stop_processing.

    CLASS-METHODS get_object_text
      IMPORTING
        i_object   TYPE e071-object    "e.g. TABD
        i_obj_name TYPE c OPTIONAL     "for DOCU
      RETURNING value(r_text) TYPE string.

    CLASS-METHODS get_function_pool_master
      IMPORTING
        i_area  TYPE c
      RETURNING value(r_master) TYPE progdir-name.

    CLASS-METHODS create_package
      IMPORTING
         i_devclass   TYPE devclass
         i_langu      TYPE sylangu DEFAULT 'E'
         i_ctext      TYPE as4text
         i_dlvunit    TYPE dlvunit
         i_parentcl   TYPE packparent         "super package
         i_pdevclass  TYPE tdevc-pdevclass    "transport layer
         i_comp_posid TYPE akhkompo
         i_tpclass    TYPE tpclass
         i_srv_check  TYPE srv_check
      EXCEPTIONS
         package_not_created.

    CLASS-METHODS create_doma
      IMPORTING
        i_domname    TYPE domname
        i_datatype   TYPE dd01v-datatype OPTIONAL
        i_leng       TYPE dd01v-leng OPTIONAL
        i_outputlen  TYPE dd01v-outputlen OPTIONAL
        i_convexit   TYPE dd01v-convexit  OPTIONAL
        i_decimals   TYPE dd01v-decimals  OPTIONAL
        i_lowercase  TYPE dd01v-lowercase OPTIONAL
        i_entitytab  TYPE dd01v-entitytab OPTIONAL
        i_appendname TYPE domname OPTIONAL  "appendname not known in all releases
        i_devclass   TYPE devclass
        i_langu      TYPE sylangu OPTIONAL
        i_ddtext     TYPE ddtext OPTIONAL
        i_domvalue   TYPE dd07v-domvalue_l OPTIONAL
        i_valpos     TYPE dd07v-valpos OPTIONAL
        i_valtext    TYPE dd07v-ddtext OPTIONAL.

    CLASS-METHODS create_dtel
      IMPORTING
        i_rollname  TYPE rollname
        i_domname   TYPE domname
        i_datatype  TYPE dd04v-domname   OPTIONAL  "only needed if domain is initial
        i_decimals  TYPE dd04v-decimals  OPTIONAL  "only needed if rollname is initial
        i_leng      TYPE dd04v-leng      OPTIONAL  "only needed if domain is initial
        i_devclass  TYPE devclass
        i_logflag   TYPE logflag DEFAULT 'X'
        i_memoryid  TYPE dd04v-memoryid OPTIONAL
        i_headlen   TYPE dd04v-headlen OPTIONAL  "defaulted with fieldlen
        i_scrlen1   TYPE dd04v-scrlen1 DEFAULT 10
        i_scrlen2   TYPE dd04v-scrlen2 DEFAULT 15
        i_scrlen3   TYPE dd04v-scrlen3 DEFAULT 20
        i_langu     TYPE sylangu
        i_ddtext    TYPE ddtext
        i_reptext   TYPE reptext OPTIONAL
        i_scrtext_m TYPE scrtext_m
        i_scrtext_l TYPE scrtext_l
        i_scrtext_s TYPE scrtext_s
        i_shlpname  TYPE shlpname OPTIONAL
        i_shlpfield TYPE shlpfield OPTIONAL
        i_deffdname TYPE deffdname OPTIONAL
        i_proxytype TYPE ddproxyty OPTIONAL.

    CLASS-METHODS create_table    "or structure or append or database table
      IMPORTING
        i_tabname    TYPE tabname
        i_devclass   TYPE devclass
        i_exclass    TYPE dd02v-exclass  OPTIONAL
        i_langu      TYPE sylangu   DEFAULT 'E'   "Default EN
        i_ddtext     TYPE ddtext    OPTIONAL      "can be taken from tabname
        i_authclass  TYPE dd02v-authclass DEFAULT '00'
        i_mainflag   TYPE dd02v-mainflag OPTIONAL
        i_tabclass   TYPE tabclass  DEFAULT 'INTTAB'
        i_sqltab     TYPE sqlappdtab OPTIONAL
        i_proxytype  TYPE ddproxyty         OPTIONAL
        i_contflag   TYPE contflag         DEFAULT 'C'     "only needed for db tables
        i_tabkat     TYPE dd09v-tabkat     DEFAULT '0'     "only needed for db tables
        i_tabart     TYPE dd09v-tabart     DEFAULT 'APPL2' "only needed for db tables
        i_bufallow   TYPE dd09v-bufallow   DEFAULT 'N'     "only needed for db tables
        i_pufferung  TYPE dd09v-pufferung  OPTIONAL        "only needed for db tables
        i_schfeldanz TYPE dd09v-schfeldanz OPTIONAL        "only needed for db tables
        i_speichpuff TYPE dd09v-speichpuff OPTIONAL        "only needed for db tables
        i_javaonly   TYPE xfeld OPTIONAL  "dd09v-javaonly  "only needed for db tables   ">=SAPBASIS700
        i_protokoll  TYPE dd09v-protokoll  OPTIONAL.       "only needed for db tables

    CLASS-METHODS add_field_to_table
      IMPORTING
        i_tabname   TYPE tabname
        i_keyflag   TYPE keyflag DEFAULT space
        i_anonymous TYPE xfeld OPTIONAL "dd03p-anonymous
        i_fieldname TYPE fieldname
        i_rollname  TYPE rollname       OPTIONAL  "data element, structure, table_type, include/append name
        i_datatype  TYPE dd03p-datatype OPTIONAL  "only needed if rollname is initial
        i_decimals  TYPE dd03p-decimals OPTIONAL  "only needed if rollname is initial
        i_leng      TYPE dd03p-leng     OPTIONAL  "only needed if rollname is initial
        i_langu     TYPE dd03p-ddlanguage OPTIONAL  "only needed if rollname is initial
        i_ddtext    TYPE dd03p-ddtext   OPTIONAL  "only needed if rollname is initial
        i_reftable  TYPE dd03p-reftable OPTIONAL
        i_reffield  TYPE dd03p-reffield OPTIONAL
        i_notnull   TYPE dd03p-notnull  OPTIONAL
        i_languflag TYPE dd03p-languflag OPTIONAL
        i_groupname TYPE ddgroup        OPTIONAL
        is_dd08v    TYPE dd08v          OPTIONAL   "foreign key relationship
        it_dd05m    TYPE tt_dd05m       OPTIONAL   "foreign key relationship fields
        i_context   TYPE fieldname      OPTIONAL.  "name of previous field or include, blank->append

    CLASS-METHODS create_view
      IMPORTING
        i_viewname   TYPE viewname
        i_devclass   TYPE devclass
        i_langu      TYPE sylangu DEFAULT 'E'   "Default EN
        i_ddtext     TYPE ddtext OPTIONAL      "can be taken from tabname
        i_contflag   TYPE dd25v-customauth DEFAULT 'C'
        i_aggtype    TYPE dd25v-aggtype
        i_roottab    TYPE dd25v-roottab
        i_viewclass  TYPE dd25v-viewclass
        i_viewgrant  TYPE dd25v-viewgrant
        i_readonly   TYPE dd25v-readonly   OPTIONAL
        i_globalflag TYPE dd25v-globalflag OPTIONAL
        it_dd26v     TYPE tt_dd26v    "basis tables
        "it_dd28j    TYPE tt_dd28j    "join conditions
        it_dd28v    TYPE tt_dd28v.   "view conditions

    CLASS-METHODS add_field_to_view
      IMPORTING
        i_viewname  TYPE viewname
        i_viewfield TYPE viewfield OPTIONAL  "omit if same like fieldname
        i_tabname   TYPE tabname
        i_fieldname TYPE fieldname
        i_rollname  TYPE rollname   OPTIONAL  "can be taken from tabfield
        i_rdonly    TYPE vfldroflag OPTIONAL
        i_context   TYPE fieldname  OPTIONAL. "name of previous field or include, blank->append

    CLASS-METHODS regenerate_maint_view                     "SE54
      IMPORTING
        i_viewname  TYPE viewname.

    CLASS-METHODS create_message_class
      IMPORTING
         i_devclass TYPE devclass
         i_msgid    TYPE msgid
         i_langu    TYPE sylangu DEFAULT 'E'   "Default EN
         i_text     TYPE natxt.

    CLASS-METHODS create_message
      IMPORTING
         i_msgid TYPE msgid
         i_msgno TYPE msgno
         i_langu TYPE sylangu DEFAULT 'E'   "Default EN
         i_text  TYPE natxt
         i_selfdef TYPE doku_selfd DEFAULT 'X'.

    CLASS-METHODS create_transaction
      IMPORTING
        i_tcode    TYPE tstc-tcode
        i_devclass TYPE devclass OPTIONAL
        i_langu    TYPE sylangu DEFAULT 'E'
        i_text     TYPE tstct-ttext    OPTIONAL
        i_type     LIKE ststc_c_type_dialog DEFAULT 'D'
        i_program  TYPE tstc-pgmna     OPTIONAL "only for report transaction
        i_dynpro   TYPE sydynnr        OPTIONAL "tstc-dypno
        i_javagui  TYPE tstcc-s_platin DEFAULT 'X'
        i_htmlgui  TYPE tstcc-s_webgui DEFAULT 'X'
        i_wingui   TYPE tstcc-s_win32  DEFAULT 'X'
        i_called_transaction TYPE  tstc-tcode OPTIONAL
        i_called_transaction_skip TYPE  char01 OPTIONAL
        i_param TYPE s_param OPTIONAL.

    CLASS-METHODS create_dtel_docu
      IMPORTING
         i_rollname  TYPE rollname
         i_langu     TYPE sylangu DEFAULT 'E'   "Default EN
         i_line      TYPE string OPTIONAL "all lines get collected until i_line is omitted
       EXPORTING
         et_lines    TYPE tline_tab.

    CLASS-METHODS create_mess_docu
      IMPORTING
         i_msgid     TYPE msgid
         i_msgno     TYPE msgno
         i_langu     TYPE sylangu DEFAULT 'E'   "Default EN
         i_line      TYPE string OPTIONAL  "all lines get collected until i_line is omitted
       EXPORTING
         et_lines    TYPE tline_tab.

    CLASS-METHODS create_function_group
       IMPORTING
          i_area     TYPE tlibg-area
          i_devclass TYPE devclass
          i_langu    TYPE sylangu DEFAULT 'E'
          i_text     TYPE tlibt-areat OPTIONAL
          i_appl     TYPE trdir-appl    OPTIONAL
          i_fixpt    TYPE trdir-fixpt   DEFAULT 'X'
          i_uccheck  TYPE trdir-uccheck DEFAULT 'X'.

    CLASS-METHODS add_to_transport
      IMPORTING i_object   TYPE e071-object    "TABD
                i_obj_name TYPE c     "flexible number of characters
                i_devclass TYPE devclass OPTIONAL
                i_langu    TYPE sylangu OPTIONAL
      EXCEPTIONS
                error
                simulation.

    CLASS-METHODS register_inactive_object
        IMPORTING
           i_objtype  TYPE e071-object
           i_treetype TYPE e071-object OPTIONAL  "space = do not update tree, optionally different type in tree, e.g. TABL vs. CDS
           i_objname TYPE c.

    CLASS-METHODS log_message.

    CLASS-METHODS display_log.

    CLASS-METHODS set_context
      IMPORTING i_object    TYPE e071-object
                i_obj_name  TYPE c
                i_obj_name2 TYPE c OPTIONAL
                i_text      TYPE c OPTIONAL
                i_langu     TYPE sylangu.

    CLASS-METHODS support_pack_applied
      IMPORTING i_trkorr_list TYPE string
      RETURNING value(r_applied) TYPE xfeld.

    CLASS-METHODS software_comp_applied
      IMPORTING i_component TYPE dlvunit
      EXPORTING e_cvers TYPE cvers
      EXCEPTIONS not_applied.

    CLASS-METHODS activate
      IMPORTING i_result_auth_check TYPE sysubrc OPTIONAL.

ENDCLASS.                    "lcl_wb DEFINITION
*----------------------------------------------------------------------*
*       CLASS lcl_dcm_to_po_bridge IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcl_wb IMPLEMENTATION.

  METHOD init.

    CALL FUNCTION 'AUTHORITY_CHECK_TCODE'
      EXPORTING
        tcode  = 'SNOTE'
      EXCEPTIONS
        ok     = 0
        OTHERS = 1.
    IF sy-subrc NE 0.
      MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      RAISE stop_processing.
    ENDIF.

    IF showlogs IS NOT INITIAL.
      CALL METHOD display_log.
      LEAVE PROGRAM.
    ENDIF.

    DATA: ls_log TYPE bal_s_log.
    "prepare application log
    ls_log-object    = c_bal_object.
    ls_log-subobject = c_bal_subobj.
    ls_log-extnumber = sy-repid.
    ls_log-aldate    = sy-datum.
    ls_log-altime    = sy-uzeit.
    ls_log-aluser    = sy-uname.
    ls_log-alprog    = sy-repid.
    ls_log-altcode   = sy-tcode.
    "create standard application log handle
    CALL FUNCTION 'BAL_LOG_CREATE'
      EXPORTING
        i_s_log                 = ls_log
      IMPORTING
        e_log_handle            = gv_log_handle
      EXCEPTIONS
        log_header_inconsistent = 1
        OTHERS                  = 2.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    EXPORT gv_log_handle FROM gv_log_handle TO MEMORY ID c_memory_id.

    CALL METHOD set_context
      EXPORTING
        i_langu    = space
        i_object   = space
        i_obj_name = space.

    "check software component and SP level
    DATA: ls_cvers    TYPE cvers,
          l_applied   TYPE xfeld,
          l_line(255).
    IF i_component IS SUPPLIED.
      CALL METHOD software_comp_applied                     "#EC *
        EXPORTING
          i_component = i_component
        IMPORTING
          e_cvers     = ls_cvers
        EXCEPTIONS
          not_applied = 1
          OTHERS      = 2.
      IF sy-subrc IS NOT INITIAL.
        MESSAGE e666(01) WITH 'Software Component' i_component 'not installed! Execution stopped!' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        CALL METHOD display_log.
        RAISE stop_processing.
      ELSE.
        "further check if possible
        IF i_trkorr_list IS SUPPLIED.
          CALL METHOD support_pack_applied
            EXPORTING
              i_trkorr_list = i_trkorr_list
            RECEIVING
              r_applied     = l_applied.
          IF l_applied EQ 'X'.
            CONCATENATE i_component '/' ls_cvers-extrelease INTO l_line.
            MESSAGE e666(01) WITH 'The system contains software component/support pack level' l_line
                                  '. Report execution not required anymore.' INTO sy-lisel. "#EC *
            CALL METHOD log_message.
            CALL METHOD display_log.
            RAISE stop_processing.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF. " i_component IS SUPPLIED.

    IF i_note IS NOT INITIAL.
*     that that note is not already implemented
*     this must not be the note containing the generated report for DDIC but a follow-up note with the coding using that new DDIC
      DATA l_status TYPE c.
      CALL FUNCTION 'SCWB_NOTE_IMPL_STATUS_SIMPLE'
        EXPORTING
          iv_numm   = i_note
        IMPORTING
          ev_status = l_status
        EXCEPTIONS
          OTHERS    = 1.
      CASE l_status.
        WHEN 'E'.
          MESSAGE e666(01) WITH 'SAP Note' i_note 'completely implemented;' 'Report execution not required anymore.' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
          CALL METHOD display_log.
          RAISE stop_processing.
        WHEN 'O'.
          MESSAGE e666(01) WITH 'SAP Note' i_note 'is obsolete;' 'Report execution not required anymore.' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
          CALL METHOD display_log.
          RAISE stop_processing.
        WHEN OTHERS. "okay
          DATA: ls_note TYPE  bcwbn_note.
          ls_note-key-numm = i_note.
          CALL FUNCTION 'SCWB_NOTE_READ'
            EXPORTING
              iv_read_corr_instructions  = 'X'
            CHANGING
              cs_note                    = ls_note
            EXCEPTIONS
              note_not_found             = 1
              language_not_found         = 2
              unreadable_text_format     = 3
              corr_instruction_not_found = 4
              OTHERS                     = 5.
          IF sy-subrc <> 0.
            MESSAGE e666(01) WITH 'SAP Note' i_note 'cannot be read;' 'Ensure correct download of note first.' INTO sy-lisel. "#EC *
            CALL METHOD log_message.
            CALL METHOD display_log.
            RAISE stop_processing.
          ENDIF.
*------
          FIELD-SYMBOLS: <ls_corr> TYPE bcwbn_corr_instruction.
          DATA: l_valid TYPE bcwbn_bool.
          LOOP AT ls_note-corr_instructions ASSIGNING <ls_corr>.
            IF i_cinst IS NOT INITIAL.
              CHECK <ls_corr>-key-aleid = i_cinst.
            ENDIF.
            CALL FUNCTION 'SCWB_CINST_CHECK_VALID'
              IMPORTING
                ev_valid                   = l_valid
              CHANGING
                cs_corr_instruction        = <ls_corr>
              EXCEPTIONS
                corr_inst_not_found        = 1
                inconsistent_delivery_data = 2
                undefined                  = 3
                OTHERS                     = 4.
            IF sy-subrc <> 0.
              MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            ENDIF.
            IF l_valid IS NOT INITIAL.
              EXIT.
            ENDIF.
          ENDLOOP.
          IF l_valid IS INITIAL.
            MESSAGE e666(01) WITH 'Manual changes cannot be applied;' 'Correction instruction invalid' 'for current patch level' INTO sy-lisel. "#EC *                 "#EC *
            CALL METHOD log_message.
            CALL METHOD display_log.
            RAISE stop_processing.
          ENDIF.
      ENDCASE.
    ENDIF.

    CALL FUNCTION 'SCWG_TOOLFLAG_SET'. "Reset will happen at leave of program

    IF testrun IS INITIAL.
      MESSAGE i666(01) WITH 'Running in Update Mode' INTO sy-lisel. "#EC *
    ELSE.
      MESSAGE i666(01) WITH 'Running in Test Mode' INTO sy-lisel. "#EC *
    ENDIF.
    CALL METHOD log_message.

  ENDMETHOD.                    "init

  METHOD get_object_text.

    STATICS: lt_object_text TYPE TABLE OF ko100,
             lt_doktypes    TYPE TABLE OF dd07v.

    DATA: ls_object_text TYPE ko100,
          ls_doktype     TYPE dd07v.

    IF lt_object_text IS INITIAL.
      CALL FUNCTION 'TR_OBJECT_TABLE'
        TABLES
          wt_object_text = lt_object_text.
      SORT lt_object_text BY object.

      CALL FUNCTION 'DDIF_DOMA_GET'
        EXPORTING
          name      = 'DOK_ID'
          langu     = sy-langu
        TABLES
          dd07v_tab = lt_doktypes
        EXCEPTIONS
          OTHERS    = 0.
      SORT lt_doktypes BY domvalue_l.
    ENDIF.

    IF i_object EQ 'DOCU'.
      READ TABLE lt_doktypes INTO ls_doktype BINARY SEARCH
        WITH KEY domvalue_l = i_obj_name(2).
      IF sy-subrc EQ 0.
        CONCATENATE 'Documentation' ls_doktype-ddtext INTO r_text SEPARATED BY space. "#EC NOTEXT
      ELSE.
        r_text = 'Documentation'.                           "#EC NOTEXT
      ENDIF.
    ELSEIF i_object IS NOT INITIAL.
      READ TABLE lt_object_text INTO ls_object_text BINARY SEARCH
        WITH KEY object = i_object.  "ignore PGMID!
      IF sy-subrc EQ 0.
        r_text = ls_object_text-text.
      ENDIF.
    ENDIF.

  ENDMETHOD.                    "get_object_text


  METHOD get_function_pool_master.
    "/SAPAPO/ABC  => /SAPAPO/SAPLABC
    "XYZ1         => SAPLXYZ1
    r_master = i_area.
    REPLACE '/' WITH '/SAPL' INTO r_master+1.
    IF sy-subrc NE 0.
      CONCATENATE 'SAPL' r_master INTO r_master.
    ENDIF.

  ENDMETHOD.                    "get_docu_object

  METHOD create_package.

    DATA: lo_package      TYPE REF TO if_package,
          ls_package_data TYPE scompkdtln.

    CALL METHOD set_context
      EXPORTING
        i_langu    = i_langu
        i_object   = 'DEVC'
        i_obj_name = i_devclass.

    SELECT SINGLE * FROM tdevc INTO CORRESPONDING FIELDS OF ls_package_data
                   WHERE devclass EQ i_devclass.
    IF sy-subrc EQ 0 AND
*       ls_package_data-ctext      EQ i_ctext      AND "ctext in TDEVC leer!
       ls_package_data-dlvunit    EQ i_dlvunit    AND
       ls_package_data-parentcl   EQ i_parentcl   AND
*       ls_package_data-comp_posid EQ i_comp_posid AND "COMP_POSID kommt nicht in TDEVC vor!
       ls_package_data-tpclass    EQ i_tpclass    AND
       ls_package_data-srv_check  EQ i_srv_check.
      MESSAGE i666(01) WITH 'No update necessary' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    CHECK testrun IS INITIAL.

    ls_package_data-devclass   = i_devclass.
    ls_package_data-ctext      = i_ctext.
    ls_package_data-masterlang = i_langu.
    ls_package_data-dlvunit    = i_dlvunit.
    ls_package_data-parentcl   = i_parentcl.
    ls_package_data-comp_posid = i_comp_posid.
    ls_package_data-pdevclass  = i_pdevclass.
    ls_package_data-tpclass    = i_tpclass.
    ls_package_data-srv_check  = i_srv_check.
    ls_package_data-as4user    = sy-uname.

    CALL METHOD cl_package=>create_new_package
      IMPORTING
        e_package                  = lo_package
      CHANGING
        c_package_data             = ls_package_data
      EXCEPTIONS
        object_already_existing    = 1
        object_just_created        = 2
        not_authorized             = 3
        wrong_name_prefix          = 4
        undefined_name             = 5
        reserved_local_name        = 6
        invalid_package_name       = 7
        short_text_missing         = 8
        software_component_invalid = 9
        layer_invalid              = 10
        author_not_existing        = 11
        component_not_existing     = 12
        component_missing          = 13
        prefix_in_use              = 14
        unexpected_error           = 15
        intern_err                 = 16
        OTHERS                     = 17.
    IF sy-subrc EQ 1.  "already exists
      RETURN.
    ELSEIF sy-subrc NE 0.
      CALL METHOD log_message.
      CALL METHOD display_log.
      RAISE package_not_created.
    ENDIF.

    "save package
    CALL METHOD lo_package->save
      IMPORTING
        e_transport_request   = gv_trkorr
      EXCEPTIONS
        object_invalid        = 1
        object_not_changeable = 2
        cancelled_in_corr     = 3
        permission_failure    = 4
        unexpected_error      = 5
        intern_err            = 6.

    IF sy-subrc NE 0.
      CALL METHOD log_message.
      CALL METHOD display_log.
      RAISE package_not_created.
    ENDIF.

    MESSAGE i666(01) WITH 'Update successful' INTO sy-lisel. "#EC *
    CALL METHOD log_message.

  ENDMETHOD.                    "create_package


  METHOD create_doma.
    DATA: ls_dd01v   TYPE dd01v,
          lt_dd07v   TYPE TABLE OF dd07v,
          ls_dd07v   TYPE dd07v,
          l_update,
          ls_domname LIKE LINE OF gr_domname VALUE 'IEQ'.

    FIELD-SYMBOLS: <l_appendname> TYPE c,
                   <ls_dd07v>     LIKE LINE OF lt_dd07v.

    CALL METHOD set_context
      EXPORTING
        i_langu    = i_langu
        i_object   = 'DOMA'
        i_obj_name = i_domname.

    ls_domname-low = i_domname.
    COLLECT ls_domname INTO gr_domname.

    CALL FUNCTION 'DDIF_DOMA_GET'
      EXPORTING
        name      = i_domname
        langu     = i_langu      "reads all values, returns value without language/text if text does not exist in i_langu
        state     = 'M'  "newest version (e.g. inactive)
      IMPORTING
        dd01v_wa  = ls_dd01v
      TABLES
        dd07v_tab = lt_dd07v
      EXCEPTIONS
        OTHERS    = 0.

    IF ls_dd01v IS INITIAL OR
       ls_dd01v-ddtext    NE i_ddtext    OR
       ls_dd01v-domname   NE i_domname   OR
       ls_dd01v-datatype  NE i_datatype  OR
       ls_dd01v-leng      NE i_leng      OR
       i_outputlen NE 0 AND i_outputlen NE ls_dd01v-outputlen OR
       i_outputlen EQ 0 AND i_leng      NE ls_dd01v-outputlen OR
       ls_dd01v-convexit  NE i_convexit  OR
       ls_dd01v-decimals  NE i_decimals  OR
       ls_dd01v-lowercase NE i_lowercase OR
       ls_dd01v-entitytab NE i_entitytab.
      l_update = 'X'.
    ENDIF.

    IF gv_copy_translation IS INITIAL.
      ls_dd01v-domname  = i_domname.
      ls_dd01v-datatype = i_datatype.
      ls_dd01v-leng     = i_leng.
      IF i_outputlen IS INITIAL.
        ls_dd01v-outputlen = i_leng.
      ELSE.
        ls_dd01v-outputlen = i_outputlen.
      ENDIF.
      ls_dd01v-convexit    = i_convexit.
      ASSIGN ('LS_DD01V-APPENDNAME') TO <l_appendname>.
      IF sy-subrc EQ 0.
        <l_appendname>  = i_appendname.
      ENDIF.
    ENDIF.

    ls_dd01v-ddlanguage = i_langu.
    ls_dd01v-ddtext     = i_ddtext.
    ls_dd01v-domname    = i_domname.
    ls_dd01v-datatype   = i_datatype.
    ls_dd01v-leng       = i_leng.
    ls_dd01v-outputlen  = i_outputlen.
    ls_dd01v-convexit   = i_convexit.
    ls_dd01v-decimals   = i_decimals.
    ls_dd01v-lowercase  = i_lowercase.
    ls_dd01v-entitytab  = i_entitytab.

    IF i_domvalue IS SUPPLIED.   "INITIAL value shall be possible fix value
      READ TABLE lt_dd07v ASSIGNING <ls_dd07v> WITH KEY domvalue_l = i_domvalue.
      IF sy-subrc EQ 0.
        "value exists -> compare text
        IF <ls_dd07v>-ddtext NE i_valtext.
          <ls_dd07v>-ddlanguage = i_langu.
          <ls_dd07v>-ddtext     = i_valtext.
          l_update              = 'X'.
        ENDIF.
      ELSEIF gv_copy_translation IS INITIAL.
        "value does not exist -> insert
        READ TABLE lt_dd07v TRANSPORTING NO FIELDS WITH KEY valpos = i_valpos.
        IF sy-subrc EQ 0.
          "insert new value and increase valpos of exiting entries
          LOOP AT lt_dd07v ASSIGNING <ls_dd07v> WHERE valpos GE i_valpos.
            ADD 1 TO <ls_dd07v>-valpos.
          ENDLOOP.
        ENDIF.
        CLEAR ls_dd07v.
        ls_dd07v-domname    = i_domname.
        ls_dd07v-domvalue_l = i_domvalue.
        IF i_valpos IS INITIAL.
          DESCRIBE TABLE lt_dd07v.
          ls_dd07v-valpos = sy-tfill + 1.
        ELSE.
          ls_dd07v-valpos     = i_valpos.
        ENDIF.
        ls_dd07v-ddlanguage = i_langu.
        ls_dd07v-ddtext     = i_valtext.
        APPEND ls_dd07v TO lt_dd07v.
        SORT lt_dd07v BY valpos.
        l_update = 'X'.
      ENDIF.
      IF lt_dd07v[] IS NOT INITIAL.
        ls_dd01v-valexi = 'X'.
      ENDIF.
    ENDIF.

    IF l_update IS INITIAL.
      IF i_domvalue IS SUPPLIED.
        MESSAGE i666(01) WITH 'No update necessary for fix value' i_domvalue INTO sy-lisel. "#EC *
        CALL METHOD log_message.
      ELSE.
        MESSAGE i666(01) WITH 'No update necessary' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
      ENDIF.
      RETURN.
    ENDIF.

    CHECK testrun IS INITIAL.

    IF gv_copy_translation IS INITIAL.
      CALL METHOD add_to_transport
        EXPORTING
          i_object   = 'DOMA'
          i_obj_name = i_domname
          i_devclass = i_devclass
          i_langu    = i_langu
        EXCEPTIONS
          OTHERS     = 1.
      CHECK sy-subrc EQ 0.
    ENDIF.

    "align redundant field DOMMASTER with TADIR-MASTERLANG
    SELECT SINGLE masterlang FROM tadir INTO ls_dd01v-dommaster
                            WHERE pgmid    EQ 'R3TR'
                              AND object   EQ 'DOMA'
                              AND obj_name EQ i_domname.

    CALL FUNCTION 'DDIF_DOMA_PUT'
      EXPORTING
        name              = i_domname
        dd01v_wa          = ls_dd01v
      TABLES
        dd07v_tab         = lt_dd07v
      EXCEPTIONS
        doma_not_found    = 1
        name_inconsistent = 2
        doma_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.

    IF sy-subrc <> 0.
      MESSAGE e108(do) WITH i_domname INTO sy-lisel.        "#EC *
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    MESSAGE i666(01) WITH 'Update successful' INTO sy-lisel. "#EC *
    CALL METHOD log_message.

    CALL METHOD register_inactive_object
      EXPORTING
        i_objtype = 'DOMA'
        i_objname = i_domname.

  ENDMETHOD.                    "create_doma

  METHOD create_dtel.
    DATA: ls_dd04v    TYPE dd04v,
          l_gotstate,
          ls_rollname LIKE LINE OF gr_domname VALUE 'IEQ'.

    CALL METHOD set_context
      EXPORTING
        i_langu    = i_langu
        i_object   = 'DTEL'
        i_obj_name = i_rollname.

    ls_rollname-low = i_rollname.
    COLLECT ls_rollname INTO gr_rollname.

    CALL FUNCTION 'DDIF_DTEL_GET'
      EXPORTING
        name     = i_rollname
        langu    = i_langu
        state    = 'M'  "newest version (e.g. inactive)
      IMPORTING
        dd04v_wa = ls_dd04v
        gotstate = l_gotstate
      EXCEPTIONS
        OTHERS   = 1.
    IF sy-subrc EQ 0 AND
      ls_dd04v-rollname    = i_rollname   AND
      ls_dd04v-logflag     = i_logflag    AND
      ls_dd04v-memoryid    = i_memoryid   AND
      ls_dd04v-ddlanguage  = i_langu      AND
      ls_dd04v-ddtext      = i_ddtext     AND
      ls_dd04v-reptext     = i_reptext    AND
      ls_dd04v-shlpname    = i_shlpname   AND
      ls_dd04v-shlpfield   = i_shlpfield  AND
      ls_dd04v-deffdname   = i_deffdname  AND
      ls_dd04v-proxytype   = i_proxytype  AND
    ( ls_dd04v-domname     = i_domname OR i_domname IS INITIAL AND
                                          ls_dd04v-datatype = i_datatype AND
                                          ls_dd04v-decimals = i_decimals AND
                                          ls_dd04v-leng     = i_leng ).
      "data element already exists with that properties
      MESSAGE i666(01) WITH 'No update necessary' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    "check whether domain exists
    IF i_domname IS NOT INITIAL.
      READ TABLE gr_domname TRANSPORTING NO FIELDS WITH KEY low = i_domname.
      IF sy-subrc NE 0.
        SELECT COUNT(*) FROM dd01l WHERE domname EQ i_domname.
      ENDIF.
      IF sy-subrc NE 0.
        MESSAGE e666(01) WITH 'Domain' i_domname 'does not exist' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        RETURN.
      ENDIF.
    ENDIF.

    CHECK testrun IS INITIAL.

    ls_dd04v-ddlanguage = i_langu.
    ls_dd04v-ddtext     = i_ddtext.
    ls_dd04v-scrtext_s  = i_scrtext_s.
    ls_dd04v-scrlen1    = i_scrlen1.
    ls_dd04v-scrtext_m  = i_scrtext_m.
    ls_dd04v-scrlen2    = i_scrlen2.
    ls_dd04v-scrtext_l  = i_scrtext_l.
    ls_dd04v-scrlen3    = i_scrlen3.
    IF i_reptext IS NOT INITIAL.
      ls_dd04v-reptext = i_reptext.
      IF i_headlen IS INITIAL.
        ls_dd04v-headlen = strlen( i_reptext ).
      ELSE.
        ls_dd04v-headlen = i_headlen.
      ENDIF.
    ENDIF.

    IF gv_copy_translation IS INITIAL.
      ls_dd04v-rollname = i_rollname.
      ls_dd04v-domname  = i_domname.
      IF ls_dd04v-domname IS INITIAL.
        ls_dd04v-datatype = i_datatype.
        ls_dd04v-decimals = i_decimals.
        ls_dd04v-leng     = i_leng.
      ENDIF.
      ls_dd04v-shlpname  = i_shlpname.
      ls_dd04v-shlpfield = i_shlpfield.
      ls_dd04v-deffdname = i_deffdname.
      ls_dd04v-logflag   = i_logflag.
      ls_dd04v-memoryid  = i_memoryid.
      ls_dd04v-proxytype = i_proxytype.

      CALL METHOD add_to_transport
        EXPORTING
          i_object   = 'DTEL'
          i_obj_name = i_rollname
          i_devclass = i_devclass
          i_langu    = i_langu  "masterlanguage (only relevant during first call)
        EXCEPTIONS
          OTHERS     = 1.
      CHECK sy-subrc EQ 0.
    ENDIF.

    "align redundant field DTELMASTER with TADIR-MASTERLANG
    SELECT SINGLE masterlang FROM tadir INTO ls_dd04v-dtelmaster
                            WHERE pgmid    EQ 'R3TR'
                              AND object   EQ 'DTEL'
                              AND obj_name EQ i_rollname.

    IF i_langu EQ ls_dd04v-dtelmaster OR gv_copy_translation IS INITIAL.
      CALL FUNCTION 'DDIF_DTEL_PUT'
        EXPORTING
          name              = i_rollname
          dd04v_wa          = ls_dd04v
        EXCEPTIONS
          dtel_not_found    = 1
          name_inconsistent = 2
          dtel_inconsistent = 3
          put_failure       = 4
          put_refused       = 5
          OTHERS            = 6.

      IF sy-subrc NE 0.
        CALL METHOD log_message.
        RETURN.
      ELSE.
        MESSAGE i666(01) WITH 'Update successful' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
      ENDIF.

      CALL METHOD register_inactive_object
        EXPORTING
          i_objtype = 'DTEL'
          i_objname = i_rollname.

    ELSE.
      DATA: ls_dd04l TYPE dd04l,
            ls_dd04t TYPE dd04t,
            lt_dd04t TYPE TABLE OF dd04t.
      MOVE-CORRESPONDING ls_dd04v TO: ls_dd04l, ls_dd04t.
      APPEND ls_dd04t TO lt_dd04t.
      TRANSLATE l_gotstate USING 'MN'.
      CALL FUNCTION 'DD_DTEL_PUT'
        EXPORTING
          dd04l_wa            = ls_dd04l
          prid                = -2  "no_log
          put_state           = l_gotstate
          rollname            = ls_dd04v-rollname
        TABLES
          dd04t_tab           = lt_dd04t
        EXCEPTIONS
          object_inconsistent = 1
          OTHERS              = 2.
    ENDIF.

  ENDMETHOD.                    "create_dtel




  METHOD create_table.
    DATA: ls_dd02v     TYPE dd02v,
          ls_dd09l     TYPE dd09l,
          lt_dd03p     TYPE TABLE OF dd03p,
          lt_dd05m     TYPE TABLE OF dd05m,
          lt_dd08v     TYPE TABLE OF dd08v,
          lt_dd12v     TYPE TABLE OF dd12v,
          lt_dd17v     TYPE TABLE OF dd17v,
          lt_dd35v     TYPE TABLE OF dd35v,
          lt_dd36m     TYPE TABLE OF dd36m,
          l_tabix      TYPE sytabix,
          l_treetype   TYPE trobjtype,
          ls_dwinactiv TYPE dwinactiv,
          ls_tabname   LIKE LINE OF gr_tabname VALUE 'IEQ'.

    FIELD-SYMBOLS: <ls_dd03p>          TYPE dd03p,
                   <ls_dd09l_javaonly> TYPE char1.

    CALL METHOD set_context
      EXPORTING
        i_langu    = i_langu
        i_object   = 'TABD'
        i_obj_name = i_tabname.

    ls_tabname-low = i_tabname.
    COLLECT ls_tabname INTO gr_tabname.

    ASSIGN ('LS_DD09L-JAVAONLY') TO <ls_dd09l_javaonly>.                ">=SAPBASIS700

    CALL FUNCTION 'DDIF_TABL_GET'
      EXPORTING
        name          = i_tabname
        state         = 'M'  "newest version (e.g. inactive)
        langu         = i_langu
      IMPORTING
*       GOTSTATE      = GOTSTATE
        dd02v_wa      = ls_dd02v
        dd09l_wa      = ls_dd09l
      TABLES
        dd03p_tab     = lt_dd03p
        dd05m_tab     = lt_dd05m
        dd08v_tab     = lt_dd08v
        dd12v_tab     = lt_dd12v
        dd17v_tab     = lt_dd17v
        dd35v_tab     = lt_dd35v
        dd36m_tab     = lt_dd36m
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    IF sy-subrc           EQ 0           AND
       ls_dd02v-tabname   IS NOT INITIAL AND "existing.
       ls_dd02v-ddtext    EQ i_ddtext    AND
       ls_dd02v-exclass   EQ i_exclass   AND
       ls_dd02v-tabclass  EQ i_tabclass  AND
       ls_dd02v-authclass EQ i_authclass AND
       ls_dd02v-mainflag  EQ i_mainflag  AND
       ls_dd02v-proxytype EQ i_proxytype AND
       ls_dd02v-sqltab    EQ i_sqltab.

      IF ( ls_dd02v-tabclass   EQ 'INTTAB' ) OR
         ( ls_dd02v-contflag   EQ i_contflag   AND
           ls_dd09l-tabkat     EQ i_tabkat     AND
           ls_dd09l-tabart     EQ i_tabart     AND
           ls_dd09l-pufferung  EQ i_pufferung  AND
           ls_dd09l-bufallow   EQ i_bufallow   AND
           ls_dd09l-schfeldanz EQ i_schfeldanz AND
           ls_dd09l-protokoll  EQ i_protokoll  AND
           "ls_dd09l-javaonly   EQ i_javaonly   AND     ">=SAPBASIS700
           ls_dd09l-speichpuff EQ i_speichpuff ).   "do not check javaonly field
        MESSAGE i666(01) WITH 'No update necessary' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        RETURN.
      ENDIF.

    ENDIF.

    CHECK testrun IS INITIAL.

    "new table
    ls_dd02v-tabname    = i_tabname.
    ls_dd02v-ddlanguage = i_langu.
    ls_dd02v-exclass    = i_exclass.
    ls_dd02v-tabclass   = i_tabclass.
    ls_dd02v-authclass  = i_authclass.
    ls_dd02v-mainflag   = i_mainflag.
    ls_dd02v-proxytype  = i_proxytype.
    ls_dd02v-sqltab     = i_sqltab.

    IF i_ddtext IS INITIAL.
      ls_dd02v-ddtext   = i_tabname.
    ELSE.
      ls_dd02v-ddtext   = i_ddtext.
    ENDIF.

    IF ls_dd02v-tabclass EQ 'CLUSTER' OR  "only for real database tables
       ls_dd02v-tabclass EQ 'POOL'    OR
       ls_dd02v-tabclass EQ 'TRANSP'.
      ls_dd02v-contflag   = i_contflag.
      ls_dd09l-tabname    = i_tabname.
      ls_dd09l-tabkat     = i_tabkat.
      ls_dd09l-tabart     = i_tabart.
      ls_dd09l-pufferung  = i_pufferung.
      ls_dd09l-bufallow   = i_bufallow.
      ls_dd09l-schfeldanz = i_schfeldanz.
      ls_dd09l-protokoll  = i_protokoll.
      ls_dd09l-speichpuff = i_speichpuff.
      IF <ls_dd09l_javaonly> IS ASSIGNED.         ">=SAPBASIS700
        <ls_dd09l_javaonly> = i_javaonly.         ">=SAPBASIS700
      ENDIF.                                      ">=SAPBASIS700
      l_treetype = 'TABL'.
    ELSE.
      l_treetype = 'CDS'.
    ENDIF.

    CALL METHOD add_to_transport
      EXPORTING
        i_object   = 'TABL'
        i_langu    = i_langu
        i_obj_name = i_tabname
        i_devclass = i_devclass
      EXCEPTIONS
        OTHERS     = 1.
    CHECK sy-subrc EQ 0.

    CALL FUNCTION 'DDIF_TABL_PUT'
      EXPORTING
        name              = i_tabname
        dd02v_wa          = ls_dd02v
        dd09l_wa          = ls_dd09l
      TABLES
        dd03p_tab         = lt_dd03p
        dd05m_tab         = lt_dd05m
        dd08v_tab         = lt_dd08v
        dd35v_tab         = lt_dd35v
        dd36m_tab         = lt_dd36m
      EXCEPTIONS
        tabl_not_found    = 1
        name_inconsistent = 2
        tabl_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc <> 0.
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    MESSAGE i666(01) WITH 'Update successful' INTO sy-lisel. "#EC *
    CALL METHOD log_message.

    CALL METHOD register_inactive_object
      EXPORTING
        i_objtype  = 'TABL'
        i_treetype = l_treetype
        i_objname  = i_tabname.


  ENDMETHOD.                    "create_table

  METHOD add_field_to_table.

    DATA: ls_dd02v             TYPE dd02v,
          ls_dd09l             TYPE dd09l,
          lt_dd03p             TYPE TABLE OF dd03p,
          ls_dd05m             TYPE dd05m,
          lt_dd05m             TYPE TABLE OF dd05m,
          ls_dd08v             TYPE dd08v,
          lt_dd08v             TYPE TABLE OF dd08v,
          lt_dd12v             TYPE TABLE OF dd12v,
          lt_dd17v             TYPE TABLE OF dd17v,
          lt_dd35v             TYPE TABLE OF dd35v,
          lt_dd36m             TYPE TABLE OF dd36m,
          lt_dd32p             TYPE tt_dd32p,
          ls_dd32p             TYPE dd32p,
          l_tabix              TYPE sytabix,
          lt_checktable_fields TYPE TABLE OF dd03p,
          ls_checktable_field  TYPE dd03p,
          ls_tabname           LIKE LINE OF gr_tabname VALUE 'IEQ'.

    FIELD-SYMBOLS: <ls_dd03p> TYPE dd03p.

    CALL METHOD set_context
      EXPORTING
        i_langu    = space
        i_text     = 'Add field(s) to table'                "#EC NOTEXT
        i_object   = 'TABD'
        i_obj_name = i_tabname.

    ls_tabname-low = i_tabname.
    COLLECT ls_tabname INTO gr_tabname.

    CALL FUNCTION 'DDIF_TABL_GET'
      EXPORTING
        name          = i_tabname
        state         = 'M'  "newest version (e.g. inactive)
      IMPORTING
*       GOTSTATE      = GOTSTATE
        dd02v_wa      = ls_dd02v
        dd09l_wa      = ls_dd09l
      TABLES
        dd03p_tab     = lt_dd03p
        dd05m_tab     = lt_dd05m
        dd08v_tab     = lt_dd08v
        dd12v_tab     = lt_dd12v
        dd17v_tab     = lt_dd17v
        dd35v_tab     = lt_dd35v
        dd36m_tab     = lt_dd36m
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.

    IF sy-subrc NE 0 OR ls_dd02v-tabname IS INITIAL.  "not existing.
      IF testrun IS INITIAL OR i_tabname NOT IN gr_tabname.
        MESSAGE e666(01) WITH 'Error while reading table' i_tabname INTO sy-lisel. "#EC *
        CALL METHOD log_message.
      ENDIF.
      RETURN.
    ENDIF.

    "check whether data element respectivly included/appended/referenced structure exists
    IF i_rollname IS NOT INITIAL.
      READ TABLE gr_rollname TRANSPORTING NO FIELDS WITH KEY low = i_rollname.  "new data element
      IF sy-subrc NE 0.
        READ TABLE gt_tabname TRANSPORTING NO FIELDS WITH KEY table_line = i_rollname.  "new structure
      ENDIF.
      IF sy-subrc NE 0.
        READ TABLE gt_ttypname TRANSPORTING NO FIELDS WITH KEY table_line = i_rollname.  "new table type
      ENDIF.
      IF sy-subrc NE 0.
        SELECT SINGLE rollname FROM dd04l INTO sy-lisel WHERE rollname EQ i_rollname.  "existing data element
      ENDIF.
      IF sy-subrc NE 0.
        SELECT SINGLE tabname FROM dd03l INTO sy-lisel WHERE tabname EQ i_rollname.  "existing structure
      ENDIF.
      IF sy-subrc NE 0.
        SELECT SINGLE typename FROM dd40l INTO sy-lisel WHERE typename EQ i_rollname.  "existing table_type
      ENDIF.
      IF sy-subrc NE 0.
        SELECT SINGLE clsname FROM seoclass INTO sy-lisel WHERE clsname EQ i_rollname.  "existing class
      ENDIF.
      IF sy-subrc NE 0.
        IF i_rollname(3) EQ 'CL_'. "probably a class
          MESSAGE w666(01) WITH 'Class' i_rollname 'does not exist (yet)' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
        ELSE.
          MESSAGE e666(01) WITH 'Data Element or Structure' i_rollname 'does not exist' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
          RETURN.
        ENDIF.
      ENDIF.
    ENDIF.

    "Find field to insert/change
    IF i_fieldname(6) EQ c_include6.
      READ TABLE lt_dd03p ASSIGNING <ls_dd03p>
           WITH KEY fieldname = i_fieldname
                    precfield = i_rollname
                    groupname = i_groupname.
      IF sy-subrc EQ 0.
        "INCLUDE already exists
        MESSAGE i666(01) WITH 'Include ' i_rollname 'already part of table' i_tabname INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        RETURN.
      ENDIF.
    ELSE.
      READ TABLE lt_dd03p ASSIGNING <ls_dd03p>
           WITH KEY fieldname = i_fieldname.
      IF sy-subrc EQ 0.
        "Check if fields already has data element
        IF i_rollname NE <ls_dd03p>-rollname.
          "change data element
          <ls_dd03p>-rollname  = i_rollname.
          MESSAGE i666(01) WITH 'Data element of field' i_fieldname 'will be changed to' i_rollname INTO sy-lisel. "#EC *
          CALL METHOD log_message.
        ELSEIF it_dd05m IS SUPPLIED.
          "update foreign key relation ship
          DATA: lt_dd05m_h TYPE tt_dd05m,
                it_dd05m_h TYPE tt_dd05m.

          lt_dd05m_h[] = lt_dd05m[].
          it_dd05m_h[] = it_dd05m[].
          DELETE lt_dd05m_h WHERE fieldname NE i_fieldname.
          CLEAR ls_dd05m.
          MODIFY lt_dd05m_h FROM ls_dd05m TRANSPORTING domname datatype leng WHERE fieldname IS NOT INITIAL.
          MODIFY it_dd05m_h FROM ls_dd05m TRANSPORTING domname datatype leng WHERE fieldname IS NOT INITIAL.
          IF lt_dd05m_h[] EQ it_dd05m[].
            "field already exists with correct data element
            MESSAGE i666(01) WITH 'Field' i_fieldname 'already exists with SHLP' INTO sy-lisel. "#EC *
            CALL METHOD log_message.
            RETURN.
          ENDIF.
        ELSEIF i_languflag NE <ls_dd03p>-languflag.
          "field already exists with correct data element
          MESSAGE i666(01) WITH 'Properties of field' i_fieldname 'will be changed' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
        ELSE.
          "field already exists with correct data element
          MESSAGE i666(01) WITH 'Field' i_fieldname 'already exists' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
          RETURN.
        ENDIF.
      ENDIF.
    ENDIF.
    IF sy-subrc NE 0. "new field
      "Find context (one field is enough since fieldname is unique)
      IF i_context IS NOT INITIAL.
        READ TABLE lt_dd03p TRANSPORTING NO FIELDS
             WITH KEY fieldname = i_context.
        IF sy-subrc NE 0.
          READ TABLE lt_dd03p TRANSPORTING NO FIELDS  "include name as context
                WITH KEY precfield = i_context.
        ENDIF.
        IF sy-subrc NE 0 AND sy-tfill NE 0.
          IF testrun IS INITIAL OR i_tabname NOT IN gr_tabname.
            MESSAGE w666(01) WITH 'Context' i_context 'not found in TABD' i_tabname INTO sy-lisel. "#EC *
            CALL METHOD log_message.
          ELSE.
            MESSAGE i666(01) WITH 'Field' i_fieldname 'will be added' INTO sy-lisel. "#EC *
            CALL METHOD log_message.
          ENDIF.
          RETURN.
        ENDIF.

        "insert new field after context
        l_tabix = sy-tabix + 1.
      ELSE.
        "no context -> insert field at end
        l_tabix = lines( lt_dd03p ) + 1.
      ENDIF.

      INSERT INITIAL LINE INTO lt_dd03p INDEX l_tabix ASSIGNING <ls_dd03p>.
    ENDIF.

    <ls_dd03p>-tabname   = i_tabname.
    <ls_dd03p>-fieldname = i_fieldname.
    <ls_dd03p>-groupname = i_groupname.
    <ls_dd03p>-languflag = i_languflag.
    <ls_dd03p>-notnull   = i_notnull.
    <ls_dd03p>-keyflag   = i_keyflag.
    FIELD-SYMBOLS: <ls_dd01v_anonymous> TYPE c.
    ASSIGN ('LS_DD01V-ANONYMOUS') TO <ls_dd01v_anonymous>.
    IF sy-subrc EQ 0.
      <ls_dd01v_anonymous> = i_anonymous.
    ENDIF.
    IF i_fieldname(6) EQ c_include6.
      <ls_dd03p>-precfield = i_rollname.
      <ls_dd03p>-comptype  = 'S'.
    ELSEIF i_rollname IS INITIAL.
      <ls_dd03p>-datatype = i_datatype.
      <ls_dd03p>-decimals = i_decimals.
      <ls_dd03p>-leng     = i_leng.
      IF i_ddtext IS NOT INITIAL.
        <ls_dd03p>-ddtext     = i_ddtext.
        <ls_dd03p>-ddlanguage = i_langu.
      ENDIF.
    ELSE.
      <ls_dd03p>-rollname  = i_rollname.
    ENDIF.
    <ls_dd03p>-reftable = i_reftable.
    <ls_dd03p>-reffield = i_reffield.

    LOOP AT lt_dd03p ASSIGNING <ls_dd03p> FROM l_tabix.
      <ls_dd03p>-position = sy-tabix.
    ENDLOOP.
    "field will be added
    MESSAGE i666(01) WITH 'Field' i_fieldname 'will be added' INTO sy-lisel. "#EC *
    CALL METHOD log_message.

    IF is_dd08v IS NOT INITIAL OR it_dd05m IS SUPPLIED.
      DELETE lt_dd08v WHERE fieldname = i_fieldname.
      DELETE lt_dd05m WHERE fieldname = i_fieldname.

      LOOP AT it_dd05m INTO ls_dd05m WHERE checktable IS NOT INITIAL
                                       AND checkfield IS NOT INITIAL.
        APPEND ls_dd05m TO lt_dd05m.
      ENDLOOP.
      IF is_dd08v IS NOT INITIAL.
        APPEND is_dd08v TO lt_dd08v.
      ENDIF.
    ENDIF.

    CHECK testrun IS INITIAL.

    CALL METHOD add_to_transport
      EXPORTING
        i_object   = 'TABL'
        i_obj_name = i_tabname
      EXCEPTIONS
        OTHERS     = 1.
    CHECK sy-subrc EQ 0.

    CALL FUNCTION 'DDIF_TABL_PUT'
      EXPORTING
        name              = i_tabname
        dd02v_wa          = ls_dd02v
        dd09l_wa          = ls_dd09l
      TABLES
        dd03p_tab         = lt_dd03p
        dd05m_tab         = lt_dd05m
        dd08v_tab         = lt_dd08v
        dd35v_tab         = lt_dd35v
        dd36m_tab         = lt_dd36m
      EXCEPTIONS
        tabl_not_found    = 1
        name_inconsistent = 2
        tabl_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.
    IF sy-subrc <> 0.
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    CALL METHOD register_inactive_object
      EXPORTING
        i_objtype = 'TABL'
        i_objname = i_tabname.

  ENDMETHOD.                    "add_field_to_table


  METHOD create_view.

    DATA: ls_dd25v     TYPE dd25v,
          ls_dd09l     TYPE dd09l,
          lt_dd26v     TYPE TABLE OF dd26v,
          lt_dd27p     TYPE TABLE OF dd27p,
          lt_dd28j     TYPE TABLE OF dd28j,
          lt_dd28v     TYPE TABLE OF dd28v,
          ls_dwinactiv TYPE dwinactiv.

    FIELD-SYMBOLS: <ls_dd27p> LIKE LINE OF lt_dd27p.

    DATA: l_tabix     TYPE sytabix,
          ls_viewname LIKE LINE OF gr_viewname VALUE 'IEQ'.

    CALL METHOD set_context
      EXPORTING
        i_langu    = i_langu
        i_object   = 'VIEW'
        i_obj_name = i_viewname.

    ls_viewname-low = i_viewname.
    COLLECT ls_viewname INTO gr_viewname.

    CALL FUNCTION 'DD_VIEW_GET'
      EXPORTING
        view_name      = i_viewname
        langu          = i_langu
        withtext       = 'X'
      IMPORTING
        dd25v_wa_a     = ls_dd25v
        dd09l_wa_a     = ls_dd09l
      TABLES
        dd26v_tab_a    = lt_dd26v
        dd27p_tab_a    = lt_dd27p
        dd28v_tab_a    = lt_dd28v
      EXCEPTIONS
        access_failure = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
      IF testrun IS INITIAL OR i_viewname NOT IN gr_viewname.
        MESSAGE e666(01) WITH 'Error while reading view' i_viewname INTO sy-lisel. "#EC *
        CALL METHOD log_message.
      ENDIF.
      RETURN.
    ENDIF.

    IF sy-subrc EQ 0 AND ls_dd25v-viewname IS NOT INITIAL. "existing.
      IF ls_dd25v-ddtext     EQ i_ddtext     AND
         ls_dd25v-viewname   EQ i_viewname   AND
         ls_dd25v-ddlanguage EQ i_langu      AND
         ls_dd25v-customauth EQ i_contflag   AND
         ls_dd25v-aggtype    EQ i_aggtype    AND
         ls_dd25v-roottab    EQ i_roottab    AND
         ls_dd25v-viewclass  EQ i_viewclass  AND
         ls_dd25v-viewgrant  EQ i_viewgrant  AND
         ls_dd25v-globalflag EQ i_globalflag AND
         ls_dd25v-readonly   EQ i_readonly   AND
         lt_dd26v[]          EQ it_dd26v[]   AND
         lt_dd28v[]          EQ it_dd28v[].
        "exist
        MESSAGE i666(01) WITH 'No update necessary' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        RETURN.
      ENDIF.
    ENDIF.

    CHECK testrun IS INITIAL.

    "new view
    ls_dd25v-viewname   = i_viewname.
    ls_dd25v-ddlanguage = i_langu.
    ls_dd25v-customauth = i_contflag.
    ls_dd25v-aggtype    = i_aggtype.
    ls_dd25v-roottab    = i_roottab.
    ls_dd25v-viewclass  = i_viewclass.
    ls_dd25v-viewgrant  = i_viewgrant.
    ls_dd25v-globalflag = i_globalflag.
    ls_dd25v-readonly   = i_readonly.

    IF i_ddtext IS INITIAL.
      ls_dd25v-ddtext   = i_viewname.
    ELSE.
      ls_dd25v-ddtext   = i_ddtext.
    ENDIF.

    CALL METHOD add_to_transport
      EXPORTING
        i_object   = 'VIEW'
        i_langu    = i_langu
        i_obj_name = i_viewname
        i_devclass = i_devclass
      EXCEPTIONS
        OTHERS     = 1.
    CHECK sy-subrc EQ 0.

    "clear redundant field MASTERLANG, relevant is only TADIR-MASTERLANG
    CLEAR ls_dd25v-masterlang.

    CALL FUNCTION 'DD_VIEW_PUT'
      EXPORTING
        view_name         = i_viewname
        put_state         = 'N'    "new
        dd25v_wa          = ls_dd25v
        dd09l_wa          = ls_dd09l
      TABLES
        dd26v_tab         = it_dd26v
        dd27p_tab         = lt_dd27p   "fields: emtpy
        dd28v_tab         = it_dd28v
      EXCEPTIONS
        db_access_failure = 1
        OTHERS            = 2.

    IF sy-subrc <> 0.
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    CALL METHOD register_inactive_object
      EXPORTING
        i_objtype = 'VIEW'
        i_objname = i_viewname.

  ENDMETHOD.                    "create_view

  METHOD add_field_to_view.
    DATA: ls_dd25v TYPE dd25v,
          ls_dd09l TYPE dd09l,
          lt_dd26v TYPE TABLE OF dd26v,
          lt_dd27p TYPE TABLE OF dd27p,
          lt_dd28j TYPE TABLE OF dd28j,
          lt_dd28v TYPE TABLE OF dd28v.

    FIELD-SYMBOLS: <ls_dd27p> LIKE LINE OF lt_dd27p.

    DATA: l_viewfield LIKE i_viewfield,
          l_rollname  LIKE i_rollname,
          l_tabix     TYPE sytabix,
          ls_viewname LIKE LINE OF gr_viewname VALUE 'IEQ'.

    CALL METHOD set_context
      EXPORTING
        i_langu    = space
        i_text     = 'Add Field(s) to View'                 "#EC NOTEXT
        i_object   = 'VIEW'
        i_obj_name = i_viewname.

    ls_viewname-low = i_viewname.
    COLLECT ls_viewname INTO gr_viewname.

    CALL FUNCTION 'DDIF_VIEW_GET'
      EXPORTING
        name          = i_viewname
        state         = 'M'     "most recent, e.g. inactive
      IMPORTING
        dd25v_wa      = ls_dd25v
        dd09l_wa      = ls_dd09l
      TABLES
        dd26v_tab     = lt_dd26v
        dd27p_tab     = lt_dd27p
        dd28j_tab     = lt_dd28j
        dd28v_tab     = lt_dd28v
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc NE 0.
      IF testrun IS INITIAL OR i_viewname NOT IN gr_viewname.
        MESSAGE e666(01) WITH 'Error while reading view' i_viewname INTO sy-lisel. "#EC *
        CALL METHOD log_message.
      ENDIF.
      RETURN.
    ENDIF.

    IF i_viewfield IS INITIAL.
      l_viewfield = i_fieldname.
    ELSE.
      l_viewfield = i_viewfield.
    ENDIF.

    IF i_rollname IS INITIAL.
      SELECT SINGLE rollname FROM dd03l INTO l_rollname
                            WHERE tabname   EQ i_tabname
                              AND fieldname EQ i_fieldname.
      IF sy-subrc NE 0.
        MESSAGE i666(01) WITH 'Field' i_fieldname 'not found in ' i_tabname INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        RETURN.
      ENDIF.
    ELSE.
      l_rollname = i_rollname.
    ENDIF.

    "Check if fields already exists
    READ TABLE lt_dd27p TRANSPORTING NO FIELDS
         WITH KEY viewfield = l_viewfield.
    IF sy-subrc EQ 0.
      "field already exists
      MESSAGE i666(01) WITH 'Field' i_fieldname 'already exists in view' i_viewname INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    IF i_context IS INITIAL.
      DESCRIBE TABLE lt_dd27p LINES sy-tabix.  "append at the end
    ELSE.
      "Find context (one field is enough since fieldname is unique)
      READ TABLE lt_dd27p TRANSPORTING NO FIELDS
           WITH KEY viewfield = i_context.
      IF sy-subrc NE 0.
        IF testrun IS INITIAL OR i_viewname NOT IN gr_viewname.
          MESSAGE i666(01) WITH 'Context' i_context 'not found in VIED' i_viewname INTO sy-lisel. "#EC *
          CALL METHOD log_message.
        ENDIF.
        RETURN.
      ENDIF.
    ENDIF.

    "insert new field after context
    l_tabix = sy-tabix + 1.

    "check whether data element exists
    IF l_rollname IS NOT INITIAL.
      READ TABLE gr_rollname TRANSPORTING NO FIELDS WITH KEY low = l_rollname.
      IF sy-subrc NE 0.
        SELECT COUNT(*) FROM dd04l WHERE rollname EQ l_rollname.
      ENDIF.
      IF sy-subrc NE 0.
        MESSAGE e666(01) WITH 'Data Element' l_rollname 'does not exist' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        RETURN.
      ENDIF.
    ENDIF.

    CHECK testrun IS INITIAL.

    "insert new field after context
    INSERT INITIAL LINE INTO lt_dd27p INDEX l_tabix ASSIGNING <ls_dd27p>.

    <ls_dd27p>-viewname   = i_viewname.
    <ls_dd27p>-viewfield  = l_viewfield.
    <ls_dd27p>-tabname    = i_tabname.
    <ls_dd27p>-fieldname  = i_fieldname.
    <ls_dd27p>-rdonly     = i_rdonly. "S/H/R
    <ls_dd27p>-rollnamevi = l_rollname.

    LOOP AT lt_dd27p ASSIGNING <ls_dd27p> FROM l_tabix.
      <ls_dd27p>-objpos = sy-tabix.
    ENDLOOP.

    CALL METHOD add_to_transport
      EXPORTING
        i_object   = 'VIEW'
        i_obj_name = i_viewname
      EXCEPTIONS
        OTHERS     = 1.
    CHECK sy-subrc EQ 0.

    CALL FUNCTION 'DDIF_VIEW_PUT'
      EXPORTING
        name              = i_viewname
        dd25v_wa          = ls_dd25v
        dd09l_wa          = ls_dd09l
      TABLES
        dd26v_tab         = lt_dd26v
        dd27p_tab         = lt_dd27p
        dd28j_tab         = lt_dd28j
        dd28v_tab         = lt_dd28v
      EXCEPTIONS
        view_not_found    = 1
        name_inconsistent = 2
        view_inconsistent = 3
        put_failure       = 4
        put_refused       = 5
        OTHERS            = 6.

    IF sy-subrc <> 0.
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    MESSAGE i666(01) WITH 'Field' i_fieldname 'has been added to view' i_viewname INTO sy-lisel. "#EC *
    CALL METHOD log_message.

    CALL METHOD register_inactive_object
      EXPORTING
        i_objtype = 'VIEW'
        i_objname = i_viewname.

  ENDMETHOD.                    "add_field_to_view

  METHOD regenerate_maint_view.   "call SE54, leaves screens untouched

    "regenerate maintaince view vua barch input of SE54
    "assumptions:
    "- maint view dialog is based on view (not table)
    "- new fields have been added
    "- no screen changes needed or done via separate corr instruction

    DATA: lt_bdc   TYPE TABLE OF bdcdata,
          ls_bdc   TYPE bdcdata,
          ls_bdcp  TYPE bdcdata,
          ls_radio LIKE ls_bdc-fnam,
          ls_opt   TYPE ctu_params.

    CALL METHOD set_context
      EXPORTING
        i_langu    = space
        i_text     = 'Regenerate Maintainance View'         "#EC NOTEXT
        i_object   = 'VIEW'
        i_obj_name = i_viewname.

    CHECK testrun IS INITIAL.

    ls_opt-dismode = 'E'.

    "-------------------------------------------
    ls_bdcp-program  = 'SAPMSVIM'.
    ls_bdcp-dynpro   = '0050'.
    ls_bdcp-dynbegin = 'X'.
    APPEND ls_bdcp TO lt_bdc.

    ls_bdc-fnam = 'VIMDYNFLDS-VIEWNAME'.
    ls_bdc-fval = i_viewname.
    APPEND ls_bdc TO lt_bdc.

    ls_bdc-fnam = 'BDC_CURSOR'.
    ls_bdc-fval = 'VIMDYNFLDS-ELEM_GEN'.
    APPEND ls_bdc TO lt_bdc.

    ls_bdc-fnam = 'VIMDYNFLDS-ELEM_GEN'.
    ls_bdc-fval = 'X'.
    APPEND ls_bdc TO lt_bdc.

    ls_bdc-fnam = 'BDC_OKCODE'.
    ls_bdc-fval = '=CRMO'.
    APPEND ls_bdc TO lt_bdc.

    "-------------------------------------------
    ls_bdcp-dynpro   = '0120'.
    ls_bdcp-dynbegin = 'X'.
    APPEND ls_bdcp TO lt_bdc.

    ls_bdc-fnam = 'BDC_OKCODE'.
    ls_bdc-fval = '=RESE'.
    APPEND ls_bdc TO lt_bdc.

    "-------------------------------------------
    ls_bdcp-dynpro   = '1240'.
    ls_bdcp-dynbegin = 'X'.
    APPEND ls_bdcp TO lt_bdc.

    ls_bdc-fnam = 'BDC_CURSOR'.
    ls_bdc-fval = 'VIMDYNFLDS-NEW_FIELD'.
    APPEND ls_bdc TO lt_bdc.

    ls_bdc-fnam = 'VIMDYNFLDS-NEW_FIELD'.
    ls_bdc-fval = 'X'.
    APPEND ls_bdc TO lt_bdc.

    ls_bdc-fnam = 'BDC_OKCODE'.
    ls_bdc-fval = '=O.K.'.
    APPEND ls_bdc TO lt_bdc.

    "-------------------------------------------
    ls_bdcp-dynpro   = '1243'.
    ls_bdcp-dynbegin = 'X'.
    APPEND ls_bdcp TO lt_bdc.

    ls_bdc-fnam = 'BDC_CURSOR'.
    ls_bdc-fval = 'VIMDYNFLDS-FIELD_NORM'.
    APPEND ls_bdc TO lt_bdc.

    ls_bdc-fnam = 'VIMDYNFLDS-FIELD_NORM'.
    ls_bdc-fval = 'X'.
    APPEND ls_bdc TO lt_bdc.

    ls_bdc-fnam = 'BDC_OKCODE'.
    ls_bdc-fval = '=O.K.'.
    APPEND ls_bdc TO lt_bdc.

    ls_opt-dismode  = 'E'.
    ls_opt-racommit = 'X'.
    ls_opt-nobinpt  = 'X'.
    ls_opt-nobiend  = 'X'.

    "-------------------------------------------
    ls_bdcp-dynpro   = '0120'.
    ls_bdcp-dynbegin = 'X'.
    APPEND ls_bdcp TO lt_bdc.

    ls_bdc-fnam = 'BDC_OKCODE'.
    ls_bdc-fval = '=BACK'.
    APPEND ls_bdc TO lt_bdc.

    "-------------------------------------------
    ls_bdcp-dynpro   = '0050'.
    ls_bdcp-dynbegin = 'X'.
    APPEND ls_bdcp TO lt_bdc.

    ls_bdc-fnam = 'BDC_OKCODE'.
    ls_bdc-fval = '=BACK'.
    APPEND ls_bdc TO lt_bdc.

    "-------------------------------------------
    CALL TRANSACTION 'SE54' USING lt_bdc OPTIONS FROM ls_opt.

    CALL METHOD log_message.

  ENDMETHOD.                    "regenerate_maint_view

  METHOD activate.

    DATA: lt_dwinactiv TYPE TABLE OF dwinactiv,
          lv_answer,
          l_request    TYPE trkorr,
          l_logname    TYPE string,
          ls_job       TYPE tbtcjob,
          lv_rc        TYPE sysubrc.

    FIELD-SYMBOLS: <ls_dwinactiv> LIKE LINE OF lt_dwinactiv,
                   <ls_viewname>  TYPE viewname.

    CALL METHOD set_context
      EXPORTING
        i_langu    = space
        i_object   = space
        i_obj_name = space.

    IF testrun IS INITIAL.
      "activate switches "online"
      IF gr_switchname IS NOT INITIAL.
        SELECT * FROM dwinactiv INTO TABLE lt_dwinactiv
                                     WHERE obj_name IN gr_switchname.
        IF lt_dwinactiv[] IS  NOT INITIAL.
          LOOP AT lt_dwinactiv ASSIGNING <ls_dwinactiv>
                                WHERE uname NE sy-uname
                                  AND obj_name IN gr_switchname.
            <ls_dwinactiv>-uname = sy-uname.
          ENDLOOP.
          INSERT dwinactiv FROM TABLE lt_dwinactiv ACCEPTING DUPLICATE KEYS.
        ENDIF.

        MESSAGE s357(scwn).
        CALL FUNCTION 'RS_WORKING_OBJECT_ACTIVATE'
          EXPORTING
            dictionary_only = 'X'
          TABLES
            objects         = lt_dwinactiv
          EXCEPTIONS
            OTHERS          = 5.
      ENDIF.

      "make sure that ranges are not empty
      APPEND 'IEQ' TO: gr_domname,
                       gr_rollname,
                       gr_tabname,
                       gr_shlpname,
                       gr_viewname,
                       gr_ttypname,
                       gr_guistatus,
                       gr_indexes,
                       gr_indxtab,
                       gr_indxname.

      SELECT * FROM dwinactiv INTO TABLE lt_dwinactiv
              WHERE ( object NE space )   "dummy
                AND ( obj_name IN gr_domname
                   OR obj_name IN gr_rollname
                   OR obj_name IN gr_tabname
                   OR obj_name IN gr_shlpname
                   OR obj_name IN gr_viewname
                   OR obj_name IN gr_ttypname
                   OR obj_name IN gr_guistatus
                   OR obj_name IN gr_indexes ).
    ENDIF.

    IF lt_dwinactiv[] IS INITIAL AND gv_objects_without_activation IS INITIAL.
      MESSAGE i666(01) WITH 'No repository changes made' '' '' '' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      IF gv_translation EQ 'X' OR gv_copy_translation EQ 'X'.
        MESSAGE i666(01) WITH 'Translation has been updated' '' '' '' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
      ENDIF.
    ELSE.
      "add all relevant inactive objects also to current user's worklist
      "gets relevant if a different user is doing the activation.
      "entries for all users will be deleted if any user activates the object
      LOOP AT lt_dwinactiv ASSIGNING <ls_dwinactiv>
                           WHERE uname NE sy-uname.
        <ls_dwinactiv>-uname = sy-uname.
      ENDLOOP.
      INSERT dwinactiv FROM TABLE lt_dwinactiv ACCEPTING DUPLICATE KEYS.

      IF i_result_auth_check IS INITIAL.

        LOOP AT lt_dwinactiv TRANSPORTING NO FIELDS
                             WHERE object = 'DOMA' OR
                                   object = 'DTEL' OR
                                   object = 'TABL' OR
                                   object = 'INDX' OR
                                   object = 'VIEW' OR
                                   object = 'TTYP' OR
                                   object = 'SHLP'.
          EXIT.
        ENDLOOP.
        IF sy-subrc EQ 0.
          IF gv_unit_test IS NOT INITIAL.
            lv_answer = '1'.  "force online activation
          ELSE.
            CALL FUNCTION 'POPUP_TO_CONFIRM'
              EXPORTING
                titlebar              = 'Activation'        "#EC NOTEXT
                text_question         = 'How do you want to activate DDIC?' "#EC NOTEXT
                text_button_1         = 'Online'            "#EC NOTEXT
                text_button_2         = 'Batch'             "#EC NOTEXT
                display_cancel_button = 'X'
              IMPORTING
                answer                = lv_answer
              EXCEPTIONS
                OTHERS                = 1.
            IF sy-subrc <> 0.
              MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                      WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
              CALL METHOD log_message.
            ENDIF.
          ENDIF.

          "DDIC via RADMASG0
          "remove DDIC objects from worklist
          DELETE lt_dwinactiv WHERE object = 'DOMA' OR
                                    object = 'DTEL' OR
                                    object = 'TABL' OR
                                    object = 'INDX' OR
                                    object = 'VIEW' OR
                                    object = 'TTYP' OR
                                    object = 'SHLP'.
        ENDIF.

        IF lv_answer NE 'A' AND lt_dwinactiv[] IS NOT INITIAL.
          "1) activate non DDIC objects (e.g. CUAD) online
          MESSAGE s357(scwn).
          CALL FUNCTION 'RS_WORKING_OBJECT_ACTIVATE'
            EXPORTING
              dictionary_only = 'X'
*             cwb_mode        = 'X'
            TABLES
              objects         = lt_dwinactiv
            EXCEPTIONS
              OTHERS          = 5.
          IF sy-subrc <> 0.
            MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
            CALL METHOD log_message.
          ENDIF.

          MESSAGE s357(scwn).
          CALL FUNCTION 'RS_WORKING_OBJECT_ACTIVATE'
            EXPORTING
              dictionary_only = ' '
*             cwb_mode        = 'X'
            TABLES
              objects         = lt_dwinactiv
            EXCEPTIONS
              OTHERS          = 5.
          IF sy-subrc <> 0.
            lv_answer = 'A'.
            CALL METHOD log_message.
            MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno
                    WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
          ENDIF.
        ENDIF.

        IF lv_answer = '1' .
          "2a) activate DDIC online
          CONCATENATE sy-repid '_&DATE&&TIME&' INTO l_logname.
          SUBMIT radmasg0 WITH domname  IN gr_domname
                          WITH rollname IN gr_rollname
                          WITH tabname  IN gr_tabname
                          WITH indxtab  IN gr_indxtab
                          WITH indxname IN gr_indxname
                          WITH viewname IN gr_viewname
                          WITH ttypname IN gr_ttypname
                          WITH shlpname IN gr_shlpname
                          WITH logname  EQ l_logname

                          WITH ddmode   = 'T'
                          WITH frcact   = 'X'
                          WITH logshow  = 'X'

                          AND RETURN.

          DATA: l_act_rc TYPE sysubrc.
          IMPORT act_rc TO l_act_rc FROM MEMORY ID 'ACRC'.
          IF l_act_rc > 4.  "4 is only warning
            MESSAGE e666(01) WITH 'Errors during DDIC activation' INTO sy-lisel.
            CALL METHOD log_message.
          ELSE.
            "Nach-Aktivieren der DB-Tabellen (teilweise "Tabelle existiert nicht auf der DB")
            SUBMIT radmasg0 WITH tabname  IN gr_tabname
                            WITH indxtab  IN gr_indxtab
                            WITH indxname IN gr_indxname
                            WITH logshow  = space
                            AND RETURN.

            IMPORT act_rc TO l_act_rc FROM MEMORY ID 'ACRC'.
            IF l_act_rc > 4.  "4 is only warning
              MESSAGE e666(01) WITH 'Errors DDIC activation Step 2' INTO sy-lisel.
              CALL METHOD log_message.
            ELSE.
              MESSAGE s666(01) WITH 'DDIC activation successful' INTO sy-lisel.
              CALL METHOD log_message.
            ENDIF.
          ENDIF.

        ELSEIF lv_answer = '2' .
          "2b) activate DDIC objects via batch job
          ls_job-jobname = sy-repid.

          CALL FUNCTION 'JOB_OPEN'
            EXPORTING
              jobname          = ls_job-jobname
            IMPORTING
              jobcount         = ls_job-jobcount
            CHANGING
              ret              = lv_rc
            EXCEPTIONS
              cant_create_job  = 1
              invalid_job_data = 2
              jobname_missing  = 3
              OTHERS           = 4.
          IF sy-subrc <> 0 OR lv_rc NE 0.
            MESSAGE e026(bt) WITH ls_job-jobname INTO sy-lisel. "#EC *
            CALL METHOD log_message.
          ELSE.
            CONCATENATE sy-repid '_&DATE&&TIME&' INTO l_logname.
            SUBMIT radmasg0 WITH domname  IN gr_domname
                            WITH rollname IN gr_rollname
                            WITH tabname  IN gr_tabname
                            WITH indxtab  IN gr_indxtab
                            WITH indxname IN gr_indxname
                            WITH viewname IN gr_viewname
                            WITH ttypname IN gr_ttypname
                            WITH shlpname IN gr_shlpname
                            WITH logname  EQ l_logname

                            WITH ddmode   = 'T'
                            WITH frcact   = 'X'
                            WITH logshow  = 'X'

                            VIA JOB ls_job-jobname
                            NUMBER ls_job-jobcount
                            AND RETURN.

            "Nach-Aktivieren der DB-Tabellen (teilweise "Tabelle existiert nicht auf der DB")
            SUBMIT radmasg0 WITH tabname  IN gr_tabname
                            WITH indxtab  IN gr_indxtab
                            WITH indxname IN gr_indxname
                            WITH logshow  = space
                            VIA JOB ls_job-jobname
                            NUMBER ls_job-jobcount
                            AND RETURN.

            CALL FUNCTION 'JOB_CLOSE'
              EXPORTING
                jobcount  = ls_job-jobcount
                jobname   = ls_job-jobname
                strtimmed = 'X'
              EXCEPTIONS
                OTHERS    = 1.
            IF sy-subrc EQ 0.
              MESSAGE s305(ut) WITH ls_job-jobname INTO sy-lisel. "#EC *
              CALL METHOD log_message.
              MESSAGE i666(01) WITH 'Use Report RADPROTB to view activation log'
                                    'after job has finished'
                                    'in transaction SMX.' ''. "#EC NOTEXT
              CALL METHOD log_message.
            ELSE.
              MESSAGE e026(bt) WITH ls_job-jobname INTO sy-lisel. "#EC *
              CALL METHOD log_message.
            ENDIF.
          ENDIF.
        ENDIF.
      ELSE.
        MESSAGE i666(01) WITH 'No authorization to activate the DDIC changes.'
                              'Call transaction SU53 for details' '' ''. "#EC NOTEXT
        sy-msgty = 'E'.
        CALL METHOD log_message.
      ENDIF.
    ENDIF.

    CALL METHOD lcl_wb=>display_log.

    SET PARAMETER ID 'EUK' FIELD space.
    EXPORT current_devclass FROM space TO MEMORY ID 'EUK'.

  ENDMETHOD.                    "activate

  METHOD add_to_transport.

    STATICS: s_object   LIKE i_object,
             s_obj_name TYPE string,
             s_subrc    TYPE sysubrc.

    DATA: l_tadir_name   TYPE tadir-obj_name,
          l_object_name  TYPE string,
          l_object_class TYPE string,
          l_extend,
          l_global_lock,
          ls_trkey       TYPE trkey,
          lv_msgty       TYPE symsgty.

    CLEAR sy-subrc.
    CHECK gv_copy_translation IS INITIAL.

    IF i_object   NE s_object OR
       i_obj_name NE s_obj_name.

      s_object   = i_object.
      s_obj_name = i_obj_name.

      CASE i_object.
        WHEN 'REPT' OR 'FUNC' OR 'CUAD' OR 'DOCU'.
          l_object_class = i_object.
          l_object_name  = i_obj_name.
        WHEN 'DOCV' OR 'DOCT' OR 'DSYS' OR 'STCS' OR 'MSAG'.
          l_object_class = i_object.
          l_object_name  = i_obj_name.
          l_global_lock  = 'X'.
          l_extend       = 'X'.
          l_tadir_name   = i_obj_name.
        WHEN 'MESS'.
          l_object_class = 'T100'.
          l_object_name  = i_obj_name.
        WHEN 'CLAS' OR 'FUGR' OR 'PARA'.
          l_object_class = i_object.
          l_object_name  = i_obj_name.
          l_tadir_name   = i_obj_name.
          l_global_lock  = 'X'.
        WHEN 'DOMA' OR 'DTEL' OR 'TABL' OR 'VIEW' OR 'INDX' OR 'TTYP' OR 'SHLP'.
          l_object_class = 'DICT'.
          CONCATENATE i_object i_obj_name
                 INTO l_object_name.
          l_tadir_name   = i_obj_name.
        WHEN OTHERS.
          l_object_class = i_object.
          l_object_name  = i_obj_name.
      ENDCASE.

      "create TADIR entry in advance avoid popup
      IF l_tadir_name IS NOT INITIAL.
        DATA: ls_tadir_old TYPE tadir.
        SELECT SINGLE * FROM tadir INTO ls_tadir_old
                       WHERE pgmid      EQ 'R3TR'
                         AND object     EQ i_object
                         AND obj_name   EQ l_tadir_name.
        IF i_langu CA 'ED'.
          "set correct language and package on first call per object
          "skip this for other languages than EN/DE.
          CALL FUNCTION 'TR_TADIR_INTERFACE'
            EXPORTING
*             WI_DELETE_TADIR_ENTRY = ' '
              wi_test_modus         = space
              wi_tadir_pgmid        = 'R3TR'
              wi_tadir_object       = i_object
              wi_tadir_obj_name     = l_tadir_name
              wi_tadir_devclass     = i_devclass
              wi_tadir_masterlang   = i_langu
            EXCEPTIONS
              OTHERS                = 25.
          IF sy-subrc <> 0.
          ENDIF.
        ENDIF.
        IF i_devclass IS NOT INITIAL.
          "set correct package in memory
          EXPORT current_devclass FROM i_devclass TO MEMORY ID 'EUK'.
          SET PARAMETER ID 'EUK' FIELD i_devclass.
        ENDIF.
      ENDIF.

      CALL FUNCTION 'RS_CORR_INSERT'    "and create TADIR-entry
        EXPORTING
          object              = l_object_name
          object_class        = l_object_class
          devclass            = i_devclass
          korrnum             = gv_trkorr
          global_lock         = l_global_lock
*         AUTHOR              = ' '
          master_language     = i_langu
*         GENFLAG             = ' '
*         PROGRAM             = ' '
*         OBJECT_CLASS_SUPPORTS_MA = ' '
          extend              = l_extend
*         SUPPRESS_DIALOG     = ' '
*         MOD_LANGU           = ' '
*         ACTIVATION_CALL     = ' '
        IMPORTING
          korrnum             = gv_trkorr
*         ORDERNUM            =
*         NEW_CORR_ENTRY      =
*         AUTHOR              =
          transport_key       = ls_trkey
*         NEW_EXTEND          =
        EXCEPTIONS
          cancelled           = 1
          permission_failure  = 2
          unknown_objectclass = 3
          OTHERS              = 4.
      s_subrc = sy-subrc.

      "correct master language if neccessary
      IF l_tadir_name IS NOT INITIAL AND ls_tadir_old IS INITIAL.
        IF i_langu CA 'ED'.
          UPDATE tadir SET masterlang = i_langu
                     WHERE pgmid      EQ 'R3TR'
                       AND object     EQ i_object
                       AND obj_name   EQ l_tadir_name
                       AND masterlang NE i_langu.
        ENDIF.
      ENDIF.

    ENDIF.

    IF s_subrc NE 0.
      MESSAGE e666(01) WITH 'Could not add to transport request' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      RAISE error.
    ENDIF.

  ENDMETHOD.                    "add_to_transport

  METHOD register_inactive_object.

    DATA: l_obj_name TYPE e071-obj_name.

    l_obj_name = i_objname.
    CALL FUNCTION 'RS_INSERT_INTO_WORKING_AREA'
      EXPORTING
        object            = i_objtype
        obj_name          = l_obj_name
      EXCEPTIONS
        wrong_object_name = 1
        OTHERS            = 2.

    IF i_treetype IS SUPPLIED.
      CHECK i_treetype NE space.
      CALL FUNCTION 'RS_TREE_OBJECT_PLACEMENT'
        EXPORTING
          type   = i_treetype
          object = l_obj_name.
    ELSE.
      CALL FUNCTION 'RS_TREE_OBJECT_PLACEMENT'
        EXPORTING
          type   = i_objtype
          object = l_obj_name.
    ENDIF.

  ENDMETHOD.                    "register_inactive_object

  METHOD create_message_class.    "will be activated immediately

    DATA: ls_t100a   TYPE t100a,
          ls_t100t   TYPE t100t,
          l_obj_name TYPE e071-obj_name.

    CALL METHOD set_context
      EXPORTING
        i_langu    = i_langu
        i_object   = 'MSAG'
        i_obj_name = i_msgid.

    "check if message class exists
    SELECT SINGLE * FROM t100a INTO ls_t100a WHERE arbgb = i_msgid.
    IF sy-subrc EQ 0.
      MESSAGE i666(01) WITH 'No update necessary' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    CHECK testrun IS INITIAL.

    CALL METHOD add_to_transport    "and create TADIR
      EXPORTING
        i_object   = 'MSAG'
        i_obj_name = i_msgid
        i_devclass = i_devclass
        i_langu    = i_langu
      EXCEPTIONS
        OTHERS     = 1.

    CHECK sy-subrc EQ 0.

    ls_t100a-lastuser   = sy-uname.
    ls_t100a-ldate      = sy-datum.
    ls_t100a-ltime      = sy-uzeit.
    ls_t100a-masterlang = i_langu.
    ls_t100a-arbgb      = i_msgid.
    MODIFY t100a FROM ls_t100a. "no activation needed

    ls_t100t-sprsl = ls_t100a-masterlang.
    ls_t100t-arbgb = ls_t100a-arbgb.
    ls_t100t-stext = i_msgid. "take any text
    MODIFY t100t FROM ls_t100t.

    MESSAGE i666(01) WITH 'Update successful' INTO sy-lisel. "#EC *
    CALL METHOD log_message.

    CALL FUNCTION 'RS_TREE_OBJECT_PLACEMENT'
      EXPORTING
        type   = 'MSAG'
        object = i_msgid.

  ENDMETHOD.                    "create_message_class

  METHOD create_message.

    DATA: lt_bdc       TYPE TABLE OF bdcdata,
          ls_bdc       TYPE bdcdata,
          ls_bdcp      TYPE bdcdata,
          ls_radio     LIKE ls_bdc-fnam,
          ls_opt       TYPE ctu_params.
    DATA: ls_t100      TYPE t100,
          ls_t100a     TYPE t100a,
          ls_t100u     TYPE t100u,
          l_obj_name   TYPE dokil-object,
          ls_msg_class LIKE LINE OF gr_msg_class VALUE 'IEQ'.

    ls_msg_class-low = i_msgid.
    COLLECT ls_msg_class INTO gr_msg_class.

    CALL METHOD set_context
      EXPORTING
        i_langu     = i_langu
        i_object    = 'MESS'
        i_obj_name  = i_msgid
        i_obj_name2 = i_msgno.

    SELECT SINGLE * FROM t100a INTO ls_t100a
                   WHERE arbgb EQ i_msgid.
    IF sy-subrc NE 0.
      IF testrun IS INITIAL OR i_msgid NOT IN gr_msg_class.
        MESSAGE e509(eu) WITH i_msgid INTO sy-lisel.        "#EC *
        CALL METHOD log_message.
      ENDIF.
      RETURN.
    ENDIF.

    SELECT SINGLE * FROM t100 INTO ls_t100
                   WHERE sprsl EQ i_langu
                     AND arbgb EQ i_msgid
                     AND msgnr EQ i_msgno.

    SELECT SINGLE * FROM t100u INTO ls_t100u
                   WHERE arbgb EQ i_msgid
                     AND msgnr EQ i_msgno.
    IF i_text EQ ls_t100-text.
      IF i_selfdef IS INITIAL     AND ls_t100u-selfdef IS INITIAL OR
         i_selfdef IS NOT INITIAL AND ls_t100u-selfdef IS NOT INITIAL.
        MESSAGE i666(01) WITH 'No update necessary' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        RETURN.
      ENDIF.
    ENDIF.

    CHECK testrun IS INITIAL.

    CALL FUNCTION 'DOCU_OBJECT_NAME_CONCATENATE'
      EXPORTING
        docu_id  = 'NA'
        element  = i_msgid
        addition = i_msgno
      IMPORTING
        object   = l_obj_name
      EXCEPTIONS
        OTHERS   = 0.

    CALL METHOD add_to_transport
      EXPORTING
        i_object   = 'MESS'
        i_obj_name = l_obj_name
      EXCEPTIONS
        OTHERS     = 1.
    CHECK sy-subrc EQ 0.

    IF i_langu EQ ls_t100a-masterlang AND gv_copy_translation IS INITIAL.
      "create or change message and write into transport request
      "if sy-langu is different from master language SE91 will switch to master lang

      "-------------------------------------------
      ls_bdcp-program  = 'SAPLWBMESSAGES'.
      ls_bdcp-dynpro   = '0100'.
      ls_bdcp-dynbegin = 'X'.
      APPEND ls_bdcp TO lt_bdc.

*    ls_bdc-fnam = 'BDC_CURSOR'.
*    ls_bdc-fval = 'MSG_NUMMER'.
*    APPEND ls_bdc TO lt_bdc.

      ls_bdc-fnam = 'RSDAG-ARBGB'.
      ls_bdc-fval = i_msgid.
      APPEND ls_bdc TO lt_bdc.

      ls_bdc-fnam = 'MSG_NUMMER'.
      ls_bdc-fval = i_msgno.
      APPEND ls_bdc TO lt_bdc.

      ls_bdc-fnam = 'RSDAG-MSGFLAG'.
      ls_bdc-fval = 'X'.
      APPEND ls_bdc TO lt_bdc.

      ls_bdc-fnam = 'BDC_OKCODE'.
      ls_bdc-fval = '=WB_EDIT'.
      APPEND ls_bdc TO lt_bdc.

      "-------------------------------------------
      ls_bdcp-dynpro   = '1000'.
      ls_bdcp-dynbegin = 'X'.
      APPEND ls_bdcp TO lt_bdc.

      ls_bdc-fnam = 'BDC_SUBSCR'.
      ls_bdc-fval = 'SAPLWBMESSAGES 0101SUB'.
      APPEND ls_bdc TO lt_bdc.

      ls_bdc-fnam = 'T100-TEXT(01)'.
      ls_bdc-fval = i_text.
      APPEND ls_bdc TO lt_bdc.

      ls_bdc-fnam = 'LISTTAB-DOKU_FLAG(01)'.
      IF i_selfdef IS INITIAL.
        ls_bdc-fval = ' '.
      ELSE.
        ls_bdc-fval = 'X'.
      ENDIF.
      APPEND ls_bdc TO lt_bdc.

      ls_bdc-fnam = 'BDC_OKCODE'.
      ls_bdc-fval = '=WB_SAVE'.
      APPEND ls_bdc TO lt_bdc.

      "-------------------------------------------
      ls_bdcp-dynpro   = '1000'.
      ls_bdcp-dynbegin = 'X'.
      APPEND ls_bdcp TO lt_bdc.

      ls_bdc-fnam = 'BDC_OKCODE'.
      ls_bdc-fval = '=WB_BACK'.
      APPEND ls_bdc TO lt_bdc.

      "-------------------------------------------
      ls_bdcp-dynpro   = '0100'.
      ls_bdcp-dynbegin = 'X'.
      APPEND ls_bdcp TO lt_bdc.

      ls_bdc-fnam = 'BDC_OKCODE'.
      ls_bdc-fval = '=WB_BACK'.
      APPEND ls_bdc TO lt_bdc.

      ls_opt-dismode  = 'E'.
      ls_opt-racommit = 'X'.
      ls_opt-nobinpt  = 'X'.
      ls_opt-nobiend  = 'X'.

      "-------------------------------------------
      CALL TRANSACTION 'SE91' USING lt_bdc OPTIONS FROM ls_opt.
    ELSE.
      "update translation only
      ls_t100-arbgb = i_msgid.
      ls_t100-msgnr = i_msgno.
      ls_t100-sprsl = i_langu.
      ls_t100-text  = i_text.
      MODIFY t100 FROM ls_t100.  "no activation needed
    ENDIF.
    MESSAGE i666(01) WITH 'Update successful' INTO sy-lisel. "#EC *
    CALL METHOD log_message.
    gv_translation                = 'X'.
    gv_objects_without_activation = 'X'.

  ENDMETHOD.                    "create_message

  METHOD create_transaction.

    DATA: l_text TYPE tstct-ttext.

    CALL METHOD set_context
      EXPORTING
        i_langu    = i_langu
        i_object   = 'TRAN'
        i_obj_name = i_tcode.

    CALL FUNCTION 'RPY_TRANSACTION_READ'
      EXPORTING
        transaction      = i_tcode
*      TABLES
*       TCODES           =
*       GUI_ATTRIBUTES   =
      EXCEPTIONS
        permission_error = 1
        cancelled        = 2
        not_found        = 3
        object_not_found = 4
        OTHERS           = 5.
    IF sy-subrc EQ 0.
      "evtl vergleichen und bei Ungleichheit zuerst löschen
      "First appraoch: No update
      MESSAGE i666(01) WITH 'Transaction exists. No update necessary' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    CHECK testrun IS INITIAL.

    IF i_text IS INITIAL.
      l_text = i_tcode.
    ELSE.
      l_text = i_text.
    ENDIF.
    CALL FUNCTION 'RPY_TRANSACTION_INSERT'          "performs rs_corr_insert
      EXPORTING
        transaction         = i_tcode
        program             = i_program
        dynpro              = i_dynpro
        language            = i_langu
        development_class   = i_devclass
        transaction_type    = i_type
        shorttext           = i_text
*       suppress_corr_insert                =
        called_transaction  = i_called_transaction
        called_transaction_skip             = i_called_transaction_skip
*       VARIANT             =
*       CL_INDEPENDEND      =
*       EASY_WEB_TRANSACTION                =
*       PROFESSIONEL_USER_TRANSACTION       =
        html_enabled        = i_htmlgui
        java_enabled        = i_javagui
        wingui_enabled      = i_wingui
*       SERVICEFILE         =
*       GENFLAG             = ' '
      TABLES
*       DOCU_TABLE_USER     =
*       DOCU_TABLE_TECH     =
        param_values        = i_param
      EXCEPTIONS
        cancelled           = 1
        already_exist       = 2
        permission_error    = 3
        name_not_allowed    = 4
        name_conflict       = 5
        illegal_type        = 6
        object_inconsistent = 7
        db_access_error     = 8
        OTHERS              = 9.
    IF sy-subrc <> 0.
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    MESSAGE i666(01) WITH 'Update successful' INTO sy-lisel. "#EC *
    CALL METHOD log_message.

    gv_objects_without_activation = 'X'.

    CALL FUNCTION 'RS_TREE_OBJECT_PLACEMENT'
      EXPORTING
        type   = 'TRAN'
        object = i_tcode.

  ENDMETHOD.                    "create_transaction


  METHOD create_mess_docu.

    STATICS: lt_line TYPE TABLE OF tline.

    DATA: ls_head          TYPE thead,
          lt_line_old      LIKE lt_line,
          ls_line          TYPE tline,
          ls_tadir         TYPE tadir,
          ls_dd04v         TYPE dd04v,
          lv_no_masterlang.

    IF i_line IS NOT INITIAL.
      ls_line = i_line.
      SHIFT ls_line-tdline LEFT.
      APPEND ls_line TO lt_line.
    ELSE.
      CALL METHOD set_context
        EXPORTING
          i_langu     = i_langu
          i_object    = 'MESS'
          i_obj_name  = i_msgid
          i_obj_name2 = i_msgno
          i_text      = 'Message Longtext'.                 "#EC NOTEXT

      ls_head-tdobject = 'DOKU'.
      CONCATENATE i_msgid i_msgno INTO ls_head-tdname.
      ls_head-tdid    = 'NA'. "Nachricht/Message
      ls_head-tdspras = i_langu.
      ls_head-tdform  = 'S_DOCU_SHOW'.
      ls_head-tdstyle = 'S_DOCUS1'.

      CALL FUNCTION 'DOCU_GET'
        EXPORTING
          id     = ls_head-tdid(2)
          langu  = ls_head-tdspras
          object = ls_head-tdname(60)
        TABLES
          line   = lt_line_old
        EXCEPTIONS
          OTHERS = 0.

      IF et_lines IS SUPPLIED.
        et_lines[] = lt_line[] = lt_line_old[].
        RETURN.
      ENDIF.

      IF lt_line_old[] EQ lt_line.
        REFRESH lt_line.
        "no update necessary
        MESSAGE i666(01) WITH 'No update necessary' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        RETURN.
      ENDIF.

      CHECK testrun IS INITIAL.

      CONCATENATE ls_head-tdid ls_head-tdname INTO ls_tadir-obj_name.

      CALL METHOD add_to_transport
        EXPORTING
          i_object   = 'DOCU'
          i_obj_name = ls_tadir-obj_name
        EXCEPTIONS
          OTHERS     = 0.

      SELECT SINGLE * FROM tadir INTO ls_tadir
                     WHERE pgmid    EQ 'R3TR'
                       AND object   EQ 'MSAG'
                       AND obj_name EQ i_msgid.
      IF ls_head-tdspras NE ls_tadir-masterlang.
        lv_no_masterlang = 'X'.
      ENDIF.

      "create new version
      DATA l_dokversion TYPE dokhl-dokversion.
      SELECT MAX( dokversion ) FROM dokhl INTO l_dokversion "#EC *
                        WHERE id     = ls_head-tdid(2)
                          AND object = ls_head-tdname
                          AND langu  = ls_head-tdspras.
      ADD 1 TO l_dokversion.

      ls_head-tdfdate = sy-datum.
      ls_head-tdftime = sy-uzeit.
      ls_head-tdfuser = sy-uname.
      ls_head-tdldate = sy-datum.
      ls_head-tdltime = sy-uzeit.
      ls_head-tdluser = sy-uname.

      CALL FUNCTION 'DOCU_UPDATE'
        EXPORTING
*         ACTCLASS      = ' '
          head          = ls_head
          no_masterlang = lv_no_masterlang
          state         = 'A'
          typ           = 'E'
          version       = l_dokversion
        TABLES
          line          = lt_line.

      MESSAGE i666(01) WITH 'Update successful' 'for longtext of message' i_msgid i_msgno INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      gv_translation = 'X'.
      REFRESH lt_line.
    ENDIF.

  ENDMETHOD.                    "create_mess_docu

  METHOD create_dtel_docu.

    STATICS: lt_line TYPE TABLE OF tline.

    DATA: ls_head          TYPE thead,
          lt_line_old      LIKE lt_line,
          ls_line          TYPE tline,
          ls_tadir         TYPE tadir,
          ls_dd04v         TYPE dd04v,
          lv_no_masterlang.

    IF i_line IS NOT INITIAL.
      ls_line = i_line.
      SHIFT ls_line-tdline LEFT.
      APPEND ls_line TO lt_line.
    ELSE.
      CALL METHOD set_context
        EXPORTING
          i_langu    = i_langu
          i_object   = 'DTEL'
          i_obj_name = i_rollname
          i_text     = 'Data Element Longtext'.             "#EC NOTEXT

      ls_head-tdobject = 'DOKU'.
      ls_head-tdname   = i_rollname.
      ls_head-tdid     = 'DE'. "Data element
      ls_head-tdspras  = i_langu.
      ls_head-tdform   = 'S_DOCU_SHOW'.
      ls_head-tdstyle  = 'S_DOCUS1'.

      CALL FUNCTION 'DOCU_GET'
        EXPORTING
          id     = ls_head-tdid(2)
          langu  = ls_head-tdspras
          object = ls_head-tdname(60)
        TABLES
          line   = lt_line_old
        EXCEPTIONS
          OTHERS = 0.

      IF et_lines IS SUPPLIED.
        et_lines[] = lt_line[] = lt_line_old[].
        RETURN.
      ENDIF.

      IF lt_line_old[] EQ lt_line.
        REFRESH lt_line.
        "no update necessary
        MESSAGE i666(01) WITH 'No update necessary' INTO sy-lisel. "#EC *
        CALL METHOD log_message.
        RETURN.
      ENDIF.

      CHECK testrun IS INITIAL.

      CONCATENATE ls_head-tdid ls_head-tdname INTO ls_tadir-obj_name.

      CALL METHOD add_to_transport
        EXPORTING
          i_object   = 'DOCU'
          i_obj_name = ls_tadir-obj_name
        EXCEPTIONS
          OTHERS     = 1.
      CHECK sy-subrc EQ 0.

      SELECT SINGLE * FROM tadir INTO ls_tadir
                     WHERE pgmid    EQ 'R3TR'
                       AND object   EQ 'DTEL'
                       AND obj_name EQ i_rollname.
      IF ls_head-tdspras NE ls_tadir-masterlang.
        lv_no_masterlang = 'X'.
      ENDIF.

      "create new version
      DATA l_dokversion TYPE dokhl-dokversion.
      SELECT MAX( dokversion ) FROM dokhl INTO l_dokversion "#EC *
                        WHERE id     = ls_head-tdid(2)
                          AND object = ls_head-tdname
                          AND langu  = ls_head-tdspras.
      ADD 1 TO l_dokversion.

      ls_head-tdfdate = sy-datum.
      ls_head-tdftime = sy-uzeit.
      ls_head-tdfuser = sy-uname.
      ls_head-tdldate = sy-datum.
      ls_head-tdltime = sy-uzeit.
      ls_head-tdluser = sy-uname.

      CALL FUNCTION 'DOCU_UPDATE'
        EXPORTING
*         ACTCLASS      = ' '
          head          = ls_head
          no_masterlang = lv_no_masterlang
          state         = 'A'
          typ           = 'E'
          version       = l_dokversion
        TABLES
          line          = lt_line.

      MESSAGE i666(01) WITH 'Update successful' 'for longtext of data element' i_rollname INTO sy-lisel. "#EC *
      CALL METHOD log_message.

      gv_translation = 'X'.
      REFRESH lt_line.
    ENDIF.

  ENDMETHOD.                    "create_dtel_docu


  METHOD create_function_group.

    DATA: l_text       LIKE i_text,
          l_tadir_name TYPE tadir-obj_name,
          l_master     TYPE progname.

    CALL METHOD set_context
      EXPORTING
        i_langu    = i_langu
        i_object   = 'FUGR'
        i_obj_name = i_area.

    CALL FUNCTION 'RPY_EXISTENCE_CHECK_FUGR'
      EXPORTING
        name      = i_area
*       LIMU_KEY  =
      EXCEPTIONS
        not_exist = 1
        OTHERS    = 2.
    IF sy-subrc EQ 0.
      "no update necessary
      MESSAGE i666(01) WITH 'No update necessary' INTO sy-lisel. "#EC *
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    CHECK testrun IS INITIAL.

    IF i_text IS INITIAL.
      l_text = i_area.
    ELSE.
      l_text = i_text.
    ENDIF.

*    CALL METHOD add_to_transport
*      EXPORTING
*        i_object   = 'FUGR'
*        i_obj_name = i_area
*        i_devclass = i_devclass
*        i_langu    = i_langu  "masterlanguage (only relevant during first call)
*      EXCEPTIONS
*        OTHERS     = 1.
*    CHECK sy-subrc EQ 0.

    "create TADIR entry in advance avoid popup
    IF i_langu CA 'ED'.
      "set correct language and package on first call per object
      "skip this for other languages than EN/DE.
      l_tadir_name = i_area.
      CALL FUNCTION 'TR_TADIR_INTERFACE'
        EXPORTING
*         WI_DELETE_TADIR_ENTRY = ' '
          wi_test_modus         = space
          wi_tadir_pgmid        = 'R3TR'
          wi_tadir_object       = 'FUGR'
          wi_tadir_obj_name     = l_tadir_name
          wi_tadir_devclass     = i_devclass
          wi_tadir_masterlang   = i_langu
        EXCEPTIONS
          OTHERS                = 25.
      IF sy-subrc <> 0.
      ENDIF.
    ENDIF.
    IF i_devclass IS NOT INITIAL.
      "set correct package in memory
      FREE MEMORY ID 'EUK'.
      SET PARAMETER ID 'EUK' FIELD i_devclass.
    ENDIF.

    "SELECT SINGLE FROM tlibg.
    "SELECT SINGLE FROM tlibt.
    CALL FUNCTION 'RS_FUNCTION_POOL_ADD'
      EXPORTING
        aktion                 = 'INSR'  "UPDA
        area                   = i_area
        corrnum                = gv_trkorr
        text                   = l_text
        uname                  = sy-uname
*       WITH_MONITOR           = ' '
*       with_korr              = ' '     "pass ' ' if add_to_transport has happend!
        save_active            = 'X'
*       WB_FB_MANAGER          =
*     IMPORTING
*       NEW_NAME               =
      EXCEPTIONS
        canceled_in_corr       = 1
        enqueue_system_failure = 2
        function_pool_exist    = 3
        not_executed           = 4
        no_modify_permission   = 5
        no_show_permission     = 6
        permission_failure     = 7
        OTHERS                 = 8.
    IF sy-subrc NE 0.
      CALL METHOD log_message.
      RETURN.
    ENDIF.

    "update TRDIR/REPOSRC/PROGRDIR
    l_master = lcl_wb=>get_function_pool_master( i_area ).

    UPDATE progdir SET appl    = i_appl
                       fixpt   = i_fixpt
                       uccheck = i_uccheck
                 WHERE name EQ l_master.

    "uodate TADIR master language
    UPDATE tadir SET masterlang = i_langu
               WHERE pgmid      EQ 'R3TR'
                 AND object     EQ 'FUGR'
                 AND obj_name   EQ i_area
                 AND masterlang NE i_langu.

    MESSAGE i666(01) WITH 'Update successful' INTO sy-lisel. "#EC *
    CALL METHOD log_message.

  ENDMETHOD.                    "create_function_group





  METHOD log_message.

    DATA: ls_msg     TYPE bal_s_msg.

    IF sy-msgno IS INITIAL OR sy-msgid IS INITIAL.
      MESSAGE i666(01) WITH 'unknown error' INTO sy-lisel.  "#EC *
    ENDIF.
    MOVE-CORRESPONDING syst TO ls_msg.

    CALL FUNCTION 'BAL_LOG_MSG_ADD'
      EXPORTING
        i_log_handle = gv_log_handle
        i_s_msg      = ls_msg
      EXCEPTIONS
        OTHERS       = 0.

  ENDMETHOD.                    "log_message

  METHOD display_log.

    DATA: lt_log_handle TYPE bal_t_logh,
          ls_profile    TYPE bal_s_prof,
          l_s_fcat      TYPE bal_s_fcat,
          lt_dfies      TYPE TABLE OF dfies,
          ls_dfies      TYPE dfies.
    DATA: ls_filter     TYPE bal_s_lfil,
          lr_filter     TYPE bal_s_extn, "range table
          lr_extnumber  TYPE bal_s_extn, "range table
          ls_s_log      TYPE bal_s_log,
          lt_log_header TYPE balhdr_t,
          lr_handle     TYPE bal_s_logh. "range table

    IF gv_log_handle IS INITIAL.

      CLEAR: ls_filter, lr_extnumber.

*- Search only log file of this application
      lr_filter-sign   = 'I'.
      lr_filter-option = 'EQ'.
      lr_filter-low    = c_bal_object.
      APPEND lr_filter TO ls_filter-object.

      lr_filter-sign   = 'I'.
      lr_filter-option = 'EQ'.
      lr_filter-low    = c_bal_subobj.
      APPEND lr_filter TO ls_filter-subobject.

*- Search only log file of this change number
      lr_extnumber-low    = sy-repid.
      lr_extnumber-sign   = 'I'.
      lr_extnumber-option = 'EQ'.
      APPEND lr_extnumber TO ls_filter-extnumber.

*-- Search for log files on the database
      CALL FUNCTION 'BAL_DB_SEARCH'
        EXPORTING
          i_s_log_filter     = ls_filter
        IMPORTING
          e_t_log_header     = lt_log_header
        EXCEPTIONS
          log_not_found      = 1
          no_filter_criteria = 2
          OTHERS             = 3.
      IF sy-subrc EQ 0.
*-- Load log files from database into memory
        CALL FUNCTION 'BAL_DB_LOAD'
          EXPORTING
            i_t_log_header     = lt_log_header
          IMPORTING
            e_t_log_handle     = lt_log_handle
          EXCEPTIONS
            no_logs_specified  = 1
            log_not_found      = 2
            log_already_loaded = 3
            OTHERS             = 4.
      ENDIF.
    ELSE.
      APPEND gv_log_handle TO lt_log_handle.
    ENDIF.

    IF 1 = 1.
      "grid
      CALL FUNCTION 'BAL_DSP_PROFILE_SINGLE_LOG_GET'
        IMPORTING
          e_s_display_profile = ls_profile
        EXCEPTIONS
          OTHERS              = 0.
      "Set profile
      ls_profile-show_all   = abap_on.
      ls_profile-use_grid   = abap_on.
      ls_profile-tree_ontop = abap_on.
      ls_profile-exp_level  = 1.
      ls_profile-mess_mark  = abap_on.
    ELSE.
      "tree
      CALL FUNCTION 'BAL_DSP_PROFILE_DETLEVEL_GET'
        IMPORTING
          e_s_display_profile = ls_profile
        EXCEPTIONS
          OTHERS              = 0.
    ENDIF.

    "add own fields to field cat
    CALL FUNCTION 'DDIF_FIELDINFO_GET'
      EXPORTING
        tabname        = c_bal_context
      TABLES
        dfies_tab      = lt_dfies
      EXCEPTIONS
        not_found      = 1
        internal_error = 2
        OTHERS         = 3.
    ASSERT sy-subrc EQ 0.

    LOOP AT lt_dfies INTO ls_dfies WHERE fieldname EQ 'OBJECT'
                                      OR fieldname EQ 'OBJ_NAME'.
      l_s_fcat-ref_table = c_bal_context.
      l_s_fcat-ref_field = ls_dfies-fieldname.
      l_s_fcat-outputlen = ls_dfies-outputlen + 1.
*      l_s_fcat-col_pos   = 100 + sy-tabix.   "most rigth columns
      APPEND l_s_fcat TO ls_profile-mess_fcat.
    ENDLOOP.


    "set parameters for saving layout.
    ls_profile-disvariant-report = sy-repid.
    ls_profile-disvariant-handle = c_bal_subobj.

    CALL FUNCTION 'BAL_DSP_LOG_DISPLAY'
      EXPORTING
        i_t_log_handle      = lt_log_handle
        i_s_display_profile = ls_profile
        i_amodal            = space
      EXCEPTIONS
        OTHERS              = 0.

    CALL FUNCTION 'BAL_DB_SAVE'
      EXPORTING
        i_t_log_handle = lt_log_handle
      EXCEPTIONS
        OTHERS         = 0.

  ENDMETHOD.                    "display_log

  METHOD set_context.

    STATICS: BEGIN OF lss_key, "save last key
               i_object    TYPE e071-object,
               i_obj_name  TYPE adir_key-obj_name,
               i_obj_name2 TYPE adir_key-obj_name,
               i_text      TYPE string,
               i_langu     TYPE sylangu,
             END OF lss_key.

    DATA: ls_msg_defaults TYPE bal_s_mdef,
          ls_context      TYPE adir_key,
          ls_object_text  TYPE ko100,
          ls_doktype      TYPE dd07v,
          l_text(70),
          l_mode          TYPE string,
          ls_key          LIKE lss_key.

    DATA: ls_e071      TYPE e071,
          ls_tadir     TYPE tadir,
          ls_tadir_key TYPE tadir.

    ls_key-i_object    = i_object.
    ls_key-i_obj_name  = i_obj_name.
    ls_key-i_obj_name2 = i_obj_name2.
    ls_key-i_text      = i_text.
    ls_key-i_langu     = i_langu.
    IF ls_key EQ lss_key. "check last key
      "avoid double message like "add field to table"
      RETURN.
    ELSE.
      lss_key = ls_key.
    ENDIF.

    ls_context-object   = i_object.
    CONCATENATE i_obj_name i_obj_name2 INTO ls_context-obj_name.
    ls_msg_defaults-log_handle      = gv_log_handle.
    ls_msg_defaults-context-value   = ls_context.
    ls_msg_defaults-context-tabname = c_bal_context.

    CALL FUNCTION 'BAL_GLB_MSG_DEFAULTS_SET'
      EXPORTING
        i_s_msg_defaults = ls_msg_defaults
      EXCEPTIONS
        OTHERS           = 0.

    "try to check if object exists
    IF i_obj_name IS NOT INITIAL.
      ls_e071-pgmid    = 'R3TR'.
      ls_e071-object   = i_object.
      ls_e071-obj_name = i_obj_name.

      CALL FUNCTION 'SCWB_GET_TADIR_REM'
        EXPORTING
          is_e071      = ls_e071
        IMPORTING
          es_tadir_key = ls_tadir_key
          es_tadir     = ls_tadir.
      IF ls_tadir_key IS INITIAL.
        ls_e071-pgmid   = 'LIMU'.
        CALL FUNCTION 'SCWB_GET_TADIR_REM'
          EXPORTING
            is_e071      = ls_e071
          IMPORTING
            es_tadir_key = ls_tadir_key
            es_tadir     = ls_tadir.
      ENDIF.

      IF ls_tadir IS INITIAL.
        l_mode = 'Create'.                                  "#EC NOTEXT
      ELSE.
        l_mode = 'Change'.                                  "#EC NOTEXT
        "check if object has been manually modified by customer.
        SELECT COUNT( * ) FROM adiraccess WHERE pgmid    EQ ls_tadir-pgmid
                                            AND object   EQ ls_tadir-object
                                            AND obj_name EQ ls_tadir-obj_name.
        IF sy-dbcnt NE 0.
          MESSAGE w666(01) WITH ls_tadir-object ls_tadir-obj_name 'was manually changed before.' 'Please adjust manually afterwards' INTO sy-lisel. "#EC *
          CALL METHOD log_message.
        ENDIF.
      ENDIF.
    ENDIF.

    IF i_text IS INITIAL.
      CALL METHOD get_object_text
        EXPORTING
          i_object   = i_object
          i_obj_name = i_obj_name
        RECEIVING
          r_text     = l_text.

      CONCATENATE l_mode l_text INTO l_text SEPARATED BY space.
    ELSE.
      l_text = i_text.
    ENDIF.

    IF l_text IS NOT INITIAL.
      IF i_langu IS NOT INITIAL.
        MESSAGE s666(01) WITH l_text '( language' i_langu ')' INTO l_text.
      ENDIF.
      CALL FUNCTION 'BAL_LOG_MSG_ADD_FREE_TEXT'
        EXPORTING
          i_msgty = 'I'
          i_text  = l_text
        EXCEPTIONS
          OTHERS  = 0.
    ENDIF.

  ENDMETHOD.                    "set_context

  METHOD support_pack_applied.

    DATA: lt_trkorr TYPE TABLE OF trkorr.

    SPLIT i_trkorr_list AT space INTO TABLE lt_trkorr.
    SELECT COUNT( * ) FROM e070 UP TO 1 ROWS
                      FOR ALL ENTRIES IN lt_trkorr
                      WHERE trkorr EQ lt_trkorr-table_line.
    IF sy-subrc EQ 0.
      r_applied = 'X'.
    ENDIF.

  ENDMETHOD.                    "support_pack_applied

  METHOD software_comp_applied.
    CLEAR e_cvers.
    SELECT SINGLE * FROM cvers
                    INTO e_cvers
                    WHERE component = i_component.
    IF sy-subrc IS NOT INITIAL.
      RAISE not_applied.
    ENDIF.
  ENDMETHOD.                    "software_comp_applied


ENDCLASS.                    "lcl_wb IMPLEMENTATION


START-OF-SELECTION.
  PERFORM action.

*&---------------------------------------------------------------------*
FORM action.

  CALL METHOD lcl_wb=>init                                  "#EC *
*    EXPORTING
*       i_trkorr_list = '<list of supportpacks which delivers the objects anyway. Take from CSS note tab support packages>'
*       i_component   = '<software comp. of objects to be created by this report>'
     EXCEPTIONS
        stop_processing = 1
        OTHERS          = 2.
  IF sy-subrc EQ 0.

    APPEND 'SEPA_RC_CUST'                           TO gt_tabname.
    APPEND 'SEPA_RC_CUST_TXT'                       TO gt_tabname.
    APPEND 'SEPA_STATUS_CUST'                       TO gt_tabname.
    APPEND 'SEPA_S_ADMIN_EXT'                       TO gt_tabname.
    APPEND 'SEPA_S_ADMIN_INT'                       TO gt_tabname.

    "- DOMA DOMD ---------------------------------------------------------------------------- Domains
    "-- LIMU DOMD SEPA_REASON_CODE (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_doma                         "#EC *
      EXPORTING
        i_domname    = 'SEPA_REASON_CODE'
        i_devclass   = 'BF_SEPA_EN'
        i_datatype   = 'CHAR'
        i_entitytab  = 'SEPA_RC_CUST'
        i_langu      = 'E'
        i_ddtext     = 'SEPA: Reason Code'
        i_leng       = '000003':.

    CALL METHOD lcl_wb=>create_doma                         "#EC *
      EXPORTING
        i_domname    = 'SEPA_REASON_CODE'
        i_devclass   = 'BF_SEPA_EN'
        i_datatype   = 'CHAR'
        i_entitytab  = 'SEPA_RC_CUST'
        i_langu      = 'D'
        i_ddtext     = 'SEPA: Ursachencode'
        i_leng       = '000003':.

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-001 IS INITIAL.
      DATA: l_ddtext TYPE ddtext.
      l_ddtext = 'SEPA: Reason Code'(001).
      CALL METHOD lcl_wb=>create_doma                       "#EC *
        EXPORTING
          i_domname    = 'SEPA_REASON_CODE'
          i_devclass   = 'BF_SEPA_EN'
          i_datatype   = 'CHAR'
          i_entitytab  = 'SEPA_RC_CUST'
          i_langu      = sy-langu
          i_ddtext     = l_ddtext
          i_leng       = '000003':.
    ENDIF.

    "-- LIMU DOMD SEPA_REASON_CODE_DESC (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_doma                         "#EC *
      EXPORTING
        i_domname    = 'SEPA_REASON_CODE_DESC'
        i_devclass   = 'BF_SEPA_EN'
        i_datatype   = 'CHAR'
        i_lowercase  = 'X'
        i_entitytab  = 'SEPA_RC_CUS_TXT'
        i_langu      = 'E'
        i_ddtext     = 'Description of Reason Code'
        i_leng       = '000050':.

    CALL METHOD lcl_wb=>create_doma                         "#EC *
      EXPORTING
        i_domname    = 'SEPA_REASON_CODE_DESC'
        i_devclass   = 'BF_SEPA_EN'
        i_datatype   = 'CHAR'
        i_lowercase  = 'X'
        i_entitytab  = 'SEPA_RC_CUS_TXT'
        i_langu      = 'D'
        i_ddtext     = 'Beschreibung des Ursachencodes'
        i_leng       = '000050':.

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-002 IS INITIAL.
      l_ddtext = 'Description of Reason Code'(002).
      CALL METHOD lcl_wb=>create_doma                       "#EC *
        EXPORTING
          i_domname    = 'SEPA_REASON_CODE_DESC'
          i_devclass   = 'BF_SEPA_EN'
          i_datatype   = 'CHAR'
          i_lowercase  = 'X'
          i_entitytab  = 'SEPA_RC_CUS_TXT'
          i_langu      = sy-langu
          i_ddtext     = l_ddtext
          i_leng       = '000050':.
    ENDIF.

    "- DTEL DTED ---------------------------------------------------------------------- Data elements
    "-- LIMU DTED SEPA_REASON_CODE (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_dtel                         "#EC *
      EXPORTING
        i_rollname  = 'SEPA_REASON_CODE'
        i_devclass  = 'BF_SEPA_EN'
        i_domname   = 'SEPA_REASON_CODE'
        i_logflag   = ''
        i_headlen   = '15'
        i_scrlen1   = '10'
        i_scrlen2   = '15'
        i_scrlen3   = '20'
        i_langu     = 'E'
        i_ddtext    = 'Reason Code for Status Change'
        i_reptext   = 'ReasonForChange'
        i_scrtext_s = 'Reason'
        i_scrtext_m = 'ReasonForChange'
        i_scrtext_l = 'Reason for Change'.

    CALL METHOD lcl_wb=>create_dtel                         "#EC *
      EXPORTING
        i_rollname  = 'SEPA_REASON_CODE'
        i_devclass  = 'BF_SEPA_EN'
        i_domname   = 'SEPA_REASON_CODE'
        i_logflag   = ''
        i_headlen   = '15'
        i_scrlen1   = '10'
        i_scrlen2   = '15'
        i_scrlen3   = '20'
        i_langu     = 'D'
        i_ddtext    = 'Ursachencode für Statusänderung'
        i_reptext   = 'Änderungsgrund'
        i_scrtext_s = 'Grund'
        i_scrtext_m = 'Änderungsgrund'
        i_scrtext_l = 'Änderungsgrund'.

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-003 IS INITIAL.
      DATA: l_reptext   TYPE reptext,
            l_scrtext_m TYPE scrtext_m,
            l_scrtext_l TYPE scrtext_l,
            l_scrtext_s TYPE scrtext_s.
      l_ddtext    = 'Reason Code for Status Change'(003).
      l_reptext   = 'ReasonForChange'(004).
      l_scrtext_s = 'Reason'(005).
      l_scrtext_m = 'ReasonForChange'(004).
      l_scrtext_l = 'Reason for Change'(006).
      CALL METHOD lcl_wb=>create_dtel                       "#EC *
        EXPORTING
          i_rollname  = 'SEPA_REASON_CODE'
          i_devclass  = 'BF_SEPA_EN'
          i_domname   = 'SEPA_REASON_CODE'
          i_logflag   = ''
          i_headlen   = '15'
          i_scrlen1   = '10'
          i_scrlen2   = '15'
          i_scrlen3   = '20'
          i_langu     = sy-langu
          i_ddtext    = l_ddtext
          i_reptext   = l_reptext
          i_scrtext_s = l_scrtext_s
          i_scrtext_m = l_scrtext_m
          i_scrtext_l = l_scrtext_l.
    ENDIF.

    "-- LIMU DOCU DESEPA_REASON_CODE (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_dtel_docu                    "#EC *
      EXPORTING
        i_rollname  = 'SEPA_REASON_CODE'
        i_langu     = 'E'
        i_line      =:'U1 &DEFINITION&',
                      'AS Describes the reason for changing mandate status.',
                      'U1 &USE&',
                      'AS The reason code explains why the status of a mandate has been changed.',
                      '   You can choose a reason code when you create or change a mandate.',
                      'U1 &DEPENDENCIES&',
                      'AS',
                      'U1 &EXAMPLE&',
                      'AS You have defined the following reason codes for changing to status',
                      '   Locked:',
                      'K1 Reason Code,,Description',
                      'T1 ,,Choose a reason code',
                      'T1 01,,Direct debit failed',
                      'T1 02,,Customer called',
                      'T1 03,,Customer letter attached',
                      'AS When you change the mandate status to Locked, the default reason code',
                      '   the system chooses for the change depends on the Customizing for reason',
                      '   codes:',
                      'B1 If the reason code for the previous status also exists for the current',
                      '   status, the system continues to use this reason code.',
                      'B1 If the reason code for the previous status does not exist for the',
                      '   current status, the system chooses the empty reason code, which in this',
                      '   example prompts you to choose a reason code.',
                      'U1 Customizing',
                      'AS You define the reason codes for changing mandate status in transaction',
                      '   <DS:TRAS.SEPA_RC_CUST>SEPA_RC_CUST</>.',
                      space.

    CALL METHOD lcl_wb=>create_dtel_docu                    "#EC *
      EXPORTING
        i_rollname  = 'SEPA_REASON_CODE'
        i_langu     = 'D'
        i_line      =:'U1 &DEFINITION&',
                      'AS Beschreibt den Grund für die Änderung des Mandatsstatus.',
                      'U1 &USE&',
                      'AS Der Ursachencode erklärt, warum der Status eines Mandats geändert wurde.',
                      '   Sie können einen Ursachencode auswählen, wenn Sie ein Mandat anlegen',
                      '   oder ändern.',
                      'U1 &DEPENDENCIES&',
                      'AS',
                      'U1 &EXAMPLE&',
                      'AS Sie haben die folgenden Ursachencodes für das Wechseln in den Status',
                      '   Gesperrt definiert:',
                      'K1 Ursachencode,,Beschreibung',
                      'T1 ,,Wählen Sie einen Ursachencode aus',
                      'T1 01,,Lastschriftverfahren fehlgeschlagen',
                      'T1 02,,Kundenanruf',
                      'T1 03,,Kundenbrief im Anhang',
                      'AS Wenn Sie den Mandatsstatus in Gesperrt ändern, wählt das System für die',
                      '   Änderung den Ursachencode in Abhängigkeit vom Customizing für die',
                      '   Ursachencodes aus:',
                      'B1 Wenn der Ursachencode für den vorherigen Status auch für den aktuellen',
                      '   Status vorhanden ist, verwendet das System diesen Ursachencode',
                      '   weiterhin.',
                      'B1 Wenn der Ursachencode für den vorherigen Status für den aktuellen Status',
                      '   nicht vorhanden ist, verwendet das System den leeren Ursachencode, der',
                      '   Sie in diesem Beispiel dazu auffordert, einen Ursachencode auszuwählen.',
                      'U1 Customizing',
                      'AS Die Ursachencodes für die Änderung des Mandatsstatus definieren Sie in',
                      '   Transaktion <DS:TRAS.SEPA_RC_CUST>SEPA_RC_CUST</>.',
                      space.

    "-- LIMU DTED SEPA_REASON_CODE_DESC (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_dtel                         "#EC *
      EXPORTING
        i_rollname  = 'SEPA_REASON_CODE_DESC'
        i_devclass  = 'BF_SEPA_EN'
        i_domname   = 'SEPA_REASON_CODE_DESC'
        i_logflag   = ''
        i_headlen   = '00'
        i_scrlen1   = '10'
        i_scrlen2   = '15'
        i_scrlen3   = '30'
        i_langu     = 'E'
        i_ddtext    = 'Description of Reason for Status Change'
        i_reptext   = ''
        i_scrtext_s = 'Desc.'
        i_scrtext_m = 'Description'
        i_scrtext_l = 'Description'.

    CALL METHOD lcl_wb=>create_dtel                         "#EC *
      EXPORTING
        i_rollname  = 'SEPA_REASON_CODE_DESC'
        i_devclass  = 'BF_SEPA_EN'
        i_domname   = 'SEPA_REASON_CODE_DESC'
        i_logflag   = ''
        i_headlen   = '00'
        i_scrlen1   = '10'
        i_scrlen2   = '15'
        i_scrlen3   = '30'
        i_langu     = 'D'
        i_ddtext    = 'Beschreibung des Grunds für die Statusänderung'
        i_reptext   = ''
        i_scrtext_s = 'Beschreib.'
        i_scrtext_m = 'Beschreibung'
        i_scrtext_l = 'Beschreibung'.

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-007 IS INITIAL.
      l_ddtext    = 'Description of Reason for Status Change'(007).
      l_reptext   = ''.
      l_scrtext_s = 'Desc.'(008).
      l_scrtext_m = 'Description'(009).
      l_scrtext_l = 'Description'(010).
      CALL METHOD lcl_wb=>create_dtel                       "#EC *
        EXPORTING
          i_rollname  = 'SEPA_REASON_CODE_DESC'
          i_devclass  = 'BF_SEPA_EN'
          i_domname   = 'SEPA_REASON_CODE_DESC'
          i_logflag   = ''
          i_headlen   = '00'
          i_scrlen1   = '10'
          i_scrlen2   = '15'
          i_scrlen3   = '30'
          i_langu     = sy-langu
          i_ddtext    = l_ddtext
          i_reptext   = ''
          i_scrtext_s = l_scrtext_s
          i_scrtext_m = l_scrtext_m
          i_scrtext_l = l_scrtext_l.
    ENDIF.

    "- TABL TABD ----------------------------------------------------------------------------- Tables
    "-- LIMU TABD SEPA_RC_CUST (language: EN , source: SI3 )
    DATA: lt_dd36  TYPE TABLE OF dd36m, ls_dd36 TYPE dd36m,
          lt_dd05m TYPE TABLE OF dd05m, ls_dd05m TYPE dd05m,
          ls_dd08v TYPE dd08v.

    CALL METHOD lcl_wb=>create_table                        "#EC *
      EXPORTING
        i_tabname    = 'SEPA_RC_CUST'
        i_devclass   = 'BF_SEPA_EN'
        i_exclass    = '1'
        i_authclass  = '00'
        i_tabclass   = 'TRANSP'
        i_contflag   = 'C'
        i_tabkat     = '0'
        i_tabart     = 'APPL0'
        i_bufallow   = 'X'
        i_pufferung  = 'X'
        i_schfeldanz = '000'
        i_speichpuff = ''
        i_langu      = 'E'
        i_ddtext     = 'SEPA Mandate: Customizing for Reason Code'.

    CALL METHOD lcl_wb=>create_table                        "#EC *
      EXPORTING
        i_tabname    = 'SEPA_RC_CUST'
        i_devclass   = 'BF_SEPA_EN'
        i_exclass    = '1'
        i_authclass  = '00'
        i_tabclass   = 'TRANSP'
        i_contflag   = 'C'
        i_tabkat     = '0'
        i_tabart     = 'APPL0'
        i_bufallow   = 'X'
        i_pufferung  = 'X'
        i_schfeldanz = '000'
        i_speichpuff = ''
        i_langu      = 'D'
        i_ddtext     = 'SEPA-Mandate: Einstellungen des Ursachencodes'.

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-011 IS INITIAL.
      l_ddtext = 'SEPA Mandate: Customizing for Reason Code'(011).
      CALL METHOD lcl_wb=>create_table                      "#EC *
        EXPORTING
          i_tabname    = 'SEPA_RC_CUST'
          i_devclass   = 'BF_SEPA_EN'
          i_exclass    = '1'
          i_authclass  = '00'
          i_tabclass   = 'TRANSP'
          i_contflag   = 'C'
          i_tabkat     = '0'
          i_tabart     = 'APPL0'
          i_bufallow   = 'X'
          i_pufferung  = 'X'
          i_schfeldanz = '000'
          i_speichpuff = ''
          i_langu      = sy-langu
          i_ddtext     = l_ddtext.
    ENDIF.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_RC_CUST'
        i_fieldname = 'MANDT'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'MANDT'
        i_context   = ''.

    CLEAR ls_dd08v.
    ls_dd08v-tabname    = 'SEPA_RC_CUST'.
    ls_dd08v-fieldname  = 'APPLICATION'.
    ls_dd08v-tabname    = 'SEPA_RC_CUST'.
    ls_dd08v-fieldname  = 'APPLICATION'.
    ls_dd08v-checktable = 'SEPA_CTRL'.

    REFRESH lt_dd05m.
    CLEAR ls_dd05m.
    ls_dd05m-tabname    = 'SEPA_RC_CUST'.
    ls_dd05m-fieldname  = 'APPLICATION'.
    ls_dd05m-fortable   = 'SEPA_RC_CUST'.
    ls_dd05m-forkey     = 'APPLICATION'.
    ls_dd05m-checktable = 'SEPA_CTRL'.
    ls_dd05m-checkfield = 'ANWND'.
    ls_dd05m-primpos    = '0001'.
    APPEND ls_dd05m TO lt_dd05m.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_RC_CUST'
        i_fieldname = 'APPLICATION'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'SEPA_ANWND'
        is_dd08v    = ls_dd08v
        it_dd05m    = lt_dd05m
        i_context   = 'MANDT'.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_RC_CUST'
        i_fieldname = 'STATUS'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'SEPA_STATUS'
        i_context   = 'APPLICATION'.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_RC_CUST'
        i_fieldname = 'REASON_CODE'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'SEPA_REASON_CODE'
        i_context   = 'STATUS'.

    "-- LIMU TABD SEPA_RC_CUST_TXT (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_table                        "#EC *
      EXPORTING
        i_tabname    = 'SEPA_RC_CUST_TXT'
        i_devclass   = 'BF_SEPA_EN'
        i_exclass    = '1'
        i_authclass  = '00'
        i_tabclass   = 'TRANSP'
        i_contflag   = 'C'
        i_tabkat     = '0'
        i_tabart     = 'APPL0'
        i_bufallow   = 'X'
        i_pufferung  = 'X'
        i_schfeldanz = '000'
        i_speichpuff = ''
        i_langu      = 'E'
        i_ddtext     = 'SEPA Mandate: Text table for Reason Code'.

    CALL METHOD lcl_wb=>create_table                        "#EC *
      EXPORTING
        i_tabname    = 'SEPA_RC_CUST_TXT'
        i_devclass   = 'BF_SEPA_EN'
        i_exclass    = '1'
        i_authclass  = '00'
        i_tabclass   = 'TRANSP'
        i_contflag   = 'C'
        i_tabkat     = '0'
        i_tabart     = 'APPL0'
        i_bufallow   = 'X'
        i_pufferung  = 'X'
        i_schfeldanz = '000'
        i_speichpuff = ''
        i_langu      = 'D'
        i_ddtext     = 'SEPA-Mandate: Texte für den Ursachencode'.

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-012 IS INITIAL.
      l_ddtext = 'SEPA Mandate: Text table for Reason Code'(012).
      CALL METHOD lcl_wb=>create_table                      "#EC *
        EXPORTING
          i_tabname    = 'SEPA_RC_CUST_TXT'
          i_devclass   = 'BF_SEPA_EN'
          i_exclass    = '1'
          i_authclass  = '00'
          i_tabclass   = 'TRANSP'
          i_contflag   = 'C'
          i_tabkat     = '0'
          i_tabart     = 'APPL0'
          i_bufallow   = 'X'
          i_pufferung  = 'X'
          i_schfeldanz = '000'
          i_speichpuff = ''
          i_langu      = sy-langu
          i_ddtext     = l_ddtext.
    ENDIF.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_RC_CUST_TXT'
        i_fieldname = 'MANDT'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'MANDT'
        i_context   = ''.

    CLEAR ls_dd08v.
    ls_dd08v-tabname    = 'SEPA_RC_CUST_TXT'.
    ls_dd08v-fieldname  = 'APPLICATION'.
    ls_dd08v-tabname    = 'SEPA_RC_CUST_TXT'.
    ls_dd08v-fieldname  = 'APPLICATION'.
    ls_dd08v-checktable = 'SEPA_CTRL'.

    REFRESH lt_dd05m.
    CLEAR ls_dd05m.
    ls_dd05m-tabname    = 'SEPA_RC_CUST_TXT'.
    ls_dd05m-fieldname  = 'APPLICATION'.
    ls_dd05m-fortable   = 'SEPA_RC_CUST_TXT'.
    ls_dd05m-forkey     = 'APPLICATION'.
    ls_dd05m-checktable = 'SEPA_CTRL'.
    ls_dd05m-checkfield = 'ANWND'.
    ls_dd05m-primpos    = '0001'.
    APPEND ls_dd05m TO lt_dd05m.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_RC_CUST_TXT'
        i_fieldname = 'APPLICATION'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'SEPA_ANWND'
        is_dd08v    = ls_dd08v
        it_dd05m    = lt_dd05m
        i_context   = 'MANDT'.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_RC_CUST_TXT'
        i_fieldname = 'STATUS'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'SEPA_STATUS'
        i_context   = 'APPLICATION'.

    CLEAR ls_dd08v.
    ls_dd08v-tabname    = 'SEPA_RC_CUST_TXT'.
    ls_dd08v-fieldname  = 'REASON_CODE'.
    ls_dd08v-tabname    = 'SEPA_RC_CUST_TXT'.
    ls_dd08v-fieldname  = 'REASON_CODE'.
    ls_dd08v-checktable = 'SEPA_RC_CUST'.
    ls_dd08v-frkart     = 'TEXT'.
    ls_dd08v-card       = 'CN'.
    ls_dd08v-cardleft   = '1'.

    REFRESH lt_dd05m.
    CLEAR ls_dd05m.
    ls_dd05m-tabname    = 'SEPA_RC_CUST_TXT'.
    ls_dd05m-fieldname  = 'REASON_CODE'.
    ls_dd05m-fortable   = 'SEPA_RC_CUST_TXT'.
    ls_dd05m-forkey     = 'MANDT'.
    ls_dd05m-checktable = 'SEPA_RC_CUST'.
    ls_dd05m-checkfield = 'MANDT'.
    ls_dd05m-primpos    = '0001'.
    APPEND ls_dd05m TO lt_dd05m.

    CLEAR ls_dd05m.
    ls_dd05m-tabname    = 'SEPA_RC_CUST_TXT'.
    ls_dd05m-fieldname  = 'REASON_CODE'.
    ls_dd05m-fortable   = 'SEPA_RC_CUST_TXT'.
    ls_dd05m-forkey     = 'APPLICATION'.
    ls_dd05m-checktable = 'SEPA_RC_CUST'.
    ls_dd05m-checkfield = 'APPLICATION'.
    ls_dd05m-primpos    = '0002'.
    APPEND ls_dd05m TO lt_dd05m.

    CLEAR ls_dd05m.
    ls_dd05m-tabname    = 'SEPA_RC_CUST_TXT'.
    ls_dd05m-fieldname  = 'REASON_CODE'.
    ls_dd05m-fortable   = 'SEPA_RC_CUST_TXT'.
    ls_dd05m-forkey     = 'STATUS'.
    ls_dd05m-checktable = 'SEPA_RC_CUST'.
    ls_dd05m-checkfield = 'STATUS'.
    ls_dd05m-primpos    = '0003'.
    APPEND ls_dd05m TO lt_dd05m.

    CLEAR ls_dd05m.
    ls_dd05m-tabname    = 'SEPA_RC_CUST_TXT'.
    ls_dd05m-fieldname  = 'REASON_CODE'.
    ls_dd05m-fortable   = 'SEPA_RC_CUST_TXT'.
    ls_dd05m-forkey     = 'REASON_CODE'.
    ls_dd05m-checktable = 'SEPA_RC_CUST'.
    ls_dd05m-checkfield = 'REASON_CODE'.
    ls_dd05m-primpos    = '0004'.
    APPEND ls_dd05m TO lt_dd05m.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_RC_CUST_TXT'
        i_fieldname = 'REASON_CODE'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'SEPA_REASON_CODE'
        is_dd08v    = ls_dd08v
        it_dd05m    = lt_dd05m
        i_context   = 'STATUS'.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_RC_CUST_TXT'
        i_fieldname = 'SPRAS'
        i_keyflag   = 'X'
        i_languflag = 'X'
        i_notnull   = 'X'
        i_rollname  = 'SPRAS'
        i_context   = 'REASON_CODE'.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_RC_CUST_TXT'
        i_fieldname = 'DESCRIPTION'
        i_rollname  = 'SEPA_REASON_CODE_DESC'
        i_context   = 'SPRAS'.

    "-- LIMU TABD SEPA_STATUS_CUST (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_table                        "#EC *
      EXPORTING
        i_tabname    = 'SEPA_STATUS_CUST'
        i_devclass   = 'BF_SEPA_EN'
        i_exclass    = '1'
        i_authclass  = '00'
        i_tabclass   = 'TRANSP'
        i_contflag   = 'C'
        i_tabkat     = '0'
        i_tabart     = 'APPL0'
        i_bufallow   = 'X'
        i_pufferung  = 'X'
        i_schfeldanz = '000'
        i_speichpuff = ''
        i_protokoll  = 'X'
        i_langu      = 'E'
        i_ddtext     = 'SEPA Mandate: Customizing for Status Transition'.

    CALL METHOD lcl_wb=>create_table                        "#EC *
      EXPORTING
        i_tabname    = 'SEPA_STATUS_CUST'
        i_devclass   = 'BF_SEPA_EN'
        i_exclass    = '1'
        i_authclass  = '00'
        i_tabclass   = 'TRANSP'
        i_contflag   = 'C'
        i_tabkat     = '0'
        i_tabart     = 'APPL0'
        i_bufallow   = 'X'
        i_pufferung  = 'X'
        i_schfeldanz = '000'
        i_speichpuff = ''
        i_protokoll  = 'X'
        i_langu      = 'D'
        i_ddtext     = 'SEPA-Mandate: Einstellungen der Statusübergänge'.

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-013 IS INITIAL.
      l_ddtext = 'SEPA Mandate: Customizing for Status Transition'(013).
      CALL METHOD lcl_wb=>create_table                      "#EC *
        EXPORTING
          i_tabname    = 'SEPA_STATUS_CUST'
          i_devclass   = 'BF_SEPA_EN'
          i_exclass    = '1'
          i_authclass  = '00'
          i_tabclass   = 'TRANSP'
          i_contflag   = 'C'
          i_tabkat     = '0'
          i_tabart     = 'APPL0'
          i_bufallow   = 'X'
          i_pufferung  = 'X'
          i_schfeldanz = '000'
          i_speichpuff = ''
          i_protokoll  = 'X'
          i_langu      = sy-langu
          i_ddtext     = l_ddtext.
    ENDIF.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_STATUS_CUST'
        i_fieldname = 'MANDT'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'MANDT'
        i_context   = ''.

    CLEAR ls_dd08v.
    ls_dd08v-tabname    = 'SEPA_STATUS_CUST'.
    ls_dd08v-fieldname  = 'ANWND'.
    ls_dd08v-tabname    = 'SEPA_STATUS_CUST'.
    ls_dd08v-fieldname  = 'ANWND'.
    ls_dd08v-checktable = 'SEPA_CTRL'.

    REFRESH lt_dd05m.
    CLEAR ls_dd05m.
    ls_dd05m-tabname    = 'SEPA_STATUS_CUST'.
    ls_dd05m-fieldname  = 'ANWND'.
    ls_dd05m-fortable   = 'SEPA_STATUS_CUST'.
    ls_dd05m-forkey     = 'ANWND'.
    ls_dd05m-checktable = 'SEPA_CTRL'.
    ls_dd05m-checkfield = 'ANWND'.
    ls_dd05m-primpos    = '0001'.
    APPEND ls_dd05m TO lt_dd05m.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_STATUS_CUST'
        i_fieldname = 'ANWND'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'SEPA_ANWND'
        is_dd08v    = ls_dd08v
        it_dd05m    = lt_dd05m
        i_context   = 'MANDT'.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_STATUS_CUST'
        i_fieldname = 'STATUS'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'SEPA_STATUS'
        i_context   = 'ANWND'.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_STATUS_CUST'
        i_fieldname = 'UNALLOWED_STATUS'
        i_keyflag   = 'X'
        i_notnull   = 'X'
        i_rollname  = 'SEPA_STATUS'
        i_context   = 'STATUS'.

    "-- LIMU TABD SEPA_S_ADMIN_EXT (language: DE , source: SI3 )
    CLEAR ls_dd08v.
    ls_dd08v-tabname    = 'SEPA_S_ADMIN_EXT'.
    ls_dd08v-fieldname  = 'REASON_CODE'.
    ls_dd08v-tabname    = 'SEPA_S_ADMIN_EXT'.
    ls_dd08v-fieldname  = 'REASON_CODE'.
    ls_dd08v-checktable = 'SEPA_RC_CUST'.
    ls_dd08v-clasfield  = '*'.

    REFRESH lt_dd05m.
    CLEAR ls_dd05m.
    ls_dd05m-tabname    = 'SEPA_S_ADMIN_EXT'.
    ls_dd05m-fieldname  = 'REASON_CODE'.
    ls_dd05m-fortable   = 'SYST'.
    ls_dd05m-forkey     = 'MANDT'.
    ls_dd05m-checktable = 'SEPA_RC_CUST'.
    ls_dd05m-checkfield = 'MANDT'.
    ls_dd05m-primpos    = '0001'.
    APPEND ls_dd05m TO lt_dd05m.

    CLEAR ls_dd05m.
    ls_dd05m-tabname    = 'SEPA_S_ADMIN_EXT'.
    ls_dd05m-fieldname  = 'REASON_CODE'.
    ls_dd05m-fortable   = '*'.
    ls_dd05m-checktable = 'SEPA_RC_CUST'.
    ls_dd05m-checkfield = 'APPLICATION'.
    ls_dd05m-primpos    = '0002'.
    APPEND ls_dd05m TO lt_dd05m.

    CLEAR ls_dd05m.
    ls_dd05m-tabname    = 'SEPA_S_ADMIN_EXT'.
    ls_dd05m-fieldname  = 'REASON_CODE'.
    ls_dd05m-fortable   = 'SEPA_S_ADMIN_EXT'.
    ls_dd05m-forkey     = 'STATUS'.
    ls_dd05m-checktable = 'SEPA_RC_CUST'.
    ls_dd05m-checkfield = 'STATUS'.
    ls_dd05m-primpos    = '0003'.
    APPEND ls_dd05m TO lt_dd05m.

    CLEAR ls_dd05m.
    ls_dd05m-tabname    = 'SEPA_S_ADMIN_EXT'.
    ls_dd05m-fieldname  = 'REASON_CODE'.
    ls_dd05m-fortable   = 'SEPA_S_ADMIN_EXT'.
    ls_dd05m-forkey     = 'REASON_CODE'.
    ls_dd05m-checktable = 'SEPA_RC_CUST'.
    ls_dd05m-checkfield = 'REASON_CODE'.
    ls_dd05m-primpos    = '0004'.
    APPEND ls_dd05m TO lt_dd05m.

    CALL METHOD lcl_wb=>add_field_to_table                  "#EC *
      EXPORTING
        i_tabname   = 'SEPA_S_ADMIN_EXT'
        i_fieldname = 'REASON_CODE'
        i_rollname  = 'SEPA_REASON_CODE'
        is_dd08v    = ls_dd08v
        it_dd05m    = lt_dd05m
        i_context   = 'B2B'.

    "- VIEW VIED ------------------------------------------------------------------------------ Views
    "-- LIMU VIED V_SEPA_RC (language: EN , source: SI3 )
    DATA: ls_dd26v TYPE dd26v, lt_dd26v TYPE TABLE OF dd26v.
    DATA: ls_dd27p TYPE dd28j, lt_dd27p TYPE TABLE OF dd28j.
    DATA: ls_dd28v TYPE dd28v, lt_dd28v TYPE TABLE OF dd28v.

    CLEAR: lt_dd26v, lt_dd27p, lt_dd28v.
    CLEAR ls_dd26v.
    ls_dd26v-viewname   = 'V_SEPA_RC'.
    ls_dd26v-tabname    = 'SEPA_RC_CUST'.
    ls_dd26v-tabpos     = '0001'.
    ls_dd26v-fortabname = 'SEPA_RC_CUST'.
    APPEND ls_dd26v TO lt_dd26v.

    CLEAR ls_dd26v.
    ls_dd26v-viewname   = 'V_SEPA_RC'.
    ls_dd26v-tabname    = 'SEPA_RC_CUST_TXT'.
    ls_dd26v-tabpos     = '0002'.
    ls_dd26v-fortabname = 'SEPA_RC_CUST'.
    ls_dd26v-forfield   = 'REASON_CODE'.
    ls_dd26v-fordir     = 'I'.
    APPEND ls_dd26v TO lt_dd26v.

    CALL METHOD lcl_wb=>create_view                         "#EC *
      EXPORTING
        i_viewname   = 'V_SEPA_RC'
        i_devclass   = 'BF_SEPA_EN'
        i_langu      = 'E'
        i_ddtext     = 'SEPA Mandate: Reason for Status Change'
        i_aggtype    = 'V'
        i_roottab    = 'SEPA_RC_CUST'
        i_viewclass  = 'C'
        i_viewgrant  = ''
        i_globalflag = 'X'
        it_dd26v     = lt_dd26v[]
        it_dd28v     = lt_dd28v[].

    CALL METHOD lcl_wb=>create_view                         "#EC *
      EXPORTING
        i_viewname   = 'V_SEPA_RC'
        i_devclass   = 'BF_SEPA_EN'
        i_langu      = 'D'
        i_ddtext     = 'SEPA-Mandate: Grund für Statusänderung'
        i_aggtype    = 'V'
        i_roottab    = 'SEPA_RC_CUST'
        i_viewclass  = 'C'
        i_viewgrant  = ''
        i_globalflag = 'X'
        it_dd26v     = lt_dd26v[]
        it_dd28v     = lt_dd28v[].

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-014 IS INITIAL.
      l_ddtext = 'SEPA Mandate: Reason for Status Change'(014).
      CALL METHOD lcl_wb=>create_view                       "#EC *
        EXPORTING
          i_viewname   = 'V_SEPA_RC'
          i_devclass   = 'BF_SEPA_EN'
          i_langu      = sy-langu
          i_ddtext     = l_ddtext
          i_aggtype    = 'V'
          i_roottab    = 'SEPA_RC_CUST'
          i_viewclass  = 'C'
          i_viewgrant  = ''
          i_globalflag = 'X'
          it_dd26v     = lt_dd26v[]
          it_dd28v     = lt_dd28v[].
    ENDIF.

    CALL METHOD lcl_wb=>add_field_to_view                   "#EC *
      EXPORTING
        i_viewname   = 'V_SEPA_RC'
        i_viewfield  = 'MANDT'
        i_tabname    = 'SEPA_RC_CUST'
        i_fieldname  = 'MANDT'
        i_rollname   = 'MANDT'
        i_context    = ''.

    CALL METHOD lcl_wb=>add_field_to_view                   "#EC *
      EXPORTING
        i_viewname   = 'V_SEPA_RC'
        i_viewfield  = 'APPLICATION'
        i_tabname    = 'SEPA_RC_CUST'
        i_fieldname  = 'APPLICATION'
        i_rollname   = 'SEPA_ANWND'
        i_context    = 'MANDT'.

    CALL METHOD lcl_wb=>add_field_to_view                   "#EC *
      EXPORTING
        i_viewname   = 'V_SEPA_RC'
        i_viewfield  = 'STATUS'
        i_tabname    = 'SEPA_RC_CUST'
        i_fieldname  = 'STATUS'
        i_rollname   = 'SEPA_STATUS'
        i_context    = 'APPLICATION'.

    CALL METHOD lcl_wb=>add_field_to_view                   "#EC *
      EXPORTING
        i_viewname   = 'V_SEPA_RC'
        i_viewfield  = 'REASON_CODE'
        i_tabname    = 'SEPA_RC_CUST'
        i_fieldname  = 'REASON_CODE'
        i_rollname   = 'SEPA_REASON_CODE'
        i_context    = 'STATUS'.

    CALL METHOD lcl_wb=>add_field_to_view                   "#EC *
      EXPORTING
        i_viewname   = 'V_SEPA_RC'
        i_viewfield  = 'DESCRIPTION'
        i_tabname    = 'SEPA_RC_CUST_TXT'
        i_fieldname  = 'DESCRIPTION'
        i_rollname   = 'SEPA_REASON_CODE_DESC'
        i_context    = 'REASON_CODE'.


    "-- LIMU VIED V_SEPA_STS_CUST (language: EN , source: SI3 )
    CLEAR: lt_dd26v, lt_dd27p, lt_dd28v.
    CLEAR ls_dd26v.
    ls_dd26v-viewname   = 'V_SEPA_STS_CUST'.
    ls_dd26v-tabname    = 'SEPA_STATUS_CUST'.
    ls_dd26v-tabpos     = '0001'.
    ls_dd26v-fortabname = 'SEPA_STATUS_CUST'.
    APPEND ls_dd26v TO lt_dd26v.

    CALL METHOD lcl_wb=>create_view                         "#EC *
      EXPORTING
        i_viewname   = 'V_SEPA_STS_CUST'
        i_devclass   = 'BF_SEPA_EN'
        i_langu      = 'E'
        i_ddtext     = 'SEPA Mandate: Unallowed Status Change'
        i_aggtype    = 'V'
        i_roottab    = 'SEPA_STATUS_CUST'
        i_viewclass  = 'C'
        i_viewgrant  = ''
        i_globalflag = 'X'
        it_dd26v     = lt_dd26v[]
        it_dd28v     = lt_dd28v[].

    CALL METHOD lcl_wb=>create_view                         "#EC *
      EXPORTING
        i_viewname   = 'V_SEPA_STS_CUST'
        i_devclass   = 'BF_SEPA_EN'
        i_langu      = 'D'
        i_ddtext     = 'SEPA-Mandate: Unzulässige Statusänderung'
        i_aggtype    = 'V'
        i_roottab    = 'SEPA_STATUS_CUST'
        i_viewclass  = 'C'
        i_viewgrant  = ''
        i_globalflag = 'X'
        it_dd26v     = lt_dd26v[]
        it_dd28v     = lt_dd28v[].

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-015 IS INITIAL.
      l_ddtext = 'SEPA Mandate: Unallowed Status Change'(015).
      CALL METHOD lcl_wb=>create_view                       "#EC *
        EXPORTING
          i_viewname   = 'V_SEPA_STS_CUST'
          i_devclass   = 'BF_SEPA_EN'
          i_langu      = sy-langu
          i_ddtext     = l_ddtext
          i_aggtype    = 'V'
          i_roottab    = 'SEPA_STATUS_CUST'
          i_viewclass  = 'C'
          i_viewgrant  = ''
          i_globalflag = 'X'
          it_dd26v     = lt_dd26v[]
          it_dd28v     = lt_dd28v[].
    ENDIF.

    CALL METHOD lcl_wb=>add_field_to_view                   "#EC *
      EXPORTING
        i_viewname   = 'V_SEPA_STS_CUST'
        i_viewfield  = 'MANDT'
        i_tabname    = 'SEPA_STATUS_CUST'
        i_fieldname  = 'MANDT'
        i_rollname   = 'MANDT'
        i_context    = ''.

    CALL METHOD lcl_wb=>add_field_to_view                   "#EC *
      EXPORTING
        i_viewname   = 'V_SEPA_STS_CUST'
        i_viewfield  = 'ANWND'
        i_tabname    = 'SEPA_STATUS_CUST'
        i_fieldname  = 'ANWND'
        i_rollname   = 'SEPA_ANWND'
        i_context    = 'MANDT'.

    CALL METHOD lcl_wb=>add_field_to_view                   "#EC *
      EXPORTING
        i_viewname   = 'V_SEPA_STS_CUST'
        i_viewfield  = 'STATUS'
        i_tabname    = 'SEPA_STATUS_CUST'
        i_fieldname  = 'STATUS'
        i_rollname   = 'SEPA_STATUS'
        i_context    = 'ANWND'.

    CALL METHOD lcl_wb=>add_field_to_view                   "#EC *
      EXPORTING
        i_viewname   = 'V_SEPA_STS_CUST'
        i_viewfield  = 'UNALLOWED_STATUS'
        i_tabname    = 'SEPA_STATUS_CUST'
        i_fieldname  = 'UNALLOWED_STATUS'
        i_rollname   = 'SEPA_STATUS'
        i_context    = 'STATUS'.

    "- MSAG ------------------------------------------------------------------------- Message Classes
    "-- LIMU MSAD SEPA_EN (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_message_class                "#EC *
      EXPORTING
        i_devclass  = 'BF_SEPA_EN'
        i_msgid     = 'SEPA_EN'
        i_text      = 'SEPA_EN'
        i_langu     = 'E'.

    "-- LIMU MESS SEPA_EN001 (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '001':
        i_langu     = 'E'
        i_selfdef   = ''
        i_text      = 'Cannot change status of mandate &1 from &2 to &3.'.

    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '001':
        i_langu     = 'D'
        i_selfdef   = ''
        i_text      = 'Status des Mandats &1 kann nicht von &2 in &3 geändert werden.'.

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-016 IS INITIAL.
      DATA: l_natxt TYPE natxt.
      l_natxt = 'Cannot change status of mandate &1 from &2 to &3.'(016).
      CALL METHOD lcl_wb=>create_message                    "#EC *
        EXPORTING
          i_msgid     = 'SEPA_EN'
          i_msgno     = '001':
          i_langu     = sy-langu
          i_selfdef   = ''
          i_text      = l_natxt.
    ENDIF.

    "-- LIMU MESS SEPA_EN002 (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '002':
        i_langu     = 'E'
        i_selfdef   = '3'
        i_text      = 'Unallowed status must be different to the original status.'.

    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '002':
        i_langu     = 'D'
        i_selfdef   = '3'
        i_text      = 'Unzulässiger Status muss sich vom Originalstatus unterscheiden.'.

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-017 IS INITIAL.
      l_natxt = 'Unallowed status must be different to the original status.'(017).
      CALL METHOD lcl_wb=>create_message                    "#EC *
        EXPORTING
          i_msgid     = 'SEPA_EN'
          i_msgno     = '002':
          i_langu     = sy-langu
          i_selfdef   = '3'
          i_text      = l_natxt.
    ENDIF.

    "-- LIMU MESS SEPA_EN003 (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '003':
        i_langu     = 'E'
        i_selfdef   = ''
        i_text      = 'Cannot change status from &1 to &2.'.

    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '003':
        i_langu     = 'D'
        i_selfdef   = ''
        i_text      = 'Status kann nicht von &1 in &2 geändert werden.'.

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-018 IS INITIAL.
      l_natxt = 'Cannot change status from &1 to &2.'(018).
      CALL METHOD lcl_wb=>create_message                    "#EC *
        EXPORTING
          i_msgid     = 'SEPA_EN'
          i_msgno     = '003':
          i_langu     = sy-langu
          i_selfdef   = ''
          i_text      = l_natxt.
    ENDIF.

    "-- LIMU MESS SEPA_EN005 (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '005':
        i_langu     = 'E'
        i_selfdef   = '3'
        i_text      = 'Reason code &1 is invalid for status &2.'.

    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '005':
        i_langu     = 'D'
        i_selfdef   = '3'
        i_text      = 'Ursachencode &1 ist für Status &2 ungültig.'.

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-019 IS INITIAL.
      l_natxt = 'Reason code &1 is invalid for status &2.'(019).
      CALL METHOD lcl_wb=>create_message                    "#EC *
        EXPORTING
          i_msgid     = 'SEPA_EN'
          i_msgno     = '005':
          i_langu     = sy-langu
          i_selfdef   = '3'
          i_text      = l_natxt.
    ENDIF.

    "-- LIMU MESS SEPA_EN006 (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '006':
        i_langu     = 'E'
        i_selfdef   = '3'
        i_text      = 'Reason code &1 is invalid for status &2 for mandate &3.'.

    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '006':
        i_langu     = 'D'
        i_selfdef   = '3'
        i_text      = 'Ursachencode &1 ist für Status &2 für Mandat &3 ungültig.'.

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-020 IS INITIAL.
      l_natxt = 'Reason code &1 is invalid for status &2 for mandate &3.'(020).
      CALL METHOD lcl_wb=>create_message                    "#EC *
        EXPORTING
          i_msgid     = 'SEPA_EN'
          i_msgno     = '006':
          i_langu     = sy-langu
          i_selfdef   = '3'
          i_text      = l_natxt.
    ENDIF.

    "-- LIMU MESS SEPA_EN007 (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '007':
        i_langu     = 'E'
        i_selfdef   = ''
        i_text      = 'Cannot create mandate with status &1.'.

    CALL METHOD lcl_wb=>create_message                      "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '007':
        i_langu     = 'D'
        i_selfdef   = ''
        i_text      = 'Mandat kann nicht mit Status &1 angelegt werden.'.

    IF sy-langu NE 'E' AND sy-langu NE 'D' AND NOT text-021 IS INITIAL.
      l_natxt = 'Cannot create mandate with status &1.'(021).
      CALL METHOD lcl_wb=>create_message                    "#EC *
        EXPORTING
          i_msgid     = 'SEPA_EN'
          i_msgno     = '007':
          i_langu     = sy-langu
          i_selfdef   = ''
          i_text      = l_natxt.
    ENDIF.

    "-- LIMU DOCU NASEPA_EN001 (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_mess_docu                    "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '001'
        i_langu     = 'E'
        i_line      =:'U1 &CAUSE&',
                      'AS You cannot change status from &v2& to &v3& according to the Customizing',
                      '   setting.',
                      'U1 &SYSTEM_RESPONSE&',
                      'AS',
                      'U1 &WHAT_TO_DO&',
                      'AS Change to an allowed status. If you do need to change to status &v3&,',
                      '   contact your system administrator to adjust the Customizing setting.',
                      'U1 &SYS_ADMIN&',
                      'AS To define which statuses you cannot change a current status to, run',
                      '   transaction <DS:TRAS.SEPA_STATUS_CUST>SEPA_STATUS_CUST</>.',
                      space.

    CALL METHOD lcl_wb=>create_mess_docu                    "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '001'
        i_langu     = 'D'
        i_line      =:'U1 &CAUSE&',
                      'AS Aufgrund der Customizing-Einstellungen können Sie den Status nicht von',
                      '   &v2& in &v3& ändern.',
                      'U1 &SYSTEM_RESPONSE&',
                      'AS',
                      'U1 &WHAT_TO_DO&',
                      'AS Ändern Sie den Status in einen zulässigen Status. Wenn Sie den Status',
                      '   wirklich in &v3& ändern müssen, bitten Sie Ihren Systemadministrator,',
                      '   die Customizing-Einstellungen zu ändern.',
                      'U1 &SYS_ADMIN&',
                      'AS In welchen Status ein bestimmter Status nicht geändert werden kann,',
                      '   können Sie in Transaktion <DS:TRAS.SEPA_STATUS_CUST>SEPA_STATUS_CUST</>',
                      '   definieren.',
                      space.

    "-- LIMU DOCU NASEPA_EN003 (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_mess_docu                    "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '003'
        i_langu     = 'E'
        i_line      =:'U1 &CAUSE&',
                      'AS You cannot change status from &v1& to &v2& according to the Customizing',
                      '   setting.',
                      'U1 &SYSTEM_RESPONSE&',
                      'AS',
                      'U1 &WHAT_TO_DO&',
                      'AS Change to an allowed status. If you do need to change to status &v2&,',
                      '   contact your system administrator to adjust the Customizing setting.',
                      'U1 &SYS_ADMIN&',
                      'AS To define which statuses you cannot change a current status to, run',
                      '   transaction <DS:TRAS.SEPA_STATUS_CUST>SEPA_STATUS_CUST</>.',
                      space.

    CALL METHOD lcl_wb=>create_mess_docu                    "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '003'
        i_langu     = 'D'
        i_line      =:'U1 &CAUSE&',
                      'AS Aufgrund der Customizing-Einstellungen können Sie den Status nicht von',
                      '   &v1& in &v2& ändern.',
                      'U1 &SYSTEM_RESPONSE&',
                      'AS',
                      'U1 &WHAT_TO_DO&',
                      'AS Ändern Sie den Status in einen zulässigen Status. Wenn Sie den Status',
                      '   wirklich in &v2& ändern müssen, bitten Sie Ihren Systemadministrator,',
                      '   die Customizing-Einstellungen zu ändern.',
                      'U1 &SYS_ADMIN&',
                      'AS In welchen Status ein bestimmter Status nicht geändert werden kann,',
                      '   können Sie in Transaction <DS:TRAS.SEPA_STATUS_CUST>SEPA_STATUS_CUST</>',
                      '   definieren.',
                      space.


    "-- LIMU DOCU NASEPA_EN007 (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_mess_docu                    "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '007'
        i_langu     = 'E'
        i_line      =:'U1 &CAUSE&',
                      'AS You cannot create a mandate with status &v1& according to the',
                      '   Customizing setting.',
                      'U1 &SYSTEM_RESPONSE&',
                      'AS',
                      'U1 &WHAT_TO_DO&',
                      'AS Create the mandate with an allowed status. If you do need to create the',
                      '   mandate with status &v1&, contact your system administrator to adjust',
                      '   the Customizing setting.',
                      'U1 &SYS_ADMIN&',
                      'AS To define which statuses you cannot create a mandate with, run',
                      '   transaction',
                      '=   <DS:TRAS.SEPA_STATUS_CUST>SEPA_STATUS_CUST</>. In the Customizing',
                      '   screen, choose Entered in the Status column and choose a status in the',
                      '   Unallowed Status column.',
                      space.

    CALL METHOD lcl_wb=>create_mess_docu                    "#EC *
      EXPORTING
        i_msgid     = 'SEPA_EN'
        i_msgno     = '007'
        i_langu     = 'D'
        i_line      =:'U1 &CAUSE&',
                      'AS Aufgrund der Customizing-Einstellungen können Sie kein Mandat mit Status',
                      '=   &v1& anlegen.',
                      'U1 &SYSTEM_RESPONSE&',
                      'AS',
                      'U1 &WHAT_TO_DO&',
                      'AS Legen Sie das Mandat mit einem zulässigen Status an. Wenn Sie das Mandat',
                      '   unbedingt mit Status &v1& anlegen müssen, bitten Sie Ihren',
                      '   Systemadministrator, die Customizing-Einstellungen zu ändern.',
                      'U1 &SYS_ADMIN&',
                      'AS Mit welchen Status Sie keine Mandate anlegen können, können Sie in',
                      '   Transaktion <DS:TRAS.SEPA_STATUS_CUST>SEPA_STATUS_CUST</> definieren.',
                      '   Wählen Sie auf dem Customizing-Bild in der Spalte Status Erfasst aus und',
                      '   wählen Sie einen Status in der Spalte Unzuläss. Status aus.',
                      space.

    "- FUGR -------------------------------------------------------------------------- Function Group
    "-- R3TR FUGR SEPA_CUST_EN (language: EN , source: SI3 )
    CALL METHOD lcl_wb=>create_function_group               "#EC *
      EXPORTING
        i_devclass   = 'BF_SEPA_EN'
        i_area       = 'SEPA_CUST_EN'
        i_langu      = 'E'
        i_appl       = 'S'
        i_text       = 'Extended Table Maintenance (Generated)'.

    "- TRAN ---------------------------------------------------------------------------- Transactions
    DATA: l_rsparam TYPE rsparam,
          lt_sparam TYPE s_param.
    "-- R3TR TRAN SEPA_RC_CUST (language: EN , source: SI3 )

    CLEAR lt_sparam[].
    l_rsparam-field = 'VIEWNAME'.
    l_rsparam-value = 'V_SEPA_RC'.
    APPEND l_rsparam TO lt_sparam.
    l_rsparam-field = 'UPDATE'.
    l_rsparam-value = 'X'.
    APPEND l_rsparam TO lt_sparam.

    IF sy-langu NE 'D'.

      DATA: l_ttext TYPE tstct-ttext.
      l_ttext = 'SEPA: Reason for Status Change'(014).
      CALL METHOD lcl_wb=>create_transaction                "#EC *
        EXPORTING
          i_tcode     = 'SEPA_RC_CUST'
          i_devclass  = 'BF_SEPA_EN'
          i_langu     = sy-langu
          i_text      = l_ttext
          i_javagui   = 'X'
          i_htmlgui   = 'X'
          i_wingui    = 'X'
          i_type      = 'P'
          i_called_transaction = 'SM30'
          i_called_transaction_skip = 'X'
          i_param     = lt_sparam.

    ELSE.

      CALL METHOD lcl_wb=>create_transaction                "#EC *
        EXPORTING
          i_tcode     = 'SEPA_RC_CUST'
          i_devclass  = 'BF_SEPA_EN'
          i_langu     = 'D'
          i_text      = 'SEPA: Grund für Statusänderung'
          i_javagui   = 'X'
          i_htmlgui   = 'X'
          i_wingui    = 'X'
          i_type      = 'P'
          i_called_transaction = 'SM30'
          i_called_transaction_skip = 'X'
          i_param     = lt_sparam.

    ENDIF.

    "-- R3TR TRAN SEPA_STATUS_CUST (language: EN , source: SI3 )
    CLEAR lt_sparam[].
    l_rsparam-field = 'VIEWNAME'.
    l_rsparam-value = 'V_SEPA_STS_CUST'.
    APPEND l_rsparam TO lt_sparam.
    l_rsparam-field = 'UPDATE'.
    l_rsparam-value = 'X'.
    APPEND l_rsparam TO lt_sparam.

    IF sy-langu NE 'D'.

      l_ttext = 'SEPA: Unallowed Status Change'(015).
      CALL METHOD lcl_wb=>create_transaction                "#EC *
        EXPORTING
          i_tcode     = 'SEPA_STATUS_CUST'
          i_devclass  = 'BF_SEPA_EN'
          i_langu     = sy-langu
          i_text      = l_ttext
          i_javagui   = 'X'
          i_htmlgui   = 'X'
          i_wingui    = 'X'
          i_type      = 'P'
          i_called_transaction = 'SM30'
          i_called_transaction_skip = 'X'
          i_param     = lt_sparam.

    ELSE.

      CALL METHOD lcl_wb=>create_transaction                "#EC *
        EXPORTING
          i_tcode     = 'SEPA_STATUS_CUST'
          i_devclass  = 'BF_SEPA_EN'
          i_langu     = 'D'
          i_text      = 'SEPA: Unzulässige Statusänderung'
          i_javagui   = 'X'
          i_htmlgui   = 'X'
          i_wingui    = 'X'
          i_type      = 'P'
          i_called_transaction = 'SM30'
          i_called_transaction_skip = 'X'
          i_param     = lt_sparam.

    ENDIF.

  ENDIF.

  CALL METHOD lcl_wb=>activate.

*  "Call SE54 and regenerate without changing the screens
*  CALL METHOD lcl_wb=>regenerate_maint_view  "#EC *
*    EXPORTING
*      i_viewname   = 'V_SEPA_RC'.

*  "Call SE54 and regenerate without changing the screens
*  CALL METHOD lcl_wb=>regenerate_maint_view  "#EC *
*    EXPORTING
*      i_viewname   = 'V_SEPA_STS_CUST'.

ENDFORM.                    "action
